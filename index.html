<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>EDH RUMBLE TRACKER</title>
<style>
/* THEME VARS */
:root {
  --bg-main:#0f0f12;
  --bg-panel:#1a1a22;
  --bg-accent:#2a2a36;
  --border-soft:#3a3a4f;

  --text-primary:#f5f5fa;
  --text-dim:#8a8aa5;

  --gold:#d4a94f;
  --cyan:#5fd8d8;
  --magenta:#ff4acb;
  --lime:#5fd85f;
  --red:#d85f5f;
  --off:#55556e;

  --button-bg:#2a2a36;
  --button-border:#3a3a4f;

  --overlay-bg:rgba(0,0,0,0.8);

  --tool-bg:#1a1a22;
  --tool-border:#3a3a4f;
}

.theme-light {
  --bg-main:#ffffff;
  --bg-panel:#ffffff;
  --bg-accent:#f4f4fa;
  --border-soft:#bfbfd4;

  --text-primary:#1a1a22;
  --text-dim:#5a5a77;

  --gold:#9c7a1f;
  --cyan:#2a8f8f;
  --magenta:#b51882;
  --lime:#2a8f2a;
  --red:#a63f3f;
  --off:#8a8aa5;

  --button-bg:#ffffff;
  --button-border:#bfbfd4;

  --overlay-bg:rgba(0,0,0,0.6);

  --tool-bg:#ffffff;
  --tool-border:#bfbfd4;
}

.theme-neon {
  --bg-main:#050509;
  --bg-panel:#0e0e1a;
  --bg-accent:#1a1a33;
  --border-soft:#4a4aff;

  --text-primary:#ffeefe;
  --text-dim:#ff4aeb;

  --gold:#ffef5a;
  --cyan:#5fd8ff;
  --magenta:#ff4acb;
  --lime:#5CFFB6;
  --red:#ff4a6b;
  --off:#4f4f80;

  --button-bg:#1a1a33;
  --button-border:#4a4aff;

  --overlay-bg:rgba(0,0,30,0.8);

  --tool-bg:#0e0e1a;
  --tool-border:#4a4aff;
}

/* BASE */
*{
  box-sizing:border-box;
  font-family:system-ui, Roboto, "Helvetica Neue", Arial, sans-serif;
}
body{
  margin:0;
  background:var(--bg-main);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  justify-content:center;
}
button{
  cursor:pointer;
}
input, textarea, select, button {
  font-family:inherit;
}

/* APP SHELL */
.app-shell{
  width:100%;
  max-width:480px;
  min-height:100vh;
  background:var(--bg-main);
  display:flex;
  flex-direction:column;
  position:relative;
}

/* STICKY HEADER */
.top-header{
  position:sticky;
  top:0;
  z-index:1000;
  background:var(--bg-panel);
  border-bottom:1px solid var(--border-soft);
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:.6rem .75rem .5rem;
  gap:.4rem;
}
.game-title{
  font-size:clamp(.8rem,.6rem + .5vw,1rem);
  font-weight:700;
  letter-spacing:.05em;
  color:var(--text-primary);
  text-align:center;
}
.header-row{
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  align-items:baseline;
  gap:.75rem 1rem;
  text-align:center;
}
#turnBanner{
  font-size:clamp(.7rem,.5rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  letter-spacing:.05em;
}
#globalTimerBanner{
  font-size:clamp(.7rem,.5rem + .4vw,.9rem);
  font-weight:600;
  color:var(--text-primary);
  letter-spacing:.05em;
}

/* CONTENT */
.content-area{
  flex:1;
  overflow-y:auto;
  padding:1rem .75rem 5rem;
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* HUD CARD */
.hud-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  box-shadow:0 20px 40px rgba(0,0,0,.7);
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.hud-top-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  justify-content:space-between;
}
.hud-col{
  flex:1 1 220px;
  min-width:0;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.section-block-inline{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.respawn-draw-banner{
  background:rgba(212,169,79,.07);
  border:1px solid var(--gold);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.7rem;
  font-weight:600;
  line-height:1.3;
  color:var(--gold);
}
.label-sm{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.text-input{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.45rem .5rem;
  min-width:5rem;
  font-weight:600;
  width:100%;
}

/* STATUS/TIMERS */
.tiny-col-stack{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.tiny-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.status-chip{
  border-radius:.5rem;
  padding:.5rem;
  text-align:center;
  font-size:.7rem;
  font-weight:600;
  line-height:1.3;
  border:1px solid;
  cursor:pointer;
  min-width:5.5rem;
}
.status-active{
  color:var(--lime);
  border-color:var(--lime);
  background:rgba(95,216,95,.07);
}
.status-cooldown{
  color:var(--red);
  border-color:var(--red);
  background:rgba(216,95,95,.08);
}
.status-elim{
  color:var(--off);
  border-color:var(--off);
  background:rgba(85,85,110,.15);
}
.cd-info-inline{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
}
.cd-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.cd-val-box{
  min-width:2rem;
  text-align:center;
  font-size:.8rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
  color:var(--text-primary);
}

/* TIMERS */
.timer-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem 1rem;
  font-size:.7rem;
  line-height:1.3;
}
.timer-block{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.timer-label{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.timer-val{
  font-size:clamp(.8rem,.6rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  min-width:3.5rem;
}

/* VITALS */
.vitalsBlock .life-row{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.life-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:1rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2.2rem;
  text-align:center;
  color:var(--text-primary);
}
.life-value{
  min-width:3rem;
  text-align:center;
  font-size:1.2rem;
  font-weight:700;
  color:var(--text-primary);
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .6rem;
  line-height:1.2;
}
.mini-counters-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(100px,100%),1fr));
  gap:.5rem;
}
.mini-counter-box{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.4rem;
  font-size:.7rem;
  text-align:center;
}
.mini-counter-label{
  font-size:.65rem;
  line-height:1.2;
  color:var(--text-dim);
}
.mini-step-row{
  display:flex;
  align-items:center;
  gap:.4rem;
  font-size:.8rem;
  font-weight:600;
}
.step-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.step-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
  color:var(--text-primary);
}

/* END TURN BUTTON */
.end-turn-btn{
  background:var(--gold);
  border:none;
  border-radius:.5rem;
  padding:.8rem .9rem;
  font-size:clamp(.8rem,.5rem + .5vw,.9rem);
  font-weight:700;
  color:#000;
  text-align:center;
  box-shadow:0 10px 20px rgba(0,0,0,.6);
  width:100%;
}

/* OTHERS */
.others-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.other-header{
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.other-player-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  overflow:hidden;
}
.other-player-top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  cursor:pointer;
}
.other-expand-indicator{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
}
.other-player-body{
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  display:none;
  flex-direction:column;
  gap:.75rem;
  font-size:.75rem;
}
.status-line-other{
  font-size:.7rem;
  font-weight:600;
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:center;
}
.life-edit-inline{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.life-inline-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.life-inline-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
}
.mini-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:flex-start;
}
.mini-col{
  display:flex;
  flex-direction:column;
  gap:.4rem;
}

/* COMMANDER DAMAGE GRID */
.cdmg-section-wrap{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.cdmg-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.cdmg-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(140px,100%),1fr));
  gap:.5rem .75rem;
}
.cdmg-cell{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  gap:.4rem;
  font-size:.7rem;
}
.cdmg-cell-label{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.2;
}
.cdmg-input-row{
  display:flex;
  gap:.5rem;
  align-items:flex-end;
}
.cdmg-input-row input{
  width:3rem;
  text-align:center;
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.4rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
}

/* PLAYER NOTE IN OTHERS */
.mini-note-box{
  display:flex;
  flex-direction:column;
  gap:.4rem;
  width:100%;
}
.mini-note-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.mini-area-input{
  width:100%;
  min-height:2rem;
  resize:vertical;
  font-size:.7rem;
  padding:.5rem .6rem;
  line-height:1.3;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
}

/* ACCORDIONS (Status Effects / Notes) */
.accordion-block{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  overflow:hidden;
}
.accordion-head{
  background:var(--bg-accent);
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .75rem;
  cursor:pointer;
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.accordion-head .hint{
  color:var(--text-dim);
  font-size:.6rem;
  font-weight:400;
  margin-left:.5rem;
}
.accordion-body{
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  display:none;
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
  display:flex;
  flex-direction:column;
  gap:1rem;
}
.row-flex{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .5rem;
}
.toggle-chip{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .5rem;
  font-size:.7rem;
  color:var(--text-primary);
  text-align:center;
  cursor:pointer;
}
.toggle-chip.active{
  box-shadow:0 0 10px var(--magenta);
  border-color:var(--text-dim);
  font-weight:600;
}
.subsection-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.area-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  width:100%;
  min-height:3rem;
  resize:vertical;
  font-size:.7rem;
  font-weight:400;
  color:var(--text-primary);
  line-height:1.3;
}
.lookup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  align-items:flex-end;
}
.lookup-col{
  flex:1;
  min-width:8rem;
  display:flex;
  flex-direction:column;
  gap:.4rem;
}
.lookup-input{
  width:100%;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.45rem .5rem;
  font-weight:600;
}
.lookup-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
  min-width:5rem;
}
.lookup-preview-block{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  font-size:.7rem;
  line-height:1.3;
  color:var(--text-primary);
}
.lookup-cardtext{
  flex:2;
  min-width:10rem;
  white-space:pre-line;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
}
.lookup-cardimg{
  flex:1;
  min-width:6rem;
  max-width:140px;
  border-radius:.5rem;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  overflow:hidden;
  align-self:flex-start;
}
.lookup-cardimg img{
  width:100%;
  height:auto;
  display:block;
}

/* FOOTER / TOOLS DOCK */
.tools-footer-wrap{
  position:sticky;
  bottom:0;
  z-index:1000;
  background:var(--tool-bg);
  border-top:1px solid var(--tool-border);
}
.tools-header-btn{
  width:100%;
  background:none;
  border:none;
  text-align:center;
  color:var(--text-primary);
  font-size:.75rem;
  font-weight:600;
  letter-spacing:.05em;
  padding:.6rem .75rem;
}
.tools-panel{
  border-top:1px solid var(--tool-border);
  display:none;
  padding:.75rem;
  font-size:.75rem;
  color:var(--text-primary);
  background:var(--tool-bg);
  max-height:50vh;
  overflow-y:auto;
}
.tools-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(200px,100%),1fr));
  gap:.75rem;
}
.tool-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.tool-title{
  font-size:.65rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.rng-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.rng-btn{
  flex:1;
  min-width:4rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
  padding:.6rem .75rem;
  text-align:center;
}
.rng-output{
  font-size:.8rem;
  font-weight:600;
  min-height:1em;
  line-height:1.2;
  color:var(--gold);
  word-break:break-word;
}
.theme-select{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:100%;
}
.global-cardtext{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  white-space:pre-line;
  font-size:.7rem;
  line-height:1.3;
  color:var(--text-primary);
}
.global-cardimg{
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  background:var(--bg-panel);
  overflow:hidden;
  max-width:140px;
}
.global-cardimg img{
  display:block;
  width:100%;
  height:auto;
}
.winner-mini-banner{
  border:1px solid var(--gold);
  color:var(--gold);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1.4;
  display:none;
  word-break:break-word;
}
.mode-line{
  font-size:.7rem;
  line-height:1.3;
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.mode-btn-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.mode-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.rules-scroll-block{
  max-height:200px;
  overflow-y:auto;
  font-size:.7rem;
  line-height:1.4;
  white-space:pre-line;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  color:var(--text-primary);
}

/* OVERLAYS */
.overlay-fullscreen{
  position:fixed;
  inset:0;
  background:var(--overlay-bg);
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:1rem;
}
.setup-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  display:flex;
  flex-direction:column;
  gap:1rem;
  text-align:center;
}
.setup-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.setup-sub{
  font-size:.7rem;
  color:var(--text-dim);
  line-height:1.4;
}
.setup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  justify-content:center;
}
.setup-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.setup-small{
  display:flex;
  flex-direction:column;
  gap:.5rem;
  align-items:center;
}
.setup-number-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:5rem;
  text-align:center;
}
.setup-go{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.5rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
}
.helper-row{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.3;
  text-align:center;
}

/* Winner overlay */
.winner-card{
  background:var(--bg-panel);
  border:2px solid var(--gold);
  border-radius:1rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  text-align:center;
  display:flex;
  flex-direction:column;
  gap:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.6),0 40px 80px rgba(0,0,0,.9);
}
.winner-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--gold);
  line-height:1.3;
  word-break:break-word;
}
.winner-line{
  font-size:.8rem;
  font-weight:500;
  color:var(--text-primary);
  line-height:1.4;
}
.overlay-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}

/* Announce / Cooldown popup */
.announce-card{
  background:var(--bg-panel);
  border:2px solid var(--gold);
  border-radius:1rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  text-align:center;
  display:flex;
  flex-direction:column;
  gap:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.6),0 40px 80px rgba(0,0,0,.9);
  font-size:.8rem;
  line-height:1.4;
  color:var(--text-primary);
}
.announce-strong{
  color:var(--gold);
  font-weight:700;
  font-size:.9rem;
  line-height:1.3;
}
</style>
</head>
<body class="theme-neon">
<div class="app-shell">

  <!-- SETUP OVERLAY -->
  <div id="setupOverlay" class="overlay-fullscreen">
    <div class="setup-card" id="setupStepMode">
      <div class="setup-title">Select Mode</div>
      <div class="setup-row">
        <button class="setup-btn" data-mode="regular">
          Mode 1 — Regular
          <div class="setup-sub">Standard Commander. No respawn.</div>
        </button>
        <button class="setup-btn" data-mode="rumble">
          Mode 2 — Rumble
          <div class="setup-sub">Cooldown / Respawn / Reigning Rumbler.</div>
        </button>
      </div>
      <div class="helper-row">You’ll pick player count next.</div>
    </div>

    <div class="setup-card" id="setupStepPlayers" style="display:none;">
      <div class="setup-title">How many players?</div>
      <div class="setup-row">
        <button class="setup-btn" data-fixedplayers="2">2</button>
        <button class="setup-btn" data-fixedplayers="3">3</button>
        <button class="setup-btn" data-fixedplayers="4">4</button>
      </div>
      <div class="setup-small">
        <div class="label-sm" style="text-align:center;">Manual Entry (2–8)</div>
        <input id="manualPlayerCount" class="setup-number-input" type="number" min="2" max="8" value="5" />
        <button id="manualStartBtn" class="setup-go">Start Game</button>
      </div>
      <div class="helper-row">Rename yourself on your turn.</div>
    </div>
  </div>

  <!-- WINNER OVERLAY -->
  <div id="winnerOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="winner-card">
      <div class="winner-title" id="winnerTitle">REIGNING RUMBLER!</div>
      <div class="winner-line" id="winnerTimeLine">Global Time: 00m 00s</div>
      <div class="winner-line" id="winnerPlayerTimeLine">Winner Player Time: 00m 00s</div>
      <button class="overlay-btn" id="winnerCloseBtn">OK</button>
    </div>
  </div>

  <!-- ANNOUNCE OVERLAY (used for cooldown acknowledge + respawn + reminders) -->
  <div id="announceOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="announce-card">
      <div class="announce-strong" id="announceMain">Announcement</div>
      <div id="announceBody">Body text.</div>
      <button class="overlay-btn" id="announceOkBtn">OK</button>
    </div>
  </div>

  <!-- HEADER -->
  <div class="top-header">
    <div class="game-title">EDH RUMBLE TRACKER</div>
    <div class="header-row">
      <div id="turnBanner">▶ PLAYER 1'S TURN ◀</div>
      <div id="globalTimerBanner">Global: 0:00</div>
    </div>
  </div>

  <!-- MAIN CONTENT -->
  <div class="content-area" id="contentArea">
    <div id="hudArea"></div>

    <button class="end-turn-btn" id="endTurnBtn">End Turn →</button>

    <div id="othersArea"></div>

    <div id="accordionsArea"></div>
  </div>

  <!-- TOOLS / FOOTER -->
  <div class="tools-footer-wrap">
    <button class="tools-header-btn" id="toggleToolsBtn">Tools ▼</button>
    <div class="tools-panel" id="toolsPanel">
      <div class="tools-grid">

        <div class="tool-block">
          <div class="tool-title">Theme</div>
          <select id="themeSelect" class="theme-select">
            <option value="theme-dark">Dark</option>
            <option value="theme-light">Light</option>
            <option value="theme-neon" selected>Neon</option>
          </select>
        </div>

        <div class="tool-block">
          <div class="tool-title">Randomizers</div>
          <div class="rng-row">
            <button class="rng-btn" id="flipCoinBtn">Coin Flip</button>
            <button class="rng-btn" id="rollD6Btn">d6</button>
            <button class="rng-btn" id="rollD20Btn">d20</button>
          </div>
          <div class="rng-output" id="rngOutput"></div>
        </div>

        <div class="tool-block">
          <div class="tool-title">Card Lookup (Scryfall)</div>
          <div class="lookup-row">
            <div class="lookup-col">
              <input id="globalLookupInput" class="lookup-input" placeholder="Any card..." />
              <button id="globalLookupBtn" class="lookup-btn">Lookup</button>
            </div>
          </div>
          <div class="lookup-preview-block" id="globalLookupPreview">
            <div class="lookup-cardtext" id="globalLookupText"></div>
            <div class="lookup-cardimg" id="globalLookupImg" style="display:none;">
              <img id="globalLookupImgTag" alt="card art"/>
            </div>
          </div>
        </div>

        <div class="tool-block">
          <div class="tool-title">Game Control</div>
          <div class="mode-line">
            <div id="modeStatusText">Mode 2 — Rumble</div>
            <div id="winnerMiniBanner" class="winner-mini-banner"></div>
            <div class="mode-btn-row">
              <button class="mode-btn" id="newGameBtn">New Game</button>
              <button class="mode-btn" id="changeModeBtn">Change Mode</button>
            </div>
          </div>
        </div>

        <div class="tool-block">
          <div class="tool-title">Rumble Rules</div>
          <div class="rules-scroll-block" id="rulesBlock">
Rumble Rules

Setup
- Normal Commander decks (100-card singleton, color identity).
- Start 40 life, 0 poison.
- Commander damage (21 from one commander) and decking out still permanently eliminate you.

Temporary Knockout (Cooldown)
You go on cooldown instead of leaving the game if:
- Your life is 0 or less,
- You have 10 or more poison counters, or
- An effect says “you lose the game.”
“Win the game” effects do nothing in Rumble.
Your cooldown is 1 + the number of players already on cooldown when you go out.

Permanent Elimination
You are out of the game (no cooldown) if:
- You’ve taken 21+ combat damage from a single commander this game, or
- You would draw a card and can’t (decked out).

Cooldown
While on cooldown:
- You are not active.
- You take no game actions.
- You can’t block, cast, respond, or be targeted as a player.
- Your battlefield remains in play, and opponents can interact with it freely.
- Your hand / graveyard / command zone stay.
- Triggers that need your choices are ignored; passive effects still work.

Cooldown Turns
Turn order still moves seat by seat.
When it reaches a cooldown player, that player doesn’t get a normal turn. Instead, they acknowledge their cooldown:
- Their cooldown counter goes down by 1.
- If it’s still above 0, they remain out.
- If it hits 0, they immediately respawn.

Respawn
When you respawn:
- You become active again.
- Your life becomes the average life total of all active players, rounded up.
- You lose all poison counters.
- Your commander tax resets.
- You regain control of whatever permanents of yours are still on the battlefield.
First Turn Back:
- On the first real turn you actually take after respawning,
  you skip your normal draw step, then draw 1 at the end of that turn instead.

Reigning Rumbler
If exactly one player is active and everyone else is either eliminated or on cooldown, that player becomes the Reigning Rumbler.
After that player finishes their next full active turn, if they are still the only active player, they win the game.

Regular Mode
- No cooldown or respawn.
- 0 life / 10 poison / “lose the game” knocks you out permanently.
- Last surviving player wins immediately.
          </div>
        </div>

      </div>
    </div>
  </div>

</div> <!-- /app-shell -->

<script>
/* =========================
   GLOBAL STATE
========================= */

let gameMode = null; // "regular" | "rumble"
let players = [];
let turnIndex = 0;
let turnCounter = 0;
let gameStartTime = null;

let reigningCandidateIndex = null;
let reigningCandidateTurnStamp = null;

let winnerLocked = false;
let winnerName = "";
let winnerTimeMs = 0;
let winnerActiveMs = 0;

// accordion open states
let accordionsOpen = {
  statusEffects:false,
  notes:true
};

// dropdown persistence for "other players"
let otherOpen = {};

let renderIntervalId = null;

// announce overlay usage flags
let showingAnnounce = false;

// after showing "draw at end of turn" reminder
let pendingClearAfterAnnounce = null;

// cooldown handoff state
let cooldownAcknowledgeIndex = null;
let pendingTurnAdvance = false;

/* GLOBAL PLANE / SCHEME STATE (shared table effects) */
let currentPlaneName   = "";
let currentPlaneText   = "";
let currentPlaneImg    = "";

let currentSchemeName  = "";
let currentSchemeText  = "";
let currentSchemeImg   = "";

/* DOM refs */
const setupOverlay           = document.getElementById("setupOverlay");
const setupStepMode          = document.getElementById("setupStepMode");
const setupStepPlayers       = document.getElementById("setupStepPlayers");
const manualPlayerCount      = document.getElementById("manualPlayerCount");
const manualStartBtn         = document.getElementById("manualStartBtn");

const winnerOverlay          = document.getElementById("winnerOverlay");
const winnerTitle            = document.getElementById("winnerTitle");
const winnerTimeLine         = document.getElementById("winnerTimeLine");
const winnerPlayerTimeLine   = document.getElementById("winnerPlayerTimeLine");
const winnerCloseBtn         = document.getElementById("winnerCloseBtn");
const winnerMiniBanner       = document.getElementById("winnerMiniBanner");

const announceOverlay        = document.getElementById("announceOverlay");
const announceMain           = document.getElementById("announceMain");
const announceBody           = document.getElementById("announceBody");
const announceOkBtn          = document.getElementById("announceOkBtn");

const turnBanner             = document.getElementById("turnBanner");
const globalTimerBanner      = document.getElementById("globalTimerBanner");

const hudArea                = document.getElementById("hudArea");
const endTurnBtn             = document.getElementById("endTurnBtn");
const othersArea             = document.getElementById("othersArea");
const accordionsArea         = document.getElementById("accordionsArea");

const toggleToolsBtn         = document.getElementById("toggleToolsBtn");
const toolsPanel             = document.getElementById("toolsPanel");

const themeSelect            = document.getElementById("themeSelect");
const flipCoinBtn            = document.getElementById("flipCoinBtn");
const rollD6Btn              = document.getElementById("rollD6Btn");
const rollD20Btn             = document.getElementById("rollD20Btn");
const rngOutput              = document.getElementById("rngOutput");

const modeStatusText         = document.getElementById("modeStatusText");
const newGameBtn             = document.getElementById("newGameBtn");
const changeModeBtn          = document.getElementById("changeModeBtn");

const globalLookupInput      = document.getElementById("globalLookupInput");
const globalLookupBtn        = document.getElementById("globalLookupBtn");
const globalLookupText       = document.getElementById("globalLookupText");
const globalLookupPreview    = document.getElementById("globalLookupPreview");
const globalLookupImg        = document.getElementById("globalLookupImg");
const globalLookupImgTag     = document.getElementById("globalLookupImgTag");

/* =========================
   UTILITIES
========================= */

function msToClock(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins + ":" + (secs<10?("0"+secs):secs);
}
function formatDurationMs(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins+"m "+secs+"s";
}
function getGameElapsedMs(){
  if(!gameStartTime) return 0;
  return Date.now()-gameStartTime;
}

function getAvgActiveLifeCeil(excludeIndex){
  let sum=0;
  let ct=0;
  players.forEach((pl,i)=>{
    if(i===excludeIndex) return;
    if(pl.status==="active"){
      sum+=pl.life;
      ct++;
    }
  });
  if(ct===0){
    return 1;
  }
  return Math.ceil(sum/ct);
}

function makePlayer(defaultName){
  return {
    name: defaultName,

    status:"active",          // "active","cooldown","eliminated"
    cooldownRemaining:0,

    life:40,
    poison:0,
    radiation:0,
    energy:0,
    experience:0,
    storm:0,

    hasMonarch:false,
    hasInitiative:false,
    hasCitysBlessing:false,

    dungeonProgress:"",
    emblemsText:"",
    notesText:"",

    dungeonLookupName:"",
    dungeonPreviewText:"",
    dungeonPreviewImg:"",

    emblemLookupName:"",
    emblemPreviewText:"",
    emblemPreviewImg:"",

    commanderTaxSteps:0,

    commanderDamage:[], // victim.commanderDamage[srcIdx] = dmg

    totalActiveMs:0,
    turnStartMs:null,
    isTiming:false,

    pendingEOTDraw:false // skip first-draw, draw at EOT
  };
}

function syncCommanderDamageArrays(){
  players.forEach(p=>{
    while(p.commanderDamage.length < players.length){
      p.commanderDamage.push(0);
    }
    if(p.commanderDamage.length > players.length){
      p.commanderDamage.length = players.length;
    }
  });
}

function getActivePlayers(){
  const arr=[];
  players.forEach((pl,i)=>{
    if(pl.status==="active"){
      arr.push(i);
    }
  });
  return arr;
}

/* timing */
function startTimingPlayer(i){
  const p=players[i];
  if(p.status!=="active") return;
  p.isTiming=true;
  p.turnStartMs=Date.now();
}
function stopTimingPlayer(i){
  const p=players[i];
  if(!p.isTiming) return;
  const now=Date.now();
  const diff = now-(p.turnStartMs||now);
  p.totalActiveMs += diff;
  p.isTiming=false;
  p.turnStartMs=null;
}
function getPlayerTurnMs(p){
  if(p.isTiming && p.turnStartMs!=null){
    return Date.now()-p.turnStartMs;
  }
  return 0;
}
function getPlayerTotalMs(p){
  return p.totalActiveMs+getPlayerTurnMs(p);
}

/* =========================
   OVERLAY HELPERS
========================= */

function showAnnounce(mainTxt, bodyTxt, okLabel="OK"){
  showingAnnounce=true;
  announceMain.textContent = mainTxt;
  announceBody.textContent = bodyTxt;
  announceOkBtn.textContent = okLabel;
  announceOverlay.style.display="flex";
}

function hideAnnounce(){
  showingAnnounce=false;
  announceOverlay.style.display="none";
}

/* =========================
   KNOCKOUT / ELIMINATION
========================= */
function permanentlyEliminate(i){
  const p=players[i];
  stopTimingPlayer(i);
  p.status="eliminated";
  p.cooldownRemaining=0;
  p.pendingEOTDraw=false;
  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

function checkCommanderDamageElim(victimIdx){
  const p = players[victimIdx];
  for(let src=0; src<p.commanderDamage.length; src++){
    if(p.commanderDamage[src] >= 21){
      permanentlyEliminate(victimIdx);
      break;
    }
  }
}

function knockOutToCooldown(i){
  const p=players[i];

  if(gameMode==="regular"){
    // regular = perm out
    permanentlyEliminate(i);
    showAnnounce(
      (p.name||("Player "+(i+1)))+" eliminated",
      "Regular mode: 0 life / 10 poison / lose-the-game is final.",
      "OK"
    );
    return;
  }

  if(p.status==="eliminated" || p.status==="cooldown") return;

  stopTimingPlayer(i);

  // cooldown = 1 + other cooldown players
  let alreadyCooling=0;
  players.forEach((q,qi)=>{
    if(qi!==i && q.status==="cooldown") alreadyCooling++;
  });

  p.status="cooldown";
  p.cooldownRemaining=1+alreadyCooling;
  p.pendingEOTDraw=false;

  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }

  showAnnounce(
    (p.name||("Player "+(i+1)))+" knocked out",
    "Entered cooldown for "+p.cooldownRemaining+" turn(s). You’ll acknowledge each cooldown turn instead of taking a normal turn.",
    "OK"
  );
}

/* =========================
   RESPAWN
========================= */
function respawnPlayer(i){
  const p=players[i];
  if(p.status!=="cooldown") return;

  const newLife=getAvgActiveLifeCeil(i);

  p.status="active";
  p.cooldownRemaining=0;
  p.poison=0;
  p.life=newLife;
  p.commanderTaxSteps=0;
  p.pendingEOTDraw=true;

  showAnnounce(
    (p.name||("Player "+(i+1)))+" respawned",
    "Life "+newLife+" (avg rounded up), poison = 0, commander tax reset.\nIMPORTANT: On your first real turn back you skip your normal draw step and instead draw 1 at END of that turn.",
    "OK"
  );
}

/* =========================
   REIGNING RUMBLER
========================= */
function updateReigningCandidateAfterTurnEnd(){
  if(gameMode!=="rumble" || winnerLocked) return;

  const actives=getActivePlayers();
  if(actives.length===1){
    const onlyIdx=actives[0];
    if(reigningCandidateIndex===null || reigningCandidateIndex!==onlyIdx){
      reigningCandidateIndex=onlyIdx;
      reigningCandidateTurnStamp=turnCounter;
      showAnnounce(
        (players[onlyIdx].name||("Player "+(onlyIdx+1)))+" is now REIGNING RUMBLER",
        "If no one else becomes active before they finish their next full turn, they win.",
        "OK"
      );
    }
  }else{
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

function checkReigningWin(){
  if(gameMode!=="rumble" || winnerLocked) return false;
  if(reigningCandidateIndex===null) return false;

  const actives=getActivePlayers();
  if(actives.length!==1) return false;
  const onlyIdx=actives[0];
  if(onlyIdx!==reigningCandidateIndex) return false;

  // must survive as sole active through their next full turn
  if(turnCounter>(reigningCandidateTurnStamp+1)){
    lockWinner(onlyIdx,true);
    return true;
  }
  return false;
}

/* =========================
   WIN CHECKS
========================= */
function checkForWinRegular(){
  if(gameMode!=="regular" || winnerLocked) return false;
  const stillIn = players.filter(p=>p.status!=="eliminated");
  if(stillIn.length===1){
    const idx = players.indexOf(stillIn[0]);
    lockWinner(idx,false);
    return true;
  }
  return false;
}

function lockWinner(idx,isRumble){
  winnerLocked=true;
  winnerName = players[idx].name || ("Player "+(idx+1));
  winnerTimeMs = Date.now()-gameStartTime;
  winnerActiveMs = getPlayerTotalMs(players[idx]);

  if(isRumble){
    winnerTitle.textContent = winnerName.toUpperCase()+" — REIGNING RUMBLER!";
  } else {
    winnerTitle.textContent = winnerName+" wins the game!";
  }
  winnerTimeLine.textContent =
    "Global Time: "+formatDurationMs(winnerTimeMs);
  winnerPlayerTimeLine.textContent =
    "Winner Player Time: "+formatDurationMs(winnerActiveMs);

  winnerMiniBanner.style.display="block";
  winnerMiniBanner.textContent =
    winnerName+
    (isRumble? " — REIGNING RUMBLER! ":" wins!")+
    " ("+formatDurationMs(winnerTimeMs)+")";

  winnerOverlay.style.display="flex";
}
winnerCloseBtn.addEventListener("click",()=>{
  winnerOverlay.style.display="none";
});

/* =========================
   TURN / COOLDOWN FLOW
========================= */

// Reminder popup at end of a respawned player's first real turn
function runEndOfTurnDrawIfNeeded(idx){
  const p=players[idx];
  if(!p) return;
  if(p.pendingEOTDraw){
    pendingClearAfterAnnounce = idx;
    showAnnounce(
      (p.name||("Player "+(idx+1)))+" draw reminder",
      "Draw 1 card now. (You skipped your normal draw step this turn.)",
      "OK"
    );
  }
}

// Called when active player taps End Turn
function passTurn(){
  if(winnerLocked){
    renderAll();
    return;
  }

  // wrap up the current active player's real turn
  stopTimingPlayer(turnIndex);

  runEndOfTurnDrawIfNeeded(turnIndex);

  // we just finished a real, actual turn
  turnCounter += 1;

  // check/crown reigning candidate after finishing this turn
  updateReigningCandidateAfterTurnEnd();

  // prepare to walk seats until we land on next active or resolve cooldown acknowledgements
  pendingTurnAdvance = true;
  cooldownAcknowledgeIndex = null;

  advanceTurn();
}

// step through seats clockwise until:
// - we hit eliminated -> skip
// - we hit cooldown -> pause with cooldown popup
// - we hit active   -> that becomes next real turn
function advanceTurn(){
  // if winner already locked, just render
  if(winnerLocked){
    renderAll();
    return;
  }

  let safety=0;
  while(safety<100){
    // next seat
    turnIndex = (turnIndex+1)%players.length;
    const pl = players[turnIndex];

    // eliminated? skip
    if(pl.status==="eliminated"){
      safety++;
      continue;
    }

    // cooldown seat? pause here and force acknowledge
    if(pl.status==="cooldown"){
      cooldownAcknowledgeIndex = turnIndex;
      showCooldownPopup(turnIndex);
      return; // wait for acknowledge
    }

    // found an active player, they get the next real turn
    if(pl.status==="active"){
      startTimingPlayer(turnIndex);

      // regular immediate win check
      if(gameMode==="regular"){
        if(checkForWinRegular()){
          renderAll();
          return;
        }
      }

      // reigning rumbler win check
      if(checkReigningWin()){
        renderAll();
        return;
      }

      // done advancing
      pendingTurnAdvance=false;
      cooldownAcknowledgeIndex=null;
      renderAll();
      return;
    }

    safety++;
  }

  // fallback
  pendingTurnAdvance=false;
  cooldownAcknowledgeIndex=null;
  renderAll();
}

// show the cooldown acknowledge popup for a cooldown seat
function showCooldownPopup(i){
  const p=players[i];
  const nm = p.name||("Player "+(i+1));

  // "You are cooling down. Remaining N turn(s)."
  const bodyTxt =
    "Cooldown remaining: "+p.cooldownRemaining+" turn(s).\n" +
    "You do nothing this turn.\n" +
    "Tap Acknowledge to continue.";

  showAnnounce(
    nm+" is cooling down",
    bodyTxt,
    "Acknowledge →"
  );
}

// handle clicking "OK"/"Acknowledge →" on announce overlay
announceOkBtn.addEventListener("click",()=>{
  hideAnnounce();

  // CASE 1: we were showing an end-of-turn draw reminder
  if(pendingClearAfterAnnounce !== null){
    const p = players[pendingClearAfterAnnounce];
    if(p){
      p.pendingEOTDraw=false;
    }
    pendingClearAfterAnnounce=null;
    // after draw reminder, we just return to board
    renderAll();
    return;
  }

  // CASE 2: we're in a cooldown acknowledgment step
  if(cooldownAcknowledgeIndex !== null){
    const idx = cooldownAcknowledgeIndex;
    const pl = players[idx];

    if(pl && pl.status==="cooldown"){
      // spend 1 cooldown "turn"
      if(pl.cooldownRemaining>0){
        pl.cooldownRemaining -= 1;
        if(pl.cooldownRemaining<0) pl.cooldownRemaining=0;
      }

      // if done cooling, respawn now
      if(pl.cooldownRemaining===0){
        respawnPlayer(idx);
        // after respawnPlayer() we just showed a respawn popup via showAnnounce().
        // when that popup ends (user hits OK again), we should continue advancing.
        // So we hook that logic up by stashing who we just respawned.
        // Easiest: remember who just respawned in cooldownAcknowledgeIndex
        // and wait for the next click.
        // BUT respawnPlayer() already triggered showAnnounce(...) which re-opened
        // the announceOverlay and reset cooldownAcknowledgeIndex? No, we didn't reset it there.
        // We'll handle that below: we don't advanceTurn() immediately here if we just respawned,
        // because there's now an active respawn popup open.
        //
        // So we mark a flag so the NEXT click continues.
        // We'll do that by storing a special value:
        pl._justRespawned = true;
        return; // wait for the respawn popup "OK"
      }
    }

    // if still cooling OR eliminated somehow, continue walking
    cooldownAcknowledgeIndex=null;
    advanceTurn();
    return;
  }

  // CASE 3: if we just ended a respawn popup
  // check if anyone has _justRespawned
  let foundRespawnIdx=-1;
  players.forEach((p,i)=>{
    if(p._justRespawned){
      foundRespawnIdx=i;
    }
  });
  if(foundRespawnIdx>=0){
    // clear flag
    players[foundRespawnIdx]._justRespawned=false;
    // that player is now active, but they do NOT immediately get full turn here.
    // We still need to continue advancing seats until we land on the next real ACTIVE turn holder.
    cooldownAcknowledgeIndex=null;
    advanceTurn();
    return;
  }

  // default close behavior (generic announce not tied to cooldown or EOT draw)
  renderAll();
});

/* =========================
   THEME / TOOLS
========================= */
toggleToolsBtn.addEventListener("click",()=>{
  if(toolsPanel.style.display==="block"){
    toolsPanel.style.display="none";
    toggleToolsBtn.textContent="Tools ▼";
  } else {
    toolsPanel.style.display="block";
    toggleToolsBtn.textContent="Tools ▲";
  }
});

themeSelect.addEventListener("change",()=>{
  document.body.classList.remove("theme-dark","theme-light","theme-neon");
  document.body.classList.add(themeSelect.value);
});

flipCoinBtn.addEventListener("click",()=>{
  rngOutput.textContent="Coin: "+(Math.random()<0.5?"Heads":"Tails");
});
rollD6Btn.addEventListener("click",()=>{
  rngOutput.textContent="d6: "+(Math.floor(Math.random()*6)+1);
});
rollD20Btn.addEventListener("click",()=>{
  rngOutput.textContent="d20: "+(Math.floor(Math.random()*20)+1);
});

newGameBtn.addEventListener("click",()=>{
  if(!confirm("Start a new game in the same mode? This clears all data.")) return;
  showPlayerCountStep();
});
changeModeBtn.addEventListener("click",()=>{
  if(!confirm("Change mode? This restarts the game.")) return;
  showModeStep();
});

/* =========================
   SCRYFALL HELPERS
========================= */
async function scryfallFuzzy(name){
  if(!name.trim()) return null;
  const url="https://api.scryfall.com/cards/named?fuzzy="+encodeURIComponent(name.trim());
  try{
    const resp=await fetch(url);
    if(!resp.ok) return null;
    return await resp.json();
  }catch(e){
    return null;
  }
}
function extractCardImage(data){
  if(!data) return "";
  if(data.image_uris && data.image_uris.normal){
    return data.image_uris.normal;
  }
  if(Array.isArray(data.card_faces)
   && data.card_faces[0]
   && data.card_faces[0].image_uris){
    return data.card_faces[0].image_uris.normal||"";
  }
  return "";
}

/* Global lookup (Tools panel) */
async function lookupAnyCardGlobal(){
  const rawName = globalLookupInput.value||"";
  const data = await scryfallFuzzy(rawName);
  if(!data){
    globalLookupText.textContent="Not found / offline.";
    globalLookupImg.style.display="none";
    globalLookupImgTag.removeAttribute("src");
    return;
  }
  const typeLine=data.type_line||"";
  const oracle=data.oracle_text||"";
  const nm=data.name||rawName.trim();

  globalLookupText.textContent = (typeLine?typeLine+"\n":"")+oracle;
  const imgUrl=extractCardImage(data);
  if(imgUrl){
    globalLookupImgTag.src=imgUrl;
    globalLookupImg.style.display="block";
  }else{
    globalLookupImg.style.display="none";
    globalLookupImgTag.removeAttribute("src");
  }
}
globalLookupBtn.addEventListener("click",()=>{
  lookupAnyCardGlobal();
});

/* Dungeon lookup (per-player) */
async function lookupDungeonForPlayer(i){
  const p=players[i];
  const rawName=p.dungeonLookupName||"";
  const data=await scryfallFuzzy(rawName);
  if(!data){
    p.dungeonPreviewText="Not found / offline.";
    p.dungeonPreviewImg="";
    renderAll();
    return;
  }
  const typeLine=data.type_line||"";
  const layout=(data.layout||"").toLowerCase();
  const oracle=data.oracle_text||"";
  const cardName=data.name||rawName.trim();

  if(typeLine.toLowerCase().includes("dungeon") || layout==="dungeon"){
    const imgUrl=extractCardImage(data);
    p.dungeonPreviewText = cardName+(typeLine?("\n"+typeLine):"")+(oracle?("\n"+oracle):"");
    p.dungeonPreviewImg  = imgUrl||"";

    if(!p.dungeonProgress.toLowerCase().includes(cardName.toLowerCase())){
      p.dungeonProgress += (p.dungeonProgress? "\n":"")+"Dungeon: "+cardName;
    }
  } else {
    p.dungeonPreviewText = "Not a Dungeon card.";
    p.dungeonPreviewImg  = "";
  }
  renderAll();
}

/* Emblem lookup (per-player) */
async function lookupEmblemForPlayer(i){
  const p=players[i];
  const rawName=p.emblemLookupName||"";
  let data=await scryfallFuzzy(rawName);

  function isEmblemCard(d){
    if(!d) return false;
    const layout=(d.layout||"").toLowerCase();
    return layout==="emblem";
  }

  if(!isEmblemCard(data)){
    if(rawName.trim()){
      data=await scryfallFuzzy(rawName+" emblem");
    }
  }

  if(!data){
    p.emblemPreviewText="Not found / offline.";
    p.emblemPreviewImg="";
    renderAll();
    return;
  }

  if(!isEmblemCard(data)){
    p.emblemPreviewText="No emblem form found. Try planeswalker name + 'emblem'.";
    p.emblemPreviewImg="";
    renderAll();
    return;
  }

  const typeLine=data.type_line||"";
  const oracle=data.oracle_text||"";
  const cardName=data.name||rawName.trim();
  const imgUrl=extractCardImage(data);

  p.emblemPreviewText =
    cardName+(typeLine?("\n"+typeLine):"")+(oracle?("\n"+oracle):"");
  p.emblemPreviewImg  = imgUrl||"";

  if(!p.emblemsText.toLowerCase().includes(cardName.toLowerCase())){
    p.emblemsText += (p.emblemsText? "\n":"")+"Emblem: "+cardName+" — "+oracle;
  }

  renderAll();
}

/* Plane lookup (global) */
async function lookupPlaneGlobal(){
  const name=(currentPlaneName||"");
  const data=await scryfallFuzzy(name);
  if(!data){
    currentPlaneText="Not found / offline.";
    currentPlaneImg="";
    renderAll();
    return;
  }
  const typeLine=data.type_line||"";
  const oracle=data.oracle_text||"";
  const nm=data.name||name.trim();

  currentPlaneText = nm+(typeLine?("\n"+typeLine):"")+(oracle?("\n"+oracle):"");

  const imgUrl=extractCardImage(data);
  currentPlaneImg=imgUrl||"";
  renderAll();
}

/* Scheme lookup (global) */
async function lookupSchemeGlobal(){
  const name=(currentSchemeName||"");
  const data=await scryfallFuzzy(name);
  if(!data){
    currentSchemeText="Not found / offline.";
    currentSchemeImg="";
    renderAll();
    return;
  }
  const typeLine=data.type_line||"";
  const oracle=data.oracle_text||"";
  const nm=data.name||name.trim();

  currentSchemeText = nm+(typeLine?("\n"+typeLine):"")+(oracle?("\n"+oracle):"");

  const imgUrl=extractCardImage(data);
  currentSchemeImg=imgUrl||"";
  renderAll();
}

/* =========================
   RENDER HELPERS
========================= */
function renderGlobalTimerBanner(){
  globalTimerBanner.textContent = "Global: "+msToClock(getGameElapsedMs());
}
function renderTimersOnly(){
  renderGlobalTimerBanner();
  const p=players[turnIndex];
  if(p){
    const hudTimerBlocks = document.querySelectorAll("#hudArea .timer-block");
    if(hudTimerBlocks.length>=2){
      const turnVal=hudTimerBlocks[0].querySelector(".timer-val");
      if(turnVal){ turnVal.textContent=msToClock(getPlayerTurnMs(p)); }
      const playerVal=hudTimerBlocks[1].querySelector(".timer-val");
      if(playerVal){ playerVal.textContent=msToClock(getPlayerTotalMs(p)); }
    }
  }
  // also update player time in "Other Players" cards
  players.forEach((pl,i)=>{
    if(i===turnIndex) return;
    const node=document.querySelector(
      `.other-player-block[data-idx="${i}"] .player-time-val`
    );
    if(node){
      node.textContent=msToClock(getPlayerTotalMs(pl));
    }
  });
}

function getSeatColor(i){
  const cols=["var(--gold)","var(--cyan)","var(--magenta)","var(--lime)"];
  return cols[i % cols.length];
}

function renderAll(){
  syncCommanderDamageArrays();

  const cur = players[turnIndex]||{};
  const nm  = cur.name||("Player "+(turnIndex+1));
  turnBanner.textContent = "▶ "+nm.toUpperCase()+"'S TURN ◀";

  modeStatusText.textContent =
    (gameMode==="regular"?"Mode 1 — Regular":"Mode 2 — Rumble");

  renderHUD();
  renderOthers();
  renderAccordions();
  renderGlobalTimerBanner();

  if(winnerLocked){
    winnerMiniBanner.style.display="block";
  }else if(!winnerTimeMs){
    winnerMiniBanner.style.display="none";
  }
}

/* HUD (active player's panel) */
function renderHUD(){
  hudArea.innerHTML="";
  const p=players[turnIndex];
  if(!p) return;

  const seatColor=getSeatColor(turnIndex);

  const card=document.createElement("div");
  card.className="hud-card";
  card.style.border="1px solid "+seatColor;
  card.style.boxShadow="0 0 20px "+seatColor+"80, 0 30px 60px rgba(0,0,0,.9)";

  const topRow=document.createElement("div");
  topRow.className="hud-top-row";

  // LEFT COL
  const leftCol=document.createElement("div");
  leftCol.className="hud-col";

  const nameBlock=document.createElement("div");
  nameBlock.className="section-block-inline";

  const nmLabel=document.createElement("div");
  nmLabel.className="label-sm";
  nmLabel.textContent="Your Name";

  const nmInput=document.createElement("input");
  nmInput.className="text-input";
  nmInput.value=p.name;
  nmInput.addEventListener("input",e=>{
    p.name=e.target.value;
  });
  nmInput.addEventListener("blur",()=>{ renderAll(); });
  nmInput.addEventListener("keydown",ev=>{
    if(ev.key==="Enter"){
      ev.preventDefault();
      nmInput.blur();
    }
  });

  const tinyStack=document.createElement("div");
  tinyStack.className="tiny-col-stack";

  // status chip + cooldown info
  const statusRow=document.createElement("div");
  statusRow.className="tiny-row";

  const stChip=document.createElement("div");
  stChip.className="status-chip "+
    (p.status==="active"?"status-active":
     p.status==="cooldown"?"status-cooldown":"status-elim");
  stChip.textContent=
    p.status==="active"?"ACTIVE":
    p.status==="cooldown"?"COOLDOWN":
    "ELIMINATED";

  stChip.title = (gameMode==="rumble")
    ? "Tap to correct: Active ↔ Cooldown ↔ Eliminated"
    : "Tap to correct: Active ↔ Eliminated";
  stChip.addEventListener("click",()=>{
    cycleStatusAdmin(turnIndex);
  });

  statusRow.appendChild(stChip);

  if(p.status==="cooldown" && gameMode==="rumble"){
    const cdWrap=document.createElement("div");
    cdWrap.className="cd-info-inline";

    const cdLab=document.createElement("div");
    cdLab.className="cd-label";
    cdLab.textContent="Cooldown:";

    const cdVal=document.createElement("div");
    cdVal.className="cd-val-box";
    cdVal.textContent=p.cooldownRemaining;

    cdWrap.appendChild(cdLab);
    cdWrap.appendChild(cdVal);
    statusRow.appendChild(cdWrap);
  }

  // Timers
  const timeRow=document.createElement("div");
  timeRow.className="timer-row";

  const tBlock1=document.createElement("div");
  tBlock1.className="timer-block";
  const tb1L=document.createElement("div");
  tb1L.className="timer-label";
  tb1L.textContent="Turn Time";
  const tb1V=document.createElement("div");
  tb1V.className="timer-val";
  tb1V.textContent=msToClock(getPlayerTurnMs(p));
  tBlock1.appendChild(tb1L);
  tBlock1.appendChild(tb1V);

  const tBlock2=document.createElement("div");
  tBlock2.className="timer-block";
  const tb2L=document.createElement("div");
  tb2L.className="timer-label";
  tb2L.textContent="Player Time";
  const tb2V=document.createElement("div");
  tb2V.className="timer-val";
  tb2V.textContent=msToClock(getPlayerTotalMs(p));
  tBlock2.appendChild(tb2L);
  tBlock2.appendChild(tb2V);

  timeRow.appendChild(tBlock1);
  timeRow.appendChild(tBlock2);

  const tinyStackTop=document.createElement("div");
  tinyStackTop.appendChild(statusRow);
  tinyStackTop.appendChild(timeRow);

  if(p.pendingEOTDraw){
    const reminder=document.createElement("div");
    reminder.className="respawn-draw-banner";
    reminder.textContent="RESPAWN TURN: Skip normal draw. Draw 1 at END of this turn.";
    tinyStackTop.appendChild(reminder);
  }

  nameBlock.appendChild(nmLabel);
  nameBlock.appendChild(nmInput);
  nameBlock.appendChild(tinyStackTop);
  leftCol.appendChild(nameBlock);

  // RIGHT COL
  const rightCol=document.createElement("div");
  rightCol.className="hud-col";

  const vitalsBlock=document.createElement("div");
  vitalsBlock.className="section-block-inline vitalsBlock";

  const lfLabel=document.createElement("div");
  lfLabel.className="label-sm";
  lfLabel.textContent="Life Total";

  const lfRow=document.createElement("div");
  lfRow.className="life-row";

  const minusBtn=document.createElement("div");
  minusBtn.className="life-btn";
  minusBtn.textContent="-";
  minusBtn.addEventListener("click",()=>{
    p.life = p.life-1;
    lethalCheck(turnIndex,"life");
    renderAll();
  });

  const lifeVal=document.createElement("div");
  lifeVal.className="life-value";
  lifeVal.textContent=p.life;

  const plusBtn=document.createElement("div");
  plusBtn.className="life-btn";
  plusBtn.textContent="+";
  plusBtn.addEventListener("click",()=>{
    p.life = p.life+1;
    renderAll();
  });

  lfRow.appendChild(minusBtn);
  lfRow.appendChild(lifeVal);
  lfRow.appendChild(plusBtn);

  const grid=document.createElement("div");
  grid.className="mini-counters-grid";

  grid.appendChild(makeMiniStepperBox("☠ Poison",p.poison,(newVal)=>{
    p.poison=newVal;
    lethalCheck(turnIndex,"poison");
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("☢ Rad",p.radiation,(newVal)=>{
    p.radiation=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("⚡ Energy",p.energy,(newVal)=>{
    p.energy=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("★ Exp",p.experience,(newVal)=>{
    p.experience=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("☁ Storm",p.storm,(newVal)=>{
    p.storm=newVal;
    renderAll();
  }));

  vitalsBlock.appendChild(lfLabel);
  vitalsBlock.appendChild(lfRow);
  vitalsBlock.appendChild(grid);

  rightCol.appendChild(vitalsBlock);

  topRow.appendChild(leftCol);
  topRow.appendChild(rightCol);
  card.appendChild(topRow);

  hudArea.appendChild(card);
}

function makeMiniStepperBox(labelText,val,onSet){
  const wrap=document.createElement("div");
  wrap.className="mini-counter-box";

  const lab=document.createElement("div");
  lab.className="mini-counter-label";
  lab.textContent=labelText;

  const row=document.createElement("div");
  row.className="mini-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1; if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1; if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);

  wrap.appendChild(lab);
  wrap.appendChild(row);
  return wrap;
}

/* OTHERS */
function renderOthers(){
  othersArea.innerHTML="";
  const wrap=document.createElement("div");
  wrap.className="others-card";

  const hdr=document.createElement("div");
  hdr.className="other-header";
  hdr.textContent="Other Players";
  wrap.appendChild(hdr);

  players.forEach((pl,i)=>{
    if(i===turnIndex) return;
    const block=document.createElement("div");
    block.className="other-player-block";
    block.setAttribute("data-idx",i);

    const top=document.createElement("div");
    top.className="other-player-top";

    const nm=pl.name||("Player "+(i+1));
    const titleSpan=document.createElement("span");
    titleSpan.textContent=nm;

    const chev=document.createElement("span");
    chev.className="other-expand-indicator";

    const body=document.createElement("div");
    body.className="other-player-body";

    const isOpen=!!otherOpen[i];
    if(isOpen){
      body.style.display="flex";
      chev.textContent="▲";
    }else{
      body.style.display="none";
      chev.textContent="▼";
    }

    // Status line
    const statusLine=document.createElement("div");
    statusLine.className="status-line-other";

    const statusText=document.createElement("div");
    statusText.textContent="Status: "+pl.status.toUpperCase();
    statusLine.appendChild(statusText);

    if(pl.status==="cooldown" && gameMode==="rumble"){
      const cdLab=document.createElement("div");
      cdLab.className="cd-label";
      cdLab.style.fontSize=".6rem";
      cdLab.style.color="var(--text-dim)";
      cdLab.style.textTransform="uppercase";
      cdLab.style.letterSpacing=".05em";
      cdLab.textContent="Cooldown:";

      const cdNum=document.createElement("div");
      cdNum.className="cd-val-box";
      cdNum.textContent=pl.cooldownRemaining;

      statusLine.appendChild(cdLab);
      statusLine.appendChild(cdNum);
    }

    const timeBox=document.createElement("div");
    timeBox.style.display="flex";
    timeBox.style.flexWrap="wrap";
    timeBox.style.alignItems="center";
    timeBox.style.gap=".5rem .75rem";

    const tLab=document.createElement("div");
    tLab.className="cd-label";
    tLab.textContent="Player Time:";

    const tVal=document.createElement("div");
    tVal.className="cd-val-box player-time-val";
    tVal.textContent=msToClock(getPlayerTotalMs(pl));
    timeBox.appendChild(tLab);
    timeBox.appendChild(tVal);

    statusLine.appendChild(timeBox);
    body.appendChild(statusLine);

    // Life / +/- controls
    const lifeCol=document.createElement("div");
    lifeCol.className="mini-col";

    const lifeLab=document.createElement("div");
    lifeLab.className="label-sm";
    lifeLab.textContent="Life Total ("+nm+")";

    const lifeRow=document.createElement("div");
    lifeRow.className="life-edit-inline";

    const minusBtn=document.createElement("div");
    minusBtn.className="life-inline-btn";
    minusBtn.textContent="-";
    minusBtn.addEventListener("click",()=>{
      pl.life=pl.life-1;
      lethalCheck(i,"life");
      renderAll();
    });

    const lifeVal=document.createElement("div");
    lifeVal.className="life-inline-val";
    lifeVal.textContent=pl.life;

    const plusBtn=document.createElement("div");
    plusBtn.className="life-inline-btn";
    plusBtn.textContent="+";
    plusBtn.addEventListener("click",()=>{
      pl.life=pl.life+1;
      renderAll();
    });

    lifeRow.appendChild(minusBtn);
    lifeRow.appendChild(lifeVal);
    lifeRow.appendChild(plusBtn);
    lifeCol.appendChild(lifeLab);
    lifeCol.appendChild(lifeRow);
    body.appendChild(lifeCol);

    // poison/rad/exp/storm
    const debuffRow=document.createElement("div");
    debuffRow.className="mini-row";

    debuffRow.appendChild(smallStepperBox("☠ Poison",pl.poison,(v)=>{
      pl.poison=v;
      lethalCheck(i,"poison");
      renderAll();
    }));
    debuffRow.appendChild(smallStepperBox("☢ Rad",pl.radiation,(v)=>{
      pl.radiation=v;
      renderAll();
    }));
    debuffRow.appendChild(smallStepperBox("★ Exp",pl.experience,(v)=>{
      pl.experience=v;
      renderAll();
    }));
    debuffRow.appendChild(smallStepperBox("☁ Storm",pl.storm,(v)=>{
      pl.storm=v;
      renderAll();
    }));
    body.appendChild(debuffRow);

    // Commander damage grid
    const cdmgWrap=document.createElement("div");
    cdmgWrap.className="cdmg-section-wrap";

    const cdmgLab=document.createElement("div");
    cdmgLab.className="cdmg-label";
    cdmgLab.textContent="Commander Damage Taken by "+nm+" (21 from any 1 source = elim)";
    cdmgWrap.appendChild(cdmgLab);

    const cdmgGrid=document.createElement("div");
    cdmgGrid.className="cdmg-grid";

    players.forEach((srcPl,srcIdx)=>{
      const srcName=srcPl.name||("P"+(srcIdx+1));
      const cell=document.createElement("div");
      cell.className="cdmg-cell";

      const cellLabel=document.createElement("div");
      cellLabel.className="cdmg-cell-label";
      cellLabel.textContent="from "+srcName;

      const inputRow=document.createElement("div");
      inputRow.className="cdmg-input-row";

      const dmgIn=document.createElement("input");
      dmgIn.type="number";
      dmgIn.min="0";
      dmgIn.value=pl.commanderDamage[srcIdx]||0;
      dmgIn.addEventListener("input",e=>{
        let v=parseInt(e.target.value,10);
        if(isNaN(v)||v<0)v=0;
        pl.commanderDamage[srcIdx]=v;
        checkCommanderDamageElim(i);
        renderAll();
      });

      inputRow.appendChild(dmgIn);
      cell.appendChild(cellLabel);
      cell.appendChild(inputRow);
      cdmgGrid.appendChild(cell);
    });

    cdmgWrap.appendChild(cdmgGrid);
    body.appendChild(cdmgWrap);

    // Player notes in Others
    const miniNote=document.createElement("div");
    miniNote.className="mini-note-box";
    const mnLab=document.createElement("div");
    mnLab.className="mini-note-label";
    mnLab.textContent="Note on "+nm+" (Monarch, Initiative, Goaded, etc.)";
    const mnArea=document.createElement("textarea");
    mnArea.className="mini-area-input";
    mnArea.value=pl.notesText;
    mnArea.addEventListener("input",e=>{
      pl.notesText=e.target.value;
    });
    miniNote.appendChild(mnLab);
    miniNote.appendChild(mnArea);
    body.appendChild(miniNote);

    top.addEventListener("click",()=>{
      otherOpen[i]=!otherOpen[i];
      renderOthers();
    });

    const chevWrap=document.createElement("span");
    chevWrap.appendChild(chev);

    top.appendChild(titleSpan);
    top.appendChild(chevWrap);

    block.appendChild(top);
    block.appendChild(body);

    wrap.appendChild(block);
  });

  othersArea.appendChild(wrap);
}

function smallStepperBox(labelText,val,onSet){
  const box=document.createElement("div");
  box.className="mini-col";

  const l=document.createElement("div");
  l.className="label-sm";
  l.textContent=labelText;

  const row=document.createElement("div");
  row.className="mini-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1; if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1; if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);
  box.appendChild(l);
  box.appendChild(row);

  return box;
}

/* =========================
   ACCORDIONS
========================= */
function makeToggleChip(label,active,onToggle){
  const chip=document.createElement("div");
  chip.className="toggle-chip"+(active?" active":"");
  chip.textContent=active?(label+" ✓"):label;
  chip.addEventListener("click",()=>{ onToggle(!active); });
  return chip;
}

function renderAccordions(){
  accordionsArea.innerHTML="";

  const statusAcc = renderStatusAccordion();
  if(statusAcc) accordionsArea.appendChild(statusAcc);

  const notesAcc = renderNotesAccordion();
  if(notesAcc) accordionsArea.appendChild(notesAcc);
}

function renderStatusAccordion(){
  const p=players[turnIndex];
  if(!p) return null;

  const wrap=document.createElement("div");
  wrap.className="accordion-block";

  const head=document.createElement("div");
  head.className="accordion-head";

  const leftSpan=document.createElement("div");
  leftSpan.textContent="Status Effects / Titles";

  const rightSpan=document.createElement("div");
  rightSpan.style.display="flex";
  rightSpan.style.gap=".5rem";
  rightSpan.style.alignItems="center";

  const hintEl=document.createElement("div");
  hintEl.className="hint";
  hintEl.textContent="Monarch, Initiative, Dungeons, Emblems, Plane, Scheme";

  const chevron=document.createElement("div");
  chevron.style.color="var(--text-dim)";
  chevron.style.fontSize=".8rem";

  rightSpan.appendChild(hintEl);
  rightSpan.appendChild(chevron);

  const body=document.createElement("div");
  body.className="accordion-body";

  // Toggled titles
  const toggleSection=document.createElement("div");
  toggleSection.style.display="flex";
  toggleSection.style.flexWrap="wrap";
  toggleSection.style.gap=".5rem .5rem";

  toggleSection.appendChild(
    makeToggleChip("Monarch",p.hasMonarch,(val)=>{
      p.hasMonarch=val; renderAll();
    })
  );
  toggleSection.appendChild(
    makeToggleChip("Initiative",p.hasInitiative,(val)=>{
      p.hasInitiative=val; renderAll();
    })
  );
  toggleSection.appendChild(
    makeToggleChip("Blessing",p.hasCitysBlessing,(val)=>{
      p.hasCitysBlessing=val; renderAll();
    })
  );

  // Dungeon / Undercity / Progress + lookup
  const dungeonBlock=document.createElement("div");
  dungeonBlock.style.display="flex";
  dungeonBlock.style.flexDirection="column";
  dungeonBlock.style.gap=".5rem";

  const dungeonLabel=document.createElement("div");
  dungeonLabel.className="subsection-label";
  dungeonLabel.textContent="Dungeon / Undercity / Progress";

  const dungeonArea=document.createElement("textarea");
  dungeonArea.className="area-input";
  dungeonArea.placeholder="Initiative rooms, dungeon rooms, steps..."
  dungeonArea.value=p.dungeonProgress;
  dungeonArea.addEventListener("input",e=>{
    p.dungeonProgress=e.target.value;
  });

  const dungeonLookupRow=document.createElement("div");
  dungeonLookupRow.className="lookup-row";

  const dungeonCol=document.createElement("div");
  dungeonCol.className="lookup-col";

  const dungeonInput=document.createElement("input");
  dungeonInput.className="lookup-input";
  dungeonInput.placeholder="Lookup Dungeon..."
  dungeonInput.value=p.dungeonLookupName;
  dungeonInput.addEventListener("input",e=>{
    p.dungeonLookupName=e.target.value;
  });

  const dungeonBtn=document.createElement("button");
  dungeonBtn.className="lookup-btn";
  dungeonBtn.textContent="Lookup Dungeon";
  dungeonBtn.addEventListener("click",()=>{
    lookupDungeonForPlayer(turnIndex);
  });

  dungeonCol.appendChild(dungeonInput);
  dungeonCol.appendChild(dungeonBtn);
  dungeonLookupRow.appendChild(dungeonCol);

  const dungeonPreview=document.createElement("div");
  dungeonPreview.className="lookup-preview-block";

  if(p.dungeonPreviewText || p.dungeonPreviewImg){
    const txt=document.createElement("div");
    txt.className="lookup-cardtext";
    txt.textContent=p.dungeonPreviewText||"";
    dungeonPreview.appendChild(txt);

    if(p.dungeonPreviewImg){
      const imgWrap=document.createElement("div");
      imgWrap.className="lookup-cardimg";
      const im=document.createElement("img");
      im.src=p.dungeonPreviewImg;
      im.alt="dungeon";
      imgWrap.appendChild(im);
      dungeonPreview.appendChild(imgWrap);
    }
  }

  dungeonBlock.appendChild(dungeonLabel);
  dungeonBlock.appendChild(dungeonArea);
  dungeonBlock.appendChild(dungeonLookupRow);
  dungeonBlock.appendChild(dungeonPreview);

  // Emblems / Globals + emblem lookup
  const emblemBlock=document.createElement("div");
  emblemBlock.style.display="flex";
  emblemBlock.style.flexDirection="column";
  emblemBlock.style.gap=".5rem";

  const emblemLabel=document.createElement("div");
  emblemLabel.className="subsection-label";
  emblemLabel.textContent="Emblems / Globals";

  const emblemArea=document.createElement("textarea");
  emblemArea.className="area-input";
  emblemArea.placeholder="Emblems, static buffs, city-wide effects..."
  emblemArea.value=p.emblemsText;
  emblemArea.addEventListener("input",e=>{
    p.emblemsText=e.target.value;
  });

  const emblemLookupRow=document.createElement("div");
  emblemLookupRow.className="lookup-row";

  const emblemCol=document.createElement("div");
  emblemCol.className="lookup-col";

  const emblemInput=document.createElement("input");
  emblemInput.className="lookup-input";
  emblemInput.placeholder="Lookup Emblem / Walker Ult..."
  emblemInput.value=p.emblemLookupName;
  emblemInput.addEventListener("input",e=>{
    p.emblemLookupName=e.target.value;
  });

  const emblemBtn=document.createElement("button");
  emblemBtn.className="lookup-btn";
  emblemBtn.textContent="Lookup Emblem";
  emblemBtn.addEventListener("click",()=>{
    lookupEmblemForPlayer(turnIndex);
  });

  emblemCol.appendChild(emblemInput);
  emblemCol.appendChild(emblemBtn);
  emblemLookupRow.appendChild(emblemCol);

  const emblemPreview=document.createElement("div");
  emblemPreview.className="lookup-preview-block";

  if(p.emblemPreviewText || p.emblemPreviewImg){
    const txt=document.createElement("div");
    txt.className="lookup-cardtext";
    txt.textContent=p.emblemPreviewText||"";
    emblemPreview.appendChild(txt);

    if(p.emblemPreviewImg){
      const imgWrap=document.createElement("div");
      imgWrap.className="lookup-cardimg";
      const im=document.createElement("img");
      im.src=p.emblemPreviewImg;
      im.alt="emblem";
      imgWrap.appendChild(im);
      emblemPreview.appendChild(imgWrap);
    }
  }

  // Table-wide effects (Plane / Scheme)
  const tableWideBlock=document.createElement("div");
  tableWideBlock.style.display="flex";
  tableWideBlock.style.flexDirection="column";
  tableWideBlock.style.gap=".75rem";

  const tableWideLabel=document.createElement("div");
  tableWideLabel.className="subsection-label";
  tableWideLabel.textContent="Table-Wide Effects (Planechase / Archenemy)";

  // plane
  const planeWrap=document.createElement("div");
  planeWrap.style.display="flex";
  planeWrap.style.flexDirection="column";
  planeWrap.style.gap=".5rem";

  const planeInnerRow=document.createElement("div");
  planeInnerRow.className="lookup-row";

  const planeCol=document.createElement("div");
  planeCol.className="lookup-col";

  const planeInput=document.createElement("input");
  planeInput.className="lookup-input";
  planeInput.placeholder="Current Plane..."
  planeInput.value=currentPlaneName;
  planeInput.addEventListener("input",e=>{
    currentPlaneName=e.target.value;
  });

  const planeBtn=document.createElement("button");
  planeBtn.className="lookup-btn";
  planeBtn.textContent="Lookup Plane";
  planeBtn.addEventListener("click",()=>{
    lookupPlaneGlobal();
  });

  planeCol.appendChild(planeInput);
  planeCol.appendChild(planeBtn);
  planeInnerRow.appendChild(planeCol);

  const planePreview=document.createElement("div");
  planePreview.className="lookup-preview-block";

  if(currentPlaneText || currentPlaneImg){
    const t=document.createElement("div");
    t.className="lookup-cardtext";
    t.textContent=currentPlaneText||"";
    planePreview.appendChild(t);

    if(currentPlaneImg){
      const imWrap=document.createElement("div");
      imWrap.className="lookup-cardimg";
      const im=document.createElement("img");
      im.src=currentPlaneImg;
      im.alt="plane";
      imWrap.appendChild(im);
      planePreview.appendChild(imWrap);
    }
  }

  planeWrap.appendChild(planeInnerRow);
  planeWrap.appendChild(planePreview);

  // scheme
  const schemeWrap=document.createElement("div");
  schemeWrap.style.display="flex";
  schemeWrap.style.flexDirection="column";
  schemeWrap.style.gap=".5rem";

  const schemeInnerRow=document.createElement("div");
  schemeInnerRow.className="lookup-row";

  const schemeCol=document.createElement("div");
  schemeCol.className="lookup-col";

  const schemeInput=document.createElement("input");
  schemeInput.className="lookup-input";
  schemeInput.placeholder="Current Scheme..."
  schemeInput.value=currentSchemeName;
  schemeInput.addEventListener("input",e=>{
    currentSchemeName=e.target.value;
  });

  const schemeBtn=document.createElement("button");
  schemeBtn.className="lookup-btn";
  schemeBtn.textContent="Lookup Scheme";
  schemeBtn.addEventListener("click",()=>{
    lookupSchemeGlobal();
  });

  schemeCol.appendChild(schemeInput);
  schemeCol.appendChild(schemeBtn);
  schemeInnerRow.appendChild(schemeCol);

  const schemePreview=document.createElement("div");
  schemePreview.className="lookup-preview-block";

  if(currentSchemeText || currentSchemeImg){
    const t=document.createElement("div");
    t.className="lookup-cardtext";
    t.textContent=currentSchemeText||"";
    schemePreview.appendChild(t);

    if(currentSchemeImg){
      const imWrap=document.createElement("div");
      imWrap.className="lookup-cardimg";
      const im=document.createElement("img");
      im.src=currentSchemeImg;
      im.alt="scheme";
      imWrap.appendChild(im);
      schemePreview.appendChild(imWrap);
    }
  }

  schemeWrap.appendChild(schemeInnerRow);
  schemeWrap.appendChild(schemePreview);

  tableWideBlock.appendChild(tableWideLabel);
  tableWideBlock.appendChild(planeWrap);
  tableWideBlock.appendChild(schemeWrap);

  body.appendChild(toggleSection);
  body.appendChild(dungeonBlock);
  body.appendChild(emblemBlock);
  body.appendChild(tableWideBlock);

  if(accordionsOpen.statusEffects){
    body.style.display="flex";
    chevron.textContent="▲";
  }else{
    body.style.display="none";
    chevron.textContent="▼";
  }

  head.addEventListener("click",()=>{
    accordionsOpen.statusEffects=!accordionsOpen.statusEffects;
    renderAccordions();
  });

  wrap.appendChild(head);
  wrap.appendChild(body);
  return wrap;
}

function renderNotesAccordion(){
  const p=players[turnIndex];
  if(!p) return null;

  const wrap=document.createElement("div");
  wrap.className="accordion-block";

  const head=document.createElement("div");
  head.className="accordion-head";

  const leftSpan=document.createElement("div");
  leftSpan.textContent="Notes / Reminders";

  const rightSpan=document.createElement("div");
  rightSpan.style.display="flex";
  rightSpan.style.gap=".5rem";
  rightSpan.style.alignItems="center";

  const hintEl=document.createElement("div");
  hintEl.className="hint";
  hintEl.textContent="Goad, skip draw, bounties, politics";

  const chevron=document.createElement("div");
  chevron.style.color="var(--text-dim)";
  chevron.style.fontSize=".8rem";

  rightSpan.appendChild(hintEl);
  rightSpan.appendChild(chevron);

  const body=document.createElement("div");
  body.className="accordion-body";

  const notesLabel=document.createElement("div");
  notesLabel.className="subsection-label";
  notesLabel.textContent="Notes";

  const notesArea=document.createElement("textarea");
  notesArea.className="area-input";
  notesArea.placeholder="Goaded Krenko, skip next draw, bounty, 'don't attack me' deals..."
  notesArea.value=p.notesText;
  notesArea.addEventListener("input",e=>{
    p.notesText=e.target.value;
  });

  body.appendChild(notesLabel);
  body.appendChild(notesArea);

  if(accordionsOpen.notes){
    body.style.display="flex";
    chevron.textContent="▲";
  }else{
    body.style.display="none";
    chevron.textContent="▼";
  }

  head.addEventListener("click",()=>{
    accordionsOpen.notes=!accordionsOpen.notes;
    renderAccordions();
  });

  wrap.appendChild(head);
  wrap.appendChild(body);
  return wrap;
}

/* =========================
   LETHAL CHECK
========================= */
function lethalCheck(i,source){
  const p=players[i];
  if(!p) return;
  if(source==="life" && p.life<=0){
    knockOutToCooldown(i);
    return;
  }
  if(source==="poison" && p.poison>=10){
    knockOutToCooldown(i);
    return;
  }
}

/* =========================
   ADMIN STATUS CYCLE
========================= */
function cycleStatusAdmin(i){
  const p=players[i];
  if(gameMode==="rumble"){
    // active -> cooldown -> eliminated -> active
    if(p.status==="active"){
      knockOutToCooldown(i);
    }else if(p.status==="cooldown"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction.",
        "OK"
      );
    }else{
      p.status="active";
      p.cooldownRemaining=0;
      p.pendingEOTDraw=false;
    }
  }else{
    // regular: active -> eliminated -> active
    if(p.status==="active"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction.",
        "OK"
      );
    }else{
      p.status="active";
      p.cooldownRemaining=0;
      p.pendingEOTDraw=false;
    }
  }
  renderAll();
}

/* =========================
   SETUP / MODE / NEW GAME
========================= */
function resetGameStateKeepMode(){
  players=[];
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;
  winnerName="";
  winnerTimeMs=0;
  winnerActiveMs=0;
  otherOpen={};

  currentPlaneName   ="";
  currentPlaneText   ="";
  currentPlaneImg    ="";
  currentSchemeName  ="";
  currentSchemeText  ="";
  currentSchemeImg   ="";

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  accordionsOpen.statusEffects=false;
  accordionsOpen.notes=true;

  setupStepMode.style.display="none";
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

function showModeStep(){
  players=[];
  gameStartTime=null;
  winnerLocked=false;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  otherOpen={};

  currentPlaneName   ="";
  currentPlaneText   ="";
  currentPlaneImg    ="";
  currentSchemeName  ="";
  currentSchemeText  ="";
  currentSchemeImg   ="";

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  accordionsOpen.statusEffects=false;
  accordionsOpen.notes=true;

  setupStepMode.style.display="flex";
  setupStepPlayers.style.display="none";
  setupOverlay.style.display="flex";
}

function showPlayerCountStep(){
  players=[];
  gameStartTime=null;
  winnerLocked=false;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  otherOpen={};

  currentPlaneName   ="";
  currentPlaneText   ="";
  currentPlaneImg    ="";
  currentSchemeName  ="";
  currentSchemeText  ="";
  currentSchemeImg   ="";

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  accordionsOpen.statusEffects=false;
  accordionsOpen.notes=true;

  setupStepMode.style.display="none";
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

setupStepMode.querySelectorAll("[data-mode]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const m=btn.getAttribute("data-mode");
    gameMode=m==="regular"?"regular":"rumble";
    showPlayerCountStep();
  });
});

setupStepPlayers.querySelectorAll("[data-fixedplayers]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const n=parseInt(btn.getAttribute("data-fixedplayers"),10);
    startGameWith(n);
  });
});

manualStartBtn.addEventListener("click",()=>{
  let n=parseInt(manualPlayerCount.value,10);
  if(isNaN(n)||n<2)n=2;
  if(n>8)n=8;
  startGameWith(n);
});

function startGameWith(nPlayers){
  players=[];
  for(let i=0;i<nPlayers;i++){
    players.push(makePlayer("Player "+(i+1)));
  }
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;
  winnerName="";
  winnerTimeMs=0;
  winnerActiveMs=0;
  otherOpen={};

  currentPlaneName   ="";
  currentPlaneText   ="";
  currentPlaneImg    ="";
  currentSchemeName  ="";
  currentSchemeText  ="";
  currentSchemeImg   ="";

  accordionsOpen.statusEffects=false;
  accordionsOpen.notes=true;

  gameStartTime=Date.now();

  syncCommanderDamageArrays();
  if(players[0] && players[0].status==="active"){
    startTimingPlayer(0);
  }

  setupOverlay.style.display="none";
  renderAll();

  if(renderIntervalId){
    clearInterval(renderIntervalId);
  }
  renderIntervalId=setInterval(()=>{
    if(!winnerLocked){
      renderTimersOnly();
    }
  },1000);
}

/* =========================
   EVENTS
========================= */
endTurnBtn.addEventListener("click",()=>{
  passTurn();
});

winnerCloseBtn.addEventListener("click",()=>{
  winnerOverlay.style.display="none";
});

themeSelect.addEventListener("change",()=>{
  document.body.classList.remove("theme-dark","theme-light","theme-neon");
  document.body.classList.add(themeSelect.value);
});

</script>
</body>
</html>