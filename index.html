<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>EDH RUMBLE TRACKER v16.2</title>
<style>
/* THEME VARS */
:root {
  --bg-main:#0f0f12;
  --bg-panel:#1a1a22;
  --bg-accent:#2a2a36;
  --border-soft:#3a3a4f;

  --text-primary:#f5f5fa;
  --text-dim:#8a8aa5;

  --gold:#d4a94f;
  --cyan:#5fd8d8;
  --magenta:#ff4acb;
  --lime:#5fd85f;
  --red:#d85f5f;
  --off:#55556e;

  --button-bg:#2a2a36;
  --button-border:#3a3a4f;

  --overlay-bg:rgba(0,0,0,0.8);

  --tool-bg:#1a1a22;
  --tool-border:#3a3a4f;
}

.theme-light {
  --bg-main:#ffffff;
  --bg-panel:#ffffff;
  --bg-accent:#f4f4fa;
  --border-soft:#bfbfd4;

  --text-primary:#1a1a22;
  --text-dim:#5a5a77;

  --gold:#9c7a1f;
  --cyan:#2a8f8f;
  --magenta:#b51882;
  --lime:#2a8f2a;
  --red:#a63f3f;
  --off:#8a8aa5;

  --button-bg:#ffffff;
  --button-border:#bfbfd4;

  --overlay-bg:rgba(0,0,0,0.6);

  --tool-bg:#ffffff;
  --tool-border:#bfbfd4;
}

.theme-neon {
  --bg-main:#050509;
  --bg-panel:#0e0e1a;
  --bg-accent:#1a1a33;
  --border-soft:#4a4aff;

  --text-primary:#ffeefe;
  --text-dim:#ff4aeb;

  --gold:#ffef5a;
  --cyan:#5fd8ff;
  --magenta:#ff4acb;
  --lime:#5CFFB6;
  --red:#ff4a6b;
  --off:#4f4f80;

  --button-bg:#1a1a33;
  --button-border:#4a4aff;

  --overlay-bg:rgba(0,0,30,0.8);

  --tool-bg:#0e0e1a;
  --tool-border:#4a4aff;
}

/* BASE */
*{
  box-sizing:border-box;
  font-family:system-ui, Roboto, "Helvetica Neue", Arial, sans-serif;
}
body{
  margin:0;
  background:var(--bg-main);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  justify-content:center;
}
button{
  cursor:pointer;
}
input, textarea, select, button {
  font-family:inherit;
}

/* APP SHELL */
.app-shell{
  width:100%;
  max-width:480px;
  min-height:100vh;
  background:var(--bg-main);
  display:flex;
  flex-direction:column;
  position:relative;
}

/* STICKY HEADER */
.top-header{
  position:sticky;
  top:0;
  z-index:1000;
  background:var(--bg-panel);
  border-bottom:1px solid var(--border-soft);
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:.6rem .75rem .5rem;
  gap:.4rem;
}
.game-title{
  font-size:clamp(.8rem,.6rem + .5vw,1rem);
  font-weight:700;
  letter-spacing:.05em;
  color:var(--text-primary);
  text-align:center;
}
.header-row{
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  align-items:baseline;
  gap:.75rem 1rem;
  text-align:center;
}
#turnBanner{
  font-size:clamp(.7rem,.5rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  letter-spacing:.05em;
}
#globalTimerBanner{
  font-size:clamp(.7rem,.5rem + .4vw,.9rem);
  font-weight:600;
  color:var(--text-primary);
  letter-spacing:.05em;
}

/* CONTENT AREA */
.content-area{
  flex:1;
  overflow-y:auto;
  padding:1rem .75rem 5rem; /* bottom pad so footer doesn't cover */
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* HUD CARD */
.hud-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  box-shadow:0 20px 40px rgba(0,0,0,.7);
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.hud-top-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  justify-content:space-between;
}
.hud-col{
  flex:1 1 220px;
  min-width:0;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.section-block-inline{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.respawn-draw-banner{
  background:rgba(212,169,79,.07);
  border:1px solid var(--gold);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.7rem;
  font-weight:600;
  line-height:1.3;
  color:var(--gold);
}
.label-sm{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.text-input{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.45rem .5rem;
  min-width:5rem;
  font-weight:600;
  width:100%;
}

/* STATUS + TAX + TIMERS */
.tiny-col-stack{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.tiny-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.status-chip{
  border-radius:.5rem;
  padding:.5rem;
  text-align:center;
  font-size:.7rem;
  font-weight:600;
  line-height:1.3;
  border:1px solid;
  cursor:pointer;
  min-width:5.5rem;
}
.status-active{
  color:var(--lime);
  border-color:var(--lime);
  background:rgba(95,216,95,.07);
}
.status-cooldown{
  color:var(--red);
  border-color:var(--red);
  background:rgba(216,95,95,.08);
}
.status-elim{
  color:var(--off);
  border-color:var(--off);
  background:rgba(85,85,110,.15);
}
.cd-info-inline{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
}
.cd-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.cd-val-box{
  min-width:2rem;
  text-align:center;
  font-size:.8rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
  color:var(--text-primary);
}

/* Commander tax row */
.tax-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.tax-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.tax-ctrl{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.tax-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.tax-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
}

/* TIMERS */
.timer-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem 1rem;
  font-size:.7rem;
  line-height:1.3;
}
.timer-block{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.timer-label{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.timer-val{
  font-size:clamp(.8rem,.6rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  min-width:3.5rem;
}

/* VITALS */
.vitalsBlock .life-row{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.life-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:1rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2.2rem;
  text-align:center;
  color:var(--text-primary);
}
.life-value{
  min-width:3rem;
  text-align:center;
  font-size:1.2rem;
  font-weight:700;
  color:var(--text-primary);
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .6rem;
  line-height:1.2;
}
.mini-counters-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(100px,100%),1fr));
  gap:.5rem;
}
.mini-counter-box{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.4rem;
  font-size:.7rem;
  text-align:center;
}
.mini-counter-label{
  font-size:.65rem;
  line-height:1.2;
  color:var(--text-dim);
}
.mini-step-row{
  display:flex;
  align-items:center;
  gap:.4rem;
  font-size:.8rem;
  font-weight:600;
}
.step-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.step-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
  color:var(--text-primary);
}

/* END TURN BUTTON */
.end-turn-btn{
  background:var(--gold);
  border:none;
  border-radius:.5rem;
  padding:.8rem .9rem;
  font-size:clamp(.8rem,.5rem + .5vw,.9rem);
  font-weight:700;
  color:#000;
  text-align:center;
  box-shadow:0 10px 20px rgba(0,0,0,.6);
  width:100%;
}

/* OTHERS */
.others-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.other-header{
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.other-player-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  overflow:hidden;
}
.other-player-top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  cursor:pointer;
}
.other-expand-indicator{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
}
.other-player-body{
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  display:none;
  flex-direction:column;
  gap:.75rem;
  font-size:.75rem;
}

/* LINES INSIDE OTHER PLAYER */
.status-line-other{
  font-size:.7rem;
  font-weight:600;
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:center;
}
.life-edit-inline{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.life-inline-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.life-inline-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
}
.mini-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:flex-start;
}
.mini-col{
  display:flex;
  flex-direction:column;
  gap:.4rem;
}

/* COMMANDER DAMAGE GRID */
.cdmg-section-wrap{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.cdmg-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.cdmg-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(140px,100%),1fr));
  gap:.5rem .75rem;
}
.cdmg-cell{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  gap:.4rem;
  font-size:.7rem;
}
.cdmg-cell-label{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.2;
}
.cdmg-input-row{
  display:flex;
  gap:.5rem;
  align-items:flex-end;
}
.cdmg-input-row input{
  width:3rem;
  text-align:center;
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.4rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
}

/* PLAYER NOTES IN OTHERS */
.mini-note-box{
  display:flex;
  flex-direction:column;
  gap:.4rem;
  width:100%;
}
.mini-note-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.mini-area-input{
  width:100%;
  min-height:2rem;
  resize:vertical;
  font-size:.7rem;
  padding:.5rem .6rem;
  line-height:1.3;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
}

/* ACCORDIONS */
.accordion-block{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  overflow:hidden;
}
.accordion-head{
  background:var(--bg-accent);
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .75rem;
  cursor:pointer;
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.accordion-head .hint{
  color:var(--text-dim);
  font-size:.6rem;
  font-weight:400;
  margin-left:.5rem;
}
.accordion-body{
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  display:none;
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
}
.row-flex{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
}
.toggle-chip{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .5rem;
  font-size:.7rem;
  color:var(--text-primary);
  text-align:center;
  cursor:pointer;
}
.toggle-chip.active{
  box-shadow:0 0 10px var(--magenta);
  border-color:var(--text-dim);
  font-weight:600;
}
.area-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  width:100%;
  min-height:3rem;
  resize:vertical;
  font-size:.7rem;
  font-weight:400;
  color:var(--text-primary);
  line-height:1.3;
}

/* SCRYFALL LOOKUP */
.lookup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.lookup-input{
  flex:2;
  min-width:8rem;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.45rem .5rem;
  font-weight:600;
}
.lookup-btn{
  flex:1;
  min-width:5rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.lookup-results{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  font-size:.7rem;
  line-height:1.3;
  color:var(--text-primary);
  margin-top:.5rem;
}
.lookup-cardtext{
  flex:2;
  min-width:10rem;
  white-space:pre-line;
}
.lookup-cardimg{
  flex:1;
  min-width:6rem;
  max-width:140px;
  border-radius:.5rem;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  overflow:hidden;
}
.lookup-cardimg img{
  width:100%;
  height:auto;
  display:block;
}

/* FOOTER / TOOLS DOCK */
.tools-footer-wrap{
  position:sticky;
  bottom:0;
  z-index:1000;
  background:var(--tool-bg);
  border-top:1px solid var(--tool-border);
}
.tools-header-btn{
  width:100%;
  background:none;
  border:none;
  text-align:center;
  color:var(--text-primary);
  font-size:.75rem;
  font-weight:600;
  letter-spacing:.05em;
  padding:.6rem .75rem;
}
.tools-panel{
  border-top:1px solid var(--tool-border);
  display:none;
  padding:.75rem;
  font-size:.75rem;
  color:var(--text-primary);
  background:var(--tool-bg);
  max-height:50vh;
  overflow-y:auto;
}
.tools-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(200px,100%),1fr));
  gap:.75rem;
}
.tool-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.tool-title{
  font-size:.65rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.rng-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.rng-btn{
  flex:1;
  min-width:4rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
  padding:.6rem .75rem;
  text-align:center;
}
.rng-output{
  font-size:.8rem;
  font-weight:600;
  min-height:1em;
  line-height:1.2;
  color:var(--gold);
  word-break:break-word;
}
.global-input{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.45rem .5rem;
  color:var(--text-primary);
  font-size:.7rem;
  min-height:3rem;
  resize:vertical;
  line-height:1.3;
  width:100%;
}
.theme-select{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:100%;
}
.winner-mini-banner{
  border:1px solid var(--gold);
  color:var(--gold);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1.4;
  display:none;
  word-break:break-word;
}
.mode-line{
  font-size:.7rem;
  line-height:1.3;
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.mode-btn-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.mode-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}

/* Rules text block */
.rules-scroll-block{
  max-height:200px;
  overflow-y:auto;
  font-size:.7rem;
  line-height:1.4;
  white-space:pre-line;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  color:var(--text-primary);
}

/* OVERLAYS (setup, winner, announce, respawnDraw) */
.overlay-fullscreen{
  position:fixed;
  inset:0;
  background:var(--overlay-bg);
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:1rem;
}
.setup-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  display:flex;
  flex-direction:column;
  gap:1rem;
  text-align:center;
}
.setup-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.setup-sub{
  font-size:.7rem;
  color:var(--text-dim);
  line-height:1.4;
}
.setup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  justify-content:center;
}
.setup-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.setup-small{
  display:flex;
  flex-direction:column;
  gap:.5rem;
  align-items:center;
}
.setup-number-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:5rem;
  text-align:center;
}
.setup-go{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.5rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
}
.helper-row{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.3;
  text-align:center;
}

/* Winner overlay */
.winner-card{
  background:var(--bg-panel);
  border:2px solid var(--gold);
  border-radius:1rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  text-align:center;
  display:flex;
  flex-direction:column;
  gap:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.6),0 40px 80px rgba(0,0,0,.9);
}
.winner-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--gold);
  line-height:1.3;
  word-break:break-word;
}
.winner-line{
  font-size:.8rem;
  font-weight:500;
  color:var(--text-primary);
  line-height:1.4;
}
.overlay-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}

/* Generic announce overlay (KO, respawn, reigning, draw reminder) */
.announce-card{
  background:var(--bg-panel);
  border:2px solid var(--gold);
  border-radius:1rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  text-align:center;
  display:flex;
  flex-direction:column;
  gap:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.6),0 40px 80px rgba(0,0,0,.9);
  font-size:.8rem;
  line-height:1.4;
  color:var(--text-primary);
}
.announce-strong{
  color:var(--gold);
  font-weight:700;
  font-size:.9rem;
  line-height:1.3;
}
</style>
</head>
<body class="theme-dark">
<div class="app-shell">

  <!-- SETUP OVERLAY -->
  <div id="setupOverlay" class="overlay-fullscreen">
    <!-- Step 1 select mode -->
    <div class="setup-card" id="setupStepMode">
      <div class="setup-title">Select Mode</div>
      <div class="setup-row">
        <button class="setup-btn" data-mode="regular">
          Mode 1 — Regular
          <div class="setup-sub">Standard Commander. No respawn.</div>
        </button>
        <button class="setup-btn" data-mode="rumble">
          Mode 2 — Rumble
          <div class="setup-sub">Cooldown / Respawn / Reigning Rumbler.</div>
        </button>
      </div>
      <div class="helper-row">You’ll pick player count next.</div>
    </div>

    <!-- Step 2 select players -->
    <div class="setup-card" id="setupStepPlayers" style="display:none;">
      <div class="setup-title">How many players?</div>
      <div class="setup-row">
        <button class="setup-btn" data-fixedplayers="2">2</button>
        <button class="setup-btn" data-fixedplayers="3">3</button>
        <button class="setup-btn" data-fixedplayers="4">4</button>
      </div>
      <div class="setup-small">
        <div class="label-sm" style="text-align:center;">Manual Entry (2–8)</div>
        <input id="manualPlayerCount" class="setup-number-input" type="number" min="2" max="8" value="5" />
        <button id="manualStartBtn" class="setup-go">Start Game</button>
      </div>
      <div class="helper-row">Rename yourself on your turn.</div>
    </div>
  </div>

  <!-- WINNER OVERLAY -->
  <div id="winnerOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="winner-card">
      <div class="winner-title" id="winnerTitle">REIGNING RUMBLER!</div>
      <div class="winner-line" id="winnerTimeLine">Global Time: 00m 00s</div>
      <div class="winner-line" id="winnerPlayerTimeLine">Winner Player Time: 00m 00s</div>
      <button class="overlay-btn" id="winnerCloseBtn">OK</button>
    </div>
  </div>

  <!-- ANNOUNCE OVERLAY (KO, RESPAWN, DRAW REMINDER, REIGNING NOTICE) -->
  <div id="announceOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="announce-card">
      <div class="announce-strong" id="announceMain">Announcement</div>
      <div id="announceBody">Body text.</div>
      <button class="overlay-btn" id="announceOkBtn">OK</button>
    </div>
  </div>

  <!-- HEADER -->
  <div class="top-header">
    <div class="game-title">EDH RUMBLE TRACKER</div>
    <div class="header-row">
      <div id="turnBanner">▶ PLAYER 1'S TURN ◀</div>
      <div id="globalTimerBanner">Global: 0:00</div>
    </div>
  </div>

  <!-- MAIN CONTENT -->
  <div class="content-area" id="contentArea">
    <div id="hudArea"></div>

    <button class="end-turn-btn" id="endTurnBtn">End Turn →</button>

    <div id="othersArea"></div>

    <div id="accordionsArea"></div>
  </div>

  <!-- FOOTER / TOOLS -->
  <div class="tools-footer-wrap">
    <button class="tools-header-btn" id="toggleToolsBtn">Tools ▼</button>
    <div class="tools-panel" id="toolsPanel">
      <div class="tools-grid">

        <div class="tool-block">
          <div class="tool-title">Theme</div>
          <select id="themeSelect" class="theme-select">
            <option value="theme-dark" selected>Dark</option>
            <option value="theme-light">Light</option>
            <option value="theme-neon">Neon</option>
          </select>
        </div>

        <div class="tool-block">
          <div class="tool-title">Randomizers</div>
          <div class="rng-row">
            <button class="rng-btn" id="flipCoinBtn">Coin Flip</button>
            <button class="rng-btn" id="rollD6Btn">d6</button>
            <button class="rng-btn" id="rollD20Btn">d20</button>
          </div>
          <div class="rng-output" id="rngOutput"></div>
        </div>

        <div class="tool-block">
          <div class="tool-title">Current Plane (Planechase)</div>
          <textarea id="planeField" class="global-input" placeholder="Plane text / chaos effects..."></textarea>
        </div>

        <div class="tool-block">
          <div class="tool-title">Current Scheme (Archenemy)</div>
          <textarea id="schemeField" class="global-input" placeholder="Scheme text / ongoing..."></textarea>
        </div>

        <div class="tool-block">
          <div class="tool-title">Game Control</div>
          <div class="mode-line">
            <div id="modeStatusText">Mode 2 — Rumble</div>
            <div id="winnerMiniBanner" class="winner-mini-banner"></div>
            <div class="mode-btn-row">
              <button class="mode-btn" id="newGameBtn">New Game</button>
              <button class="mode-btn" id="changeModeBtn">Change Mode</button>
            </div>
          </div>
        </div>

        <div class="tool-block">
          <div class="tool-title">Rumble Rules (Official)</div>
          <div class="rules-scroll-block" id="rulesBlock">
Respawn Rumble Rules
Setup:
- Normal Commander decks (100-card singleton, color identity).
- Start 40 life, 0 poison.
- Commander damage and decking out still permanently eliminate you.

Temporary Death (Cooldown):
You go on cooldown instead of leaving the game if:
- Your life is 0 or less.
- You have 10 or more poison counters.
- An effect says “you lose the game.”
“Win the game” effects do nothing in this format.
Cooldown length is 1 + the number of players already on cooldown when you go out.

Permanent Elimination:
You are out of the game with no cooldown if:
- You’ve taken 21 or more combat damage from one commander this game.
- You would draw a card and can’t (decked out).

Cooldown Rules:
While on cooldown:
- You are removed from turn order.
- You cannot cast, activate, block, attack, respond, or be targeted as a player.
- Your permanents stay on the battlefield and still function, but you cannot protect them.
- Other players can attack/remove your board.
- Your hand, graveyard, command zone, exile, and emblems stay.
- Triggers that need your choices are ignored. Triggers that don’t need choices still work.

Cooldown Tick:
After every End Turn, all players on cooldown reduce their cooldown by 1 (down to 0).

Respawn:
When your cooldown reaches 0, you automatically respawn.
When you respawn:
- You become active again.
- Your life total becomes the average life total of all active players, rounded up.
- You remove all poison counters.
- Your commander tax resets.
- You regain control of anything you still own that survived on the battlefield.
- You re-enter turn order.
First Turn After Respawn:
- You skip the normal draw step.
- Instead, you draw 1 card at the end of that turn.

Reigning Rumbler:
If exactly one player is active and everyone else is on cooldown or eliminated, that player becomes the Reigning Rumbler.
After that player completes their next full turn, if they are still the only active player (nobody else has respawned), that player wins the game.

Regular Mode:
No cooldown or respawn. 0 life / 10 poison / lose-the-game kills you outright.
Last surviving player wins immediately.
          </div>
        </div>

      </div>
    </div>
  </div>

</div> <!-- end .app-shell -->

<script>
/* =========================
   GLOBAL STATE
========================= */

let gameMode = null; // "regular" or "rumble"
let players = [];
let turnIndex = 0;
let turnCounter = 0;
let gameStartTime = null;

let reigningCandidateIndex = null;
let reigningCandidateTurnStamp = null;

let winnerLocked = false;
let winnerName = "";
let winnerTimeMs = 0;
let winnerActiveMs = 0;

let accordionsOpen = {
  statusEffects:false,
  notes:false,
  lookup:false,
};

// dropdown persistence for other players
let otherOpen = {};

// track interval for live timer text only
let renderIntervalId = null;

let showingAnnounce = false;

/* DOM refs */
const setupOverlay           = document.getElementById("setupOverlay");
const setupStepMode          = document.getElementById("setupStepMode");
const setupStepPlayers       = document.getElementById("setupStepPlayers");
const manualPlayerCount      = document.getElementById("manualPlayerCount");
const manualStartBtn         = document.getElementById("manualStartBtn");

const winnerOverlay          = document.getElementById("winnerOverlay");
const winnerTitle            = document.getElementById("winnerTitle");
const winnerTimeLine         = document.getElementById("winnerTimeLine");
const winnerPlayerTimeLine   = document.getElementById("winnerPlayerTimeLine");
const winnerCloseBtn         = document.getElementById("winnerCloseBtn");
const winnerMiniBanner       = document.getElementById("winnerMiniBanner");

const announceOverlay        = document.getElementById("announceOverlay");
const announceMain           = document.getElementById("announceMain");
const announceBody           = document.getElementById("announceBody");
const announceOkBtn          = document.getElementById("announceOkBtn");

const turnBanner             = document.getElementById("turnBanner");
const globalTimerBanner      = document.getElementById("globalTimerBanner");

const hudArea                = document.getElementById("hudArea");
const endTurnBtn             = document.getElementById("endTurnBtn");
const othersArea             = document.getElementById("othersArea");
const accordionsArea         = document.getElementById("accordionsArea");

const toggleToolsBtn         = document.getElementById("toggleToolsBtn");
const toolsPanel             = document.getElementById("toolsPanel");

const themeSelect            = document.getElementById("themeSelect");
const flipCoinBtn            = document.getElementById("flipCoinBtn");
const rollD6Btn              = document.getElementById("rollD6Btn");
const rollD20Btn             = document.getElementById("rollD20Btn");
const rngOutput              = document.getElementById("rngOutput");

const modeStatusText         = document.getElementById("modeStatusText");
const newGameBtn             = document.getElementById("newGameBtn");
const changeModeBtn          = document.getElementById("changeModeBtn");

/* =========================
   UTILITIES
========================= */

function msToClock(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins + ":" + (secs<10?("0"+secs):secs);
}
function formatDurationMs(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins+"m "+secs+"s";
}
function getGameElapsedMs(){
  if(!gameStartTime) return 0;
  return Date.now()-gameStartTime;
}

// average life of all ACTIVE players (not counting the returning player yet)
function getAvgActiveLifeCeil(excludeIndex){
  let sum=0;
  let ct=0;
  players.forEach((pl,i)=>{
    if(i===excludeIndex) return;
    if(pl.status==="active"){
      sum+=pl.life;
      ct++;
    }
  });
  if(ct===0){
    // fail safe: if nobody else is active, give 1 life min
    return 1;
  }
  return Math.ceil(sum/ct);
}

function makePlayer(defaultName){
  return {
    name: defaultName,

    status:"active",          // "active","cooldown","eliminated"
    cooldownRemaining:0,

    life:40,
    poison:0,
    radiation:0,
    energy:0,
    experience:0,
    storm:0,

    hasMonarch:false,
    hasInitiative:false,
    hasCitysBlessing:false,

    dungeonProgress:"",
    emblemsText:"",
    notesText:"",

    commanderTaxSteps:0,

    commanderDamage:[], // victim.commanderDamage[srcIdx] = dmg taken from srcIdx's commander

    lookupNameInput:"",
    lastLookupName:"",
    lastLookupResult:"",
    lastLookupImg:"",

    totalActiveMs:0,
    turnStartMs:null,
    isTiming:false,

    pendingEOTDraw:false // after respawn, skip draw step, draw EOT first turn
  };
}

function syncCommanderDamageArrays(){
  players.forEach(p=>{
    while(p.commanderDamage.length < players.length){
      p.commanderDamage.push(0);
    }
    if(p.commanderDamage.length > players.length){
      p.commanderDamage.length = players.length;
    }
  });
}

function getActivePlayers(){
  let arr=[];
  players.forEach((pl,i)=>{
    if(pl.status==="active"){
      arr.push(i);
    }
  });
  return arr;
}

/* timing helpers */
function startTimingPlayer(i){
  const p=players[i];
  if(p.status!=="active") return;
  p.isTiming=true;
  p.turnStartMs=Date.now();
}
function stopTimingPlayer(i){
  const p=players[i];
  if(!p.isTiming) return;
  const now=Date.now();
  const diff = now-(p.turnStartMs||now);
  p.totalActiveMs += diff;
  p.isTiming=false;
  p.turnStartMs=null;
}
function getPlayerTurnMs(p){
  if(p.isTiming && p.turnStartMs!=null){
    return Date.now()-p.turnStartMs;
  }
  return 0;
}
function getPlayerTotalMs(p){
  return p.totalActiveMs+getPlayerTurnMs(p);
}

/* =========================
   ANNOUNCE OVERLAY HELPERS
========================= */
function showAnnounce(mainTxt, bodyTxt){
  if(showingAnnounce) return;
  showingAnnounce=true;
  announceMain.textContent = mainTxt;
  announceBody.textContent = bodyTxt;
  announceOverlay.style.display="flex";
}
announceOkBtn.addEventListener("click",()=>{
  announceOverlay.style.display="none";
  showingAnnounce=false;
});

/* =========================
   STATUS / DAMAGE / KOs
========================= */

function permanentlyEliminate(i){
  const p=players[i];
  stopTimingPlayer(i);
  p.status="eliminated";
  p.cooldownRemaining=0;
  p.pendingEOTDraw=false;
  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

// Commander damage check (21+ from one source kills immediately, regardless of mode)
function checkCommanderDamageElim(victimIdx){
  const p = players[victimIdx];
  for(let src=0; src<p.commanderDamage.length; src++){
    if(p.commanderDamage[src] >= 21){
      permanentlyEliminate(victimIdx);
      break;
    }
  }
}

// Called whenever lethal normal damage/poison/etc happens
function knockOutToCooldown(i){
  const p=players[i];
  if(gameMode==="regular"){
    // In Regular mode, lethal just eliminates
    permanentlyEliminate(i);
    showAnnounce(
      (p.name||("Player "+(i+1)))+" eliminated",
      "Regular mode: 0 life / 10 poison / lose-the-game is final."
    );
    return;
  }

  // Rumble mode:
  if(p.status==="eliminated") return;
  if(p.status==="cooldown") return;

  stopTimingPlayer(i);

  // cooldown turns = 1 + number of other cooldown players right now
  let alreadyCooling=0;
  players.forEach((q,qi)=>{
    if(qi!==i && q.status==="cooldown") alreadyCooling++;
  });

  p.status="cooldown";
  p.cooldownRemaining=1+alreadyCooling;
  p.pendingEOTDraw=false; // if they were in a respawn turn, that's gone

  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }

  showAnnounce(
    (p.name||("Player "+(i+1)))+" knocked out",
    "On cooldown for "+p.cooldownRemaining+" turn(s)."
  );
}

/* =========================
   RESPAWN
========================= */

function respawnPlayer(i){
  const p=players[i];
  if(p.status!=="cooldown") return;
  // compute new life using avg of current active players (excluding self)
  const newLife=getAvgActiveLifeCeil(i);

  p.status="active";
  p.cooldownRemaining=0;
  p.poison=0;
  p.life=newLife;
  p.commanderTaxSteps=0;
  p.pendingEOTDraw=true; // mark special draw rule turn
  // NOTE: board state is not changed in tracker;
  // assumption: their permanents still there stay theirs

  showAnnounce(
    (p.name||("Player "+(i+1)))+" respawned",
    "Life set to "+newLife+" (avg rounded up), poison = 0, commander tax reset. On their first turn back they skip normal draw and draw 1 at end of that turn."
  );
}

/* =========================
   RUMBLE: REIGNING RUMBLER
========================= */

function updateReigningCandidateOnTurnEnd(){
  if(gameMode!=="rumble" || winnerLocked) return;

  const actives=getActivePlayers();
  if(actives.length===1){
    const onlyIdx=actives[0];
    if(reigningCandidateIndex===null){
      reigningCandidateIndex=onlyIdx;
      reigningCandidateTurnStamp=turnCounter;
      showAnnounce(
        (players[onlyIdx].name||("Player "+(onlyIdx+1)))+" is now REIGNING RUMBLER",
        "If no one else returns to active before the end of their next full turn, they win."
      );
    }else if(reigningCandidateIndex!==onlyIdx){
      // new monarch of violence
      reigningCandidateIndex=onlyIdx;
      reigningCandidateTurnStamp=turnCounter;
      showAnnounce(
        (players[onlyIdx].name||("Player "+(onlyIdx+1)))+" is now REIGNING RUMBLER",
        "If no one else returns to active before the end of their next full turn, they win."
      );
    }
  }else{
    // more than one active, crown clears
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

// check after we advance turn / process cooldown / respawns
function checkReigningWin(){
  if(gameMode!=="rumble" || winnerLocked) return false;
  if(reigningCandidateIndex===null) return false;

  const actives=getActivePlayers();
  if(actives.length!==1) return false;
  const onlyIdx=actives[0];
  if(onlyIdx!==reigningCandidateIndex) return false;

  // Did the reigning candidate survive until after completing
  // their "next full turn"?
  // We stamp reigningCandidateTurnStamp when crowned = turnCounter at that moment.
  // They win if turnCounter > reigningCandidateTurnStamp+1 AND they're still lone.
  // Reason: reigning stamp at end of some turn T. They take full turn T+1. After T+1 ends -> win.
  if(turnCounter > (reigningCandidateTurnStamp+1)){
    lockWinner(onlyIdx,true);
    return true;
  }
  return false;
}

/* =========================
   WIN LOGIC (REGULAR & RUMBLE)
========================= */

function checkForWinRegular(){
  if(gameMode!=="regular" || winnerLocked) return false;
  const stillIn = players.filter(p=>p.status!=="eliminated");
  if(stillIn.length===1){
    const idx = players.indexOf(stillIn[0]);
    lockWinner(idx,false);
    return true;
  }
  return false;
}

function lockWinner(idx,isRumble){
  winnerLocked=true;
  winnerName = players[idx].name || ("Player "+(idx+1));
  winnerTimeMs = Date.now()-gameStartTime;
  winnerActiveMs = getPlayerTotalMs(players[idx]);

  if(isRumble){
    winnerTitle.textContent = winnerName.toUpperCase()+" — REIGNING RUMBLER!";
  } else {
    winnerTitle.textContent = winnerName+" wins the game!";
  }
  winnerTimeLine.textContent =
    "Global Time: "+formatDurationMs(winnerTimeMs);
  winnerPlayerTimeLine.textContent =
    "Winner Player Time: "+formatDurationMs(winnerActiveMs);

  winnerMiniBanner.style.display="block";
  winnerMiniBanner.textContent =
    winnerName+
    (isRumble? " — REIGNING RUMBLER! ":" wins!")+
    " ("+formatDurationMs(winnerTimeMs)+")";

  winnerOverlay.style.display="flex";
}
winnerCloseBtn.addEventListener("click",()=>{
  winnerOverlay.style.display="none";
});

/* =========================
   TURN FLOW
========================= */

function runEndOfTurnDrawIfNeeded(idx){
  // If this player was on their first turn after respawn,
  // they skip normal draw step and instead draw 1 now.
  const p=players[idx];
  if(!p) return;
  if(p.pendingEOTDraw){
    showAnnounce(
      (p.name||("Player "+(idx+1)))+" draw reminder",
      "Draw 1 card now (respawn recovery). You skipped your normal draw this turn."
    );
    // after the reminder is acknowledged, we clear in the announceOkBtn
    // to guarantee we don't clear early, we'll stash who to clear:
    pendingClearAfterAnnounce = idx;
  }
}

// We'll use this to finalize clearing pendingEOTDraw after player acknowledges
let pendingClearAfterAnnounce = null;
announceOkBtn.addEventListener("click",()=>{
  if(pendingClearAfterAnnounce!==null){
    const p=players[pendingClearAfterAnnounce];
    if(p){
      p.pendingEOTDraw=false;
    }
    pendingClearAfterAnnounce=null;
  }
});

function applyCooldownTickAndRespawns(){
  // only relevant for rumble
  if(gameMode!=="rumble") return;

  // 1. tick cooldownRemaining for all cooldown players
  players.forEach((pl,i)=>{
    if(pl.status==="cooldown"){
      if(pl.cooldownRemaining>0){
        pl.cooldownRemaining -= 1;
        if(pl.cooldownRemaining<0) pl.cooldownRemaining=0;
      }
    }
  });

  // 2. anyone now at 0 cooldown respawns immediately
  players.forEach((pl,i)=>{
    if(pl.status==="cooldown" && pl.cooldownRemaining===0){
      respawnPlayer(i);
    }
  });
}

function nextActivePlayerClockwise(fromIndex){
  if(players.length===0) return fromIndex;
  let idx=fromIndex;
  let safety=0;
  do{
    idx=(idx+1)%players.length;
    const pl=players[idx];
    if(pl.status==="active"){
      return idx;
    }
    safety++;
    if(safety>50) break;
  }while(true);
  return fromIndex;
}

function passTurn(){
  if(winnerLocked){
    renderAll();
    return;
  }

  // stop timing current active player
  stopTimingPlayer(turnIndex);

  // handle end-of-turn draw for respawned player if needed
  runEndOfTurnDrawIfNeeded(turnIndex);

  // increment turnCounter BEFORE cooldown ticks or reigning checks?
  // We treat "endTurn" as finishing this player's turn.
  // We'll increment turnCounter now to reflect that we just ended one.
  turnCounter += 1;

  // TICK COOLDOWNS / RESPAWN
  applyCooldownTickAndRespawns();

  // update reigningCandidate after these changes
  updateReigningCandidateOnTurnEnd();

  // In regular mode, we may already have a winner from eliminations:
  if(gameMode==="regular"){
    const didWinReg = checkForWinRegular();
    if(didWinReg){
      renderAll();
      return;
    }
  }

  // Check Reigning Rumbler win now that turn advanced, cooldown ticked, and respawns happened
  const didWinRumble = checkReigningWin();
  if(didWinRumble){
    renderAll();
    return;
  }

  // choose next player
  const newIdx = nextActivePlayerClockwise(turnIndex);
  turnIndex = newIdx;

  // start timing new active player
  if(players[turnIndex].status==="active"){
    startTimingPlayer(turnIndex);
  }

  renderAll();
}

/* =========================
   THEME / TOOLS
========================= */

toggleToolsBtn.addEventListener("click",()=>{
  if(toolsPanel.style.display==="block"){
    toolsPanel.style.display="none";
    toggleToolsBtn.textContent="Tools ▼";
  } else {
    toolsPanel.style.display="block";
    toggleToolsBtn.textContent="Tools ▲";
  }
});

themeSelect.addEventListener("change",()=>{
  document.body.classList.remove("theme-dark","theme-light","theme-neon");
  document.body.classList.add(themeSelect.value);
});

flipCoinBtn.addEventListener("click",()=>{
  rngOutput.textContent="Coin: "+(Math.random()<0.5?"Heads":"Tails");
});
rollD6Btn.addEventListener("click",()=>{
  rngOutput.textContent="d6: "+(Math.floor(Math.random()*6)+1);
});
rollD20Btn.addEventListener("click",()=>{
  rngOutput.textContent="d20: "+(Math.floor(Math.random()*20)+1);
});

newGameBtn.addEventListener("click",()=>{
  if(!confirm("Start a new game in the same mode? This clears all data.")) return;
  showPlayerCountStep(); // keep mode, repick player count
});
changeModeBtn.addEventListener("click",()=>{
  if(!confirm("Change mode? This restarts the game.")) return;
  showModeStep();
});

/* =========================
   SCRYFALL LOOKUP
========================= */

function analyzeOracleText(oracleText,typeLine){
  const text=(oracleText||"").toLowerCase();
  const tline=(typeLine||"").toLowerCase();
  const parsed={
    wantsMonarch:/become the monarch|you become the monarch/.test(text),
    wantsInitiative:/take the initiative|you take the initiative/.test(text),
    wantsCitysBlessing:/city's blessing/.test(text),
    wantsExp:/experience counter/.test(text),
    planeswalkerHint:/planeswalker/.test(tline),

    upkeepReminder:"",
    dungeonHint:"",
  };

  const upkeepMatch=oracleText && oracleText.match(/At the beginning of your upkeep[^.]*\./i);
  if(upkeepMatch){
    parsed.upkeepReminder="UPKEEP: "+upkeepMatch[0].trim();
  }

  if(/the initiative/.test(text)
  ||/undercity/.test(text)
  ||/venture into the dungeon/.test(text)){
    parsed.dungeonHint="Dungeon/Initiative: Track Undercity / dungeon steps each upkeep.";
  }
  return parsed;
}

async function doLookup(idx){
  const p=players[idx];
  const rawName=p.lookupNameInput||"";
  if(!rawName.trim()){
    p.lastLookupResult="Enter a card name first.";
    renderAll();
    return;
  }
  const url="https://api.scryfall.com/cards/named?fuzzy="+encodeURIComponent(rawName.trim());
  try{
    const resp=await fetch(url);
    if(!resp.ok){
      p.lastLookupName="";
      p.lastLookupResult="Card not found.";
      p.lastLookupImg="";
      renderAll();
      return;
    }
    const data=await resp.json();
    const oracle=data.oracle_text||"";
    const typeLine=data.type_line||"";

    p.lastLookupName=data.name||rawName.trim();
    p.lastLookupResult=(typeLine?typeLine+"\n":"")+(oracle?oracle:"");

    let imgUrl="";
    if(data.image_uris && data.image_uris.normal){
      imgUrl=data.image_uris.normal;
    }else if(Array.isArray(data.card_faces)
          && data.card_faces[0]
          && data.card_faces[0].image_uris){
      imgUrl=data.card_faces[0].image_uris.normal||"";
    }
    p.lastLookupImg=imgUrl;

    const parsed=analyzeOracleText(oracle,typeLine);
    if(parsed.wantsMonarch){ p.hasMonarch=true; }
    if(parsed.wantsInitiative){
      p.hasInitiative=true;
      if(!p.dungeonProgress.toLowerCase().includes("undercity")
      && !p.dungeonProgress.toLowerCase().includes("dungeon")){
        p.dungeonProgress += (p.dungeonProgress? "\n":"")
          +"Initiative: Progress Undercity each upkeep.";
      }
    }
    if(parsed.wantsCitysBlessing){ p.hasCitysBlessing=true; }
    if(parsed.wantsExp){
      if(!p.notesText.toLowerCase().includes("experience counter")){
        p.notesText += (p.notesText? "\n":"")
          +"This uses Experience counters. Track them.";
      }
    }
    if(parsed.planeswalkerHint){
      if(!p.notesText.toLowerCase().includes("track loyalty")){
        p.notesText += (p.notesText? "\n":"")
          +"If this is your commander, track loyalty like life.";
      }
    }
    if(parsed.upkeepReminder){
      if(!p.notesText.toLowerCase().includes(parsed.upkeepReminder.toLowerCase())){
        p.notesText += (p.notesText? "\n":"")+parsed.upkeepReminder;
      }
    }
    if(parsed.dungeonHint){
      if(!p.dungeonProgress.toLowerCase().includes("dungeon")){
        p.dungeonProgress += (p.dungeonProgress? "\n":"")+parsed.dungeonHint;
      }
    }

    renderAll();
  }catch(e){
    p.lastLookupName=rawName.trim();
    p.lastLookupResult="Lookup failed (offline?).";
    p.lastLookupImg="";
    renderAll();
  }
}

/* =========================
   RENDER HELPERS
========================= */

function renderGlobalTimerBanner(){
  globalTimerBanner.textContent = "Global: "+msToClock(getGameElapsedMs());
}
function renderTimersOnly(){
  renderGlobalTimerBanner();

  const p=players[turnIndex];
  if(p){
    const hudTimerBlocks = document.querySelectorAll("#hudArea .timer-block");
    // block0 Turn Time, block1 Player Time, block2 Global Time
    if(hudTimerBlocks.length>=3){
      const turnVal=hudTimerBlocks[0].querySelector(".timer-val");
      if(turnVal){
        turnVal.textContent=msToClock(getPlayerTurnMs(p));
      }
      const playerVal=hudTimerBlocks[1].querySelector(".timer-val");
      if(playerVal){
        playerVal.textContent=msToClock(getPlayerTotalMs(p));
      }
      const globalVal=hudTimerBlocks[2].querySelector(".timer-val");
      if(globalVal){
        globalVal.textContent=msToClock(getGameElapsedMs());
      }
    }
  }

  // update the Player Time in others list
  players.forEach((pl,i)=>{
    if(i===turnIndex) return;
    const node=document.querySelector(
      `.other-player-block[data-idx="${i}"] .player-time-val`
    );
    if(node){
      node.textContent=msToClock(getPlayerTotalMs(pl));
    }
  });
}

/* seat glow color */
function getSeatColor(i){
  const cols=["var(--gold)","var(--cyan)","var(--magenta)","var(--lime)"];
  return cols[i % cols.length];
}

/* =========================
   RENDER ALL
========================= */

function renderAll(){
  syncCommanderDamageArrays();

  const cur = players[turnIndex]||{};
  const nm  = cur.name||("Player "+(turnIndex+1));
  turnBanner.textContent = "▶ "+nm.toUpperCase()+"'S TURN ◀";

  modeStatusText.textContent =
    (gameMode==="regular"?"Mode 1 — Regular":"Mode 2 — Rumble");

  renderHUD();
  renderOthers();
  renderAccordions();
  renderGlobalTimerBanner();

  if(winnerLocked){
    winnerMiniBanner.style.display="block";
  }else if(!winnerTimeMs){
    winnerMiniBanner.style.display="none";
  }
}

/* HUD (active player card) */
function renderHUD(){
  hudArea.innerHTML="";
  const p=players[turnIndex];
  if(!p) return;

  const seatColor=getSeatColor(turnIndex);

  const card=document.createElement("div");
  card.className="hud-card";
  card.style.border="1px solid "+seatColor;
  card.style.boxShadow="0 0 20px "+seatColor+"80, 0 30px 60px rgba(0,0,0,.9)";

  const topRow=document.createElement("div");
  topRow.className="hud-top-row";

  /* LEFT COL */
  const leftCol=document.createElement("div");
  leftCol.className="hud-col";

  const nameBlock=document.createElement("div");
  nameBlock.className="section-block-inline";

  const nmLabel=document.createElement("div");
  nmLabel.className="label-sm";
  nmLabel.textContent="Your Name";

  const nmInput=document.createElement("input");
  nmInput.className="text-input";
  nmInput.value=p.name;
  nmInput.addEventListener("input",e=>{
    p.name=e.target.value;
  });
  nmInput.addEventListener("blur",()=>{ renderAll(); });
  nmInput.addEventListener("keydown",ev=>{
    if(ev.key==="Enter"){
      ev.preventDefault();
      nmInput.blur();
    }
  });

  const tinyStack=document.createElement("div");
  tinyStack.className="tiny-col-stack";

  // STATUS ROW
  const statusRow=document.createElement("div");
  statusRow.className="tiny-row";

  const stChip=document.createElement("div");
  stChip.className="status-chip "+
    (p.status==="active"?"status-active":
     p.status==="cooldown"?"status-cooldown":
                           "status-elim");

  stChip.textContent=
    p.status==="active"?"ACTIVE":
    p.status==="cooldown"?"COOLDOWN":
    "ELIMINATED";

  // Tap cycles status only for admin fix (not normal cheating path)
  stChip.title = (gameMode==="rumble")
    ? "Tap to correct: Active ↔ Cooldown ↔ Eliminated"
    : "Tap to correct: Active ↔ Eliminated";
  stChip.addEventListener("click",()=>{
    cycleStatusAdmin(turnIndex);
  });

  statusRow.appendChild(stChip);

  // show cooldownRemaining if cooling
  if(p.status==="cooldown" && gameMode==="rumble"){
    const cdWrap=document.createElement("div");
    cdWrap.className="cd-info-inline";

    const cdLab=document.createElement("div");
    cdLab.className="cd-label";
    cdLab.textContent="Cooldown:";

    const cdVal=document.createElement("div");
    cdVal.className="cd-val-box";
    cdVal.textContent=p.cooldownRemaining;

    cdWrap.appendChild(cdLab);
    cdWrap.appendChild(cdVal);
    statusRow.appendChild(cdWrap);
  }

  // COMMANDER TAX
  const taxRow=document.createElement("div");
  taxRow.className="tax-row";

  const taxLabel=document.createElement("div");
  taxLabel.className="tax-label";
  taxLabel.textContent="Commander Tax: +2 ×";

  const taxCtrl=document.createElement("div");
  taxCtrl.className="tax-ctrl";

  const taxMinus=document.createElement("div");
  taxMinus.className="tax-btn";
  taxMinus.textContent="-";
  taxMinus.addEventListener("click",()=>{
    if(p.commanderTaxSteps>0)p.commanderTaxSteps--;
    renderAll();
  });

  const taxVal=document.createElement("div");
  taxVal.className="tax-val";
  taxVal.textContent=p.commanderTaxSteps;

  const taxPlus=document.createElement("div");
  taxPlus.className="tax-btn";
  taxPlus.textContent="+";
  taxPlus.addEventListener("click",()=>{
    p.commanderTaxSteps++;
    renderAll();
  });

  taxCtrl.appendChild(taxMinus);
  taxCtrl.appendChild(taxVal);
  taxCtrl.appendChild(taxPlus);

  // TIMERS
  const timeRow=document.createElement("div");
  timeRow.className="timer-row";

  const tBlock1=document.createElement("div");
  tBlock1.className="timer-block";
  const tb1L=document.createElement("div");
  tb1L.className="timer-label";
  tb1L.textContent="Turn Time";
  const tb1V=document.createElement("div");
  tb1V.className="timer-val";
  tb1V.textContent=msToClock(getPlayerTurnMs(p));
  tBlock1.appendChild(tb1L);
  tBlock1.appendChild(tb1V);

  const tBlock2=document.createElement("div");
  tBlock2.className="timer-block";
  const tb2L=document.createElement("div");
  tb2L.className="timer-label";
  tb2L.textContent="Player Time";
  const tb2V=document.createElement("div");
  tb2V.className="timer-val";
  tb2V.textContent=msToClock(getPlayerTotalMs(p));
  tBlock2.appendChild(tb2L);
  tBlock2.appendChild(tb2V);

  const tBlock3=document.createElement("div");
  tBlock3.className="timer-block";
  const tb3L=document.createElement("div");
  tb3L.className="timer-label";
  tb3L.textContent="Global Time";
  const tb3V=document.createElement("div");
  tb3V.className="timer-val";
  tb3V.textContent=msToClock(getGameElapsedMs());
  tBlock3.appendChild(tb3L);
  tBlock3.appendChild(tb3V);

  timeRow.appendChild(tBlock1);
  timeRow.appendChild(tBlock2);
  timeRow.appendChild(tBlock3);

  const tinyStackTop=document.createElement("div");
  tinyStackTop.appendChild(statusRow);
  tinyStackTop.appendChild(taxRow);
  tinyStackTop.appendChild(timeRow);

  // Respawn draw banner
  if(p.pendingEOTDraw){
    const reminder=document.createElement("div");
    reminder.className="respawn-draw-banner";
    reminder.textContent="Respawn Turn: Skip normal draw step. Draw 1 at END of this turn.";
    tinyStackTop.appendChild(reminder);
  }

  nameBlock.appendChild(nmLabel);
  nameBlock.appendChild(nmInput);
  nameBlock.appendChild(tinyStackTop);

  leftCol.appendChild(nameBlock);

  /* RIGHT COL */
  const rightCol=document.createElement("div");
  rightCol.className="hud-col";

  const vitalsBlock=document.createElement("div");
  vitalsBlock.className="section-block-inline vitalsBlock";

  const lfLabel=document.createElement("div");
  lfLabel.className="label-sm";
  lfLabel.textContent="Life Total";

  const lfRow=document.createElement("div");
  lfRow.className="life-row";

  const minusBtn=document.createElement("div");
  minusBtn.className="life-btn";
  minusBtn.textContent="-";
  minusBtn.addEventListener("click",()=>{
    p.life = p.life-1;
    lethalCheck(turnIndex,"life");
    renderAll();
  });

  const lifeVal=document.createElement("div");
  lifeVal.className="life-value";
  lifeVal.textContent=p.life;

  const plusBtn=document.createElement("div");
  plusBtn.className="life-btn";
  plusBtn.textContent="+";
  plusBtn.addEventListener("click",()=>{
    p.life = p.life+1;
    renderAll();
  });

  lfRow.appendChild(minusBtn);
  lfRow.appendChild(lifeVal);
  lfRow.appendChild(plusBtn);

  const grid=document.createElement("div");
  grid.className="mini-counters-grid";

  grid.appendChild(makeMiniStepperBox("☠ Poison",p.poison,(newVal)=>{
    p.poison=newVal;
    lethalCheck(turnIndex,"poison");
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("☢ Rad",p.radiation,(newVal)=>{
    p.radiation=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("⚡ Energy",p.energy,(newVal)=>{
    p.energy=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("★ Exp",p.experience,(newVal)=>{
    p.experience=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("☁ Storm",p.storm,(newVal)=>{
    p.storm=newVal;
    renderAll();
  }));

  vitalsBlock.appendChild(lfLabel);
  vitalsBlock.appendChild(lfRow);
  vitalsBlock.appendChild(grid);

  rightCol.appendChild(vitalsBlock);

  topRow.appendChild(leftCol);
  topRow.appendChild(rightCol);
  card.appendChild(topRow);

  hudArea.appendChild(card);
}

function makeMiniStepperBox(labelText,val,onSet){
  const wrap=document.createElement("div");
  wrap.className="mini-counter-box";

  const lab=document.createElement("div");
  lab.className="mini-counter-label";
  lab.textContent=labelText;

  const row=document.createElement("div");
  row.className="mini-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1;
    if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1;
    if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);

  wrap.appendChild(lab);
  wrap.appendChild(row);
  return wrap;
}

/* OTHERS LIST */
function renderOthers(){
  othersArea.innerHTML="";
  const wrap=document.createElement("div");
  wrap.className="others-card";

  const hdr=document.createElement("div");
  hdr.className="other-header";
  hdr.textContent="Other Players";
  wrap.appendChild(hdr);

  players.forEach((pl,i)=>{
    if(i===turnIndex) return;
    const block=document.createElement("div");
    block.className="other-player-block";
    block.setAttribute("data-idx",i);

    const top=document.createElement("div");
    top.className="other-player-top";

    const nm=pl.name||("Player "+(i+1));
    const titleSpan=document.createElement("span");
    titleSpan.textContent=nm;

    const chev=document.createElement("span");
    chev.className="other-expand-indicator";

    const body=document.createElement("div");
    body.className="other-player-body";

    const isOpen=!!otherOpen[i];
    if(isOpen){
      body.style.display="flex";
      chev.textContent="▲";
    }else{
      body.style.display="none";
      chev.textContent="▼";
    }

    // STATUS LINE
    const statusLine=document.createElement("div");
    statusLine.className="status-line-other";

    const statusText=document.createElement("div");
    statusText.textContent="Status: "+pl.status.toUpperCase();
    statusLine.appendChild(statusText);

    if(pl.status==="cooldown" && gameMode==="rumble"){
      const cdLab=document.createElement("div");
      cdLab.className="cd-label";
      cdLab.style.fontSize=".6rem";
      cdLab.style.color="var(--text-dim)";
      cdLab.style.textTransform="uppercase";
      cdLab.style.letterSpacing=".05em";
      cdLab.textContent="Cooldown:";
      const cdNum=document.createElement("div");
      cdNum.className="cd-val-box";
      cdNum.textContent=pl.cooldownRemaining;
      statusLine.appendChild(cdLab);
      statusLine.appendChild(cdNum);
    }

    // player time
    const timeBox=document.createElement("div");
    timeBox.style.display="flex";
    timeBox.style.flexWrap="wrap";
    timeBox.style.alignItems="center";
    timeBox.style.gap=".5rem .75rem";

    const tLab=document.createElement("div");
    tLab.className="cd-label";
    tLab.textContent="Player Time:";
    const tVal=document.createElement("div");
    tVal.className="cd-val-box player-time-val";
    tVal.textContent=msToClock(getPlayerTotalMs(pl));
    timeBox.appendChild(tLab);
    timeBox.appendChild(tVal);

    statusLine.appendChild(timeBox);
    body.appendChild(statusLine);

    // LIFE / +/- CONTROLS
    const lifeCol=document.createElement("div");
    lifeCol.className="mini-col";

    const lifeLab=document.createElement("div");
    lifeLab.className="label-sm";
    lifeLab.textContent="Life Total ("+nm+")";

    const lifeRow=document.createElement("div");
    lifeRow.className="life-edit-inline";

    const minusBtn=document.createElement("div");
    minusBtn.className="life-inline-btn";
    minusBtn.textContent="-";
    minusBtn.addEventListener("click",()=>{
      pl.life=pl.life-1;
      lethalCheck(i,"life");
      renderAll();
    });

    const lifeVal=document.createElement("div");
    lifeVal.className="life-inline-val";
    lifeVal.textContent=pl.life;

    const plusBtn=document.createElement("div");
    plusBtn.className="life-inline-btn";
    plusBtn.textContent="+";
    plusBtn.addEventListener("click",()=>{
      pl.life=pl.life+1;
      renderAll();
    });

    lifeRow.appendChild(minusBtn);
    lifeRow.appendChild(lifeVal);
    lifeRow.appendChild(plusBtn);
    lifeCol.appendChild(lifeLab);
    lifeCol.appendChild(lifeRow);

    body.appendChild(lifeCol);

    // poison/rad/exp/storm
    const debuffRow=document.createElement("div");
    debuffRow.className="mini-row";

    debuffRow.appendChild(smallStepperBox("☠ Poison",pl.poison,(v)=>{
      pl.poison=v;
      lethalCheck(i,"poison");
      renderAll();
    }));
    debuffRow.appendChild(smallStepperBox("☢ Rad",pl.radiation,(v)=>{
      pl.radiation=v;
      renderAll();
    }));
    debuffRow.appendChild(smallStepperBox("★ Exp",pl.experience,(v)=>{
      pl.experience=v;
      renderAll();
    }));
    debuffRow.appendChild(smallStepperBox("☁ Storm",pl.storm,(v)=>{
      pl.storm=v;
      renderAll();
    }));

    body.appendChild(debuffRow);

    // COMMANDER DAMAGE GRID
    const cdmgWrap=document.createElement("div");
    cdmgWrap.className="cdmg-section-wrap";

    const cdmgLab=document.createElement("div");
    cdmgLab.className="cdmg-label";
    cdmgLab.textContent=
      "Commander Damage Taken by "+nm+" (21 from any 1 source = elim)";
    cdmgWrap.appendChild(cdmgLab);

    const cdmgGrid=document.createElement("div");
    cdmgGrid.className="cdmg-grid";

    players.forEach((srcPl,srcIdx)=>{
      const srcName=srcPl.name||("P"+(srcIdx+1));
      const cell=document.createElement("div");
      cell.className="cdmg-cell";

      const cellLabel=document.createElement("div");
      cellLabel.className="cdmg-cell-label";
      cellLabel.textContent="from "+srcName;

      const inputRow=document.createElement("div");
      inputRow.className="cdmg-input-row";

      const dmgIn=document.createElement("input");
      dmgIn.type="number";
      dmgIn.min="0";
      dmgIn.value=pl.commanderDamage[srcIdx]||0;
      dmgIn.addEventListener("input",e=>{
        let v=parseInt(e.target.value,10);
        if(isNaN(v)||v<0)v=0;
        pl.commanderDamage[srcIdx]=v;
        checkCommanderDamageElim(i);
        renderAll();
      });

      inputRow.appendChild(dmgIn);
      cell.appendChild(cellLabel);
      cell.appendChild(inputRow);
      cdmgGrid.appendChild(cell);
    });

    cdmgWrap.appendChild(cdmgGrid);
    body.appendChild(cdmgWrap);

    // player note box
    const miniNote=document.createElement("div");
    miniNote.className="mini-note-box";
    const mnLab=document.createElement("div");
    mnLab.className="mini-note-label";
    mnLab.textContent="Note on "+nm+" (Monarch, Initiative, Goaded, etc.)";
    const mnArea=document.createElement("textarea");
    mnArea.className="mini-area-input";
    mnArea.value=pl.notesText;
    mnArea.addEventListener("input",e=>{
      pl.notesText=e.target.value;
    });
    miniNote.appendChild(mnLab);
    miniNote.appendChild(mnArea);
    body.appendChild(miniNote);

    top.addEventListener("click",()=>{
      otherOpen[i]=!otherOpen[i];
      renderOthers();
    });

    top.appendChild(titleSpan);
    top.appendChild(chev);
    block.appendChild(top);
    block.appendChild(body);

    wrap.appendChild(block);
  });

  othersArea.appendChild(wrap);
}

function smallStepperBox(labelText,val,onSet){
  const box=document.createElement("div");
  box.className="mini-col";

  const l=document.createElement("div");
  l.className="label-sm";
  l.textContent=labelText;

  const row=document.createElement("div");
  row.className="mini-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1; if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1; if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);

  box.appendChild(l);
  box.appendChild(row);
  return box;
}

/* ACCORDIONS (status, notes, lookup) */
function renderAccordions(){
  accordionsArea.innerHTML="";
  const p=players[turnIndex];
  if(!p) return;

  const acc1=makeAccordion(
    "statusEffects",
    "Status Effects / Titles",
    "Monarch, Initiative, Blessing, Dungeon, Emblems",
    (body)=>{
      const togglesRow=document.createElement("div");
      togglesRow.className="row-flex";

      togglesRow.appendChild(makeToggleChip("Monarch",p.hasMonarch,val=>{
        p.hasMonarch=val; renderAll();
      }));
      togglesRow.appendChild(makeToggleChip("Initiative",p.hasInitiative,val=>{
        p.hasInitiative=val; renderAll();
      }));
      togglesRow.appendChild(makeToggleChip("Blessing",p.hasCitysBlessing,val=>{
        p.hasCitysBlessing=val; renderAll();
      }));

      body.appendChild(togglesRow);

      const dLabel=document.createElement("div");
      dLabel.className="label-sm";
      dLabel.textContent="Dungeon / Undercity / Progress";

      const dArea=document.createElement("textarea");
      dArea.className="area-input";
      dArea.placeholder="Initiative, Undercity steps, dungeon rooms..."
      dArea.value=p.dungeonProgress;
      dArea.addEventListener("input",e=>{
        p.dungeonProgress=e.target.value;
      });

      const eLabel=document.createElement("div");
      eLabel.className="label-sm";
      eLabel.textContent="Emblems / Globals";

      const eArea=document.createElement("textarea");
      eArea.className="area-input";
      eArea.placeholder="Emblems, static buffs, city-wide effects..."
      eArea.value=p.emblemsText;
      eArea.addEventListener("input",e=>{
        p.emblemsText=e.target.value;
      });

      body.appendChild(dLabel);
      body.appendChild(dArea);
      body.appendChild(eLabel);
      body.appendChild(eArea);
    }
  );

  const acc2=makeAccordion(
    "notes",
    "Notes / Reminders",
    "Goad, skip draw, bounty, upkeep triggers",
    (body)=>{
      const notesLabel=document.createElement("div");
      notesLabel.className="label-sm";
      notesLabel.textContent="Notes";
      const notesArea=document.createElement("textarea");
      notesArea.className="area-input";
      notesArea.placeholder="Goaded Krenko, Skip next draw, Bounty on Theo..."
      notesArea.value=p.notesText;
      notesArea.addEventListener("input",e=>{
        p.notesText=e.target.value;
      });

      body.appendChild(notesLabel);
      body.appendChild(notesArea);
    }
  );

  const acc3=makeAccordion(
    "lookup",
    "Card Lookup (Scryfall)",
    "Pull card text + auto reminders",
    (body)=>{
      const lookRow=document.createElement("div");
      lookRow.className="lookup-row";

      const lookInput=document.createElement("input");
      lookInput.className="lookup-input";
      lookInput.placeholder="Search card..."
      lookInput.value=p.lookupNameInput;
      lookInput.addEventListener("input",e=>{
        p.lookupNameInput=e.target.value;
      });

      const lookBtn=document.createElement("button");
      lookBtn.className="lookup-btn";
      lookBtn.textContent="Lookup";
      lookBtn.addEventListener("click",()=>{
        doLookup(turnIndex);
      });

      lookRow.appendChild(lookInput);
      lookRow.appendChild(lookBtn);

      const lookResults=document.createElement("div");
      lookResults.className="lookup-results";

      if(p.lastLookupName || p.lastLookupResult){
        const textDiv=document.createElement("div");
        textDiv.className="lookup-cardtext";
        textDiv.textContent=
          (p.lastLookupName? p.lastLookupName+"\n":"")+
          (p.lastLookupResult||"");

        lookResults.appendChild(textDiv);

        if(p.lastLookupImg){
          const imgWrap=document.createElement("div");
          imgWrap.className="lookup-cardimg";
          const img=document.createElement("img");
          img.src=p.lastLookupImg;
          img.alt=p.lastLookupName||"card art";
          imgWrap.appendChild(img);
          lookResults.appendChild(imgWrap);
        }
      }else{
        const hint=document.createElement("div");
        hint.className="small-hint";
        hint.textContent="Auto-adds Monarch / Initiative and upkeep reminders to Notes.";
        lookResults.appendChild(hint);
      }

      body.appendChild(lookRow);
      body.appendChild(lookResults);
    }
  );

  accordionsArea.appendChild(acc1);
  accordionsArea.appendChild(acc2);
  accordionsArea.appendChild(acc3);
}

function makeToggleChip(label,active,onToggle){
  const chip=document.createElement("div");
  chip.className="toggle-chip"+(active?" active":"");
  chip.textContent=active?(label+" ✓"):label;
  chip.addEventListener("click",()=>{ onToggle(!active); });
  return chip;
}
function makeAccordion(key,title,hint,fillBodyFn){
  const wrap=document.createElement("div");
  wrap.className="accordion-block";

  const head=document.createElement("div");
  head.className="accordion-head";

  const leftSpan=document.createElement("div");
  leftSpan.textContent=title;

  const rightSpan=document.createElement("div");
  rightSpan.style.display="flex";
  rightSpan.style.gap=".5rem";
  rightSpan.style.alignItems="center";

  const hintEl=document.createElement("div");
  hintEl.className="hint";
  hintEl.textContent=hint;

  const chevron=document.createElement("div");
  chevron.style.color="var(--text-dim)";
  chevron.style.fontSize=".8rem";

  rightSpan.appendChild(hintEl);
  rightSpan.appendChild(chevron);

  const body=document.createElement("div");
  body.className="accordion-body";

  fillBodyFn(body);

  if(accordionsOpen[key]){
    body.style.display="block";
    chevron.textContent="▲";
  }else{
    body.style.display="none";
    chevron.textContent="▼";
  }

  head.addEventListener("click",()=>{
    accordionsOpen[key]=!accordionsOpen[key];
    if(accordionsOpen[key]){
      body.style.display="block";
      chevron.textContent="▲";
    }else{
      body.style.display="none";
      chevron.textContent="▼";
    }
  });

  wrap.appendChild(head);
  wrap.appendChild(body);
  return wrap;
}

/* =========================
   LETHAL CHECKS
========================= */

function lethalCheck(i,source){
  const p=players[i];
  if(!p) return;

  // If commander damage killed them already, they're eliminated (handled elsewhere)
  // Otherwise:
  if(source==="life" && p.life<=0){
    knockOutToCooldown(i);
    return;
  }
  if(source==="poison" && p.poison>=10){
    knockOutToCooldown(i);
    return;
  }
  // "you lose the game" style effects aren't auto in UI, but could be future button.
  // We'll include a helper call if we add that.
}

/* =========================
   ADMIN STATUS CYCLE
   (for corrections only)
========================= */

function cycleStatusAdmin(i){
  const p=players[i];
  // basic correction path, not normal gameplay
  if(gameMode==="rumble"){
    // active -> cooldown -> eliminated -> active
    if(p.status==="active"){
      // send to cooldown w/ standard calc
      knockOutToCooldown(i);
    }else if(p.status==="cooldown"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction."
      );
    }else{
      // revive as active (house fix)
      p.status="active";
      p.cooldownRemaining=0;
      p.pendingEOTDraw=false;
    }
  }else{
    // regular: active -> eliminated -> active
    if(p.status==="active"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction."
      );
    }else{
      p.status="active";
      p.cooldownRemaining=0;
      p.pendingEOTDraw=false;
    }
  }
  renderAll();
}

/* =========================
   SETUP / NEW GAME / MODE SWITCH
========================= */

function resetGameStateKeepMode(){
  players=[];
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;
  winnerName="";
  winnerTimeMs=0;
  winnerActiveMs=0;
  otherOpen={};

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  setupStepMode.style.display="none";
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

function showModeStep(){
  players=[];
  gameStartTime=null;
  winnerLocked=false;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  otherOpen={};

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  setupStepMode.style.display="flex";
  setupStepPlayers.style.display="none";
  setupOverlay.style.display="flex";
}

function showPlayerCountStep(){
  players=[];
  gameStartTime=null;
  winnerLocked=false;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  otherOpen={};

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  setupStepMode.style.display="none";
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

setupStepMode.querySelectorAll("[data-mode]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const m=btn.getAttribute("data-mode");
    gameMode=m==="regular"?"regular":"rumble";
    showPlayerCountStep();
  });
});

setupStepPlayers.querySelectorAll("[data-fixedplayers]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const n=parseInt(btn.getAttribute("data-fixedplayers"),10);
    startGameWith(n);
  });
});

manualStartBtn.addEventListener("click",()=>{
  let n=parseInt(manualPlayerCount.value,10);
  if(isNaN(n)||n<2)n=2;
  if(n>8)n=8;
  startGameWith(n);
});

function startGameWith(nPlayers){
  players=[];
  for(let i=0;i<nPlayers;i++){
    players.push(makePlayer("Player "+(i+1)));
  }
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;
  winnerName="";
  winnerTimeMs=0;
  winnerActiveMs=0;
  otherOpen={};

  gameStartTime=Date.now();

  syncCommanderDamageArrays();
  // start timing first player
  if(players[0] && players[0].status==="active"){
    startTimingPlayer(0);
  }

  setupOverlay.style.display="none";

  renderAll();

  if(renderIntervalId){
    clearInterval(renderIntervalId);
  }
  renderIntervalId=setInterval(()=>{
    if(!winnerLocked){
      renderTimersOnly();
    }
  },1000);
}

/* =========================
   EVENT LISTENERS
========================= */

endTurnBtn.addEventListener("click",()=>{
  passTurn();
});

winnerCloseBtn.addEventListener("click",()=>{
  winnerOverlay.style.display="none";
});

</script>
</body>
</html>