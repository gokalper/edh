<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>EDH RUMBLE TRACKER v16</title>
<style>
/* =========================================================
   THEME VARIABLES
   Body has 0/1 of: [none=Light] .theme-dark .theme-neon
   Animated transitions between themes
========================================================= */
:root {
  --bg-main:#ffffff;
  --bg-panel:#ffffff;
  --bg-accent:#f4f4fa;
  --border-soft:#bfbfd4;

  --text-primary:#1a1a22;
  --text-dim:#5a5a77;

  --gold:#9c7a1f;
  --cyan:#2a8f8f;
  --magenta:#b51882;
  --lime:#2a8f2a;
  --red:#a63f3f;
  --off:#8a8aa5;

  --button-bg:#ffffff;
  --button-border:#bfbfd4;

  --overlay-bg:rgba(0,0,0,0.6);

  --tool-bg:#ffffff;
  --tool-border:#bfbfd4;

  --glow-current:rgba(156,122,31,.45);
  --accent-warn-bg:rgba(212,169,79,.07);
  --accent-warn-border:var(--gold);

  --shadow-card:0 20px 40px rgba(0,0,0,.12);
  --shadow-card-strong:0 0 20px rgba(0,0,0,.15),0 30px 60px rgba(0,0,0,.2);

  --sheet-max:480px;
}
.theme-dark {
  --bg-main:#0f0f12;
  --bg-panel:#1a1a22;
  --bg-accent:#2a2a36;
  --border-soft:#3a3a4f;

  --text-primary:#f5f5fa;
  --text-dim:#8a8aa5;

  --gold:#d4a94f;
  --cyan:#5fd8d8;
  --magenta:#ff4acb;
  --lime:#5fd85f;
  --red:#d85f5f;
  --off:#55556e;

  --button-bg:#2a2a36;
  --button-border:#3a3a4f;

  --overlay-bg:rgba(0,0,0,0.8);

  --tool-bg:#1a1a22;
  --tool-border:#3a3a4f;

  --glow-current:rgba(212,169,79,.5);
  --accent-warn-bg:rgba(212,169,79,.07);
  --accent-warn-border:var(--gold);

  --shadow-card:0 20px 40px rgba(0,0,0,.6);
  --shadow-card-strong:0 0 20px rgba(255,255,255,.08),0 30px 60px rgba(0,0,0,.9);
}
.theme-neon {
  --bg-main:#050509;
  --bg-panel:#0e0e1a;
  --bg-accent:#1a1a33;
  --border-soft:#4a4aff;

  --text-primary:#ffeefe;
  --text-dim:#ff4aeb;

  --gold:#ffef5a;
  --cyan:#5fd8ff;
  --magenta:#ff4acb;
  --lime:#5CFFB6;
  --red:#ff4a6b;
  --off:#4f4f80;

  --button-bg:#1a1a33;
  --button-border:#4a4aff;

  --overlay-bg:rgba(0,0,30,0.8);

  --tool-bg:#0e0e1a;
  --tool-border:#4a4aff;

  --glow-current:rgba(90,90,255,.55);
  --accent-warn-bg:rgba(255,239,90,.07);
  --accent-warn-border:var(--gold);

  --shadow-card:0 20px 40px rgba(0,0,40,.8);
  --shadow-card-strong:0 0 25px rgba(90,90,255,.6),0 30px 80px rgba(0,0,0,.9);
}

/* smooth theming / motion */
*, *::before, *::after {
  box-sizing:border-box;
  font-family:system-ui, Roboto, "Helvetica Neue", Arial, sans-serif;
  -webkit-tap-highlight-color:rgba(0,0,0,0);
}
body{
  margin:0;
  background:var(--bg-main);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  justify-content:center;
  transition:
    background-color .3s ease,
    color .3s ease,
    box-shadow .3s ease,
    border-color .3s ease;
}
button{
  cursor:pointer;
  font-family:inherit;
  color:var(--text-primary);
  background:none;
  border:none;
}
input, textarea, select {
  font-family:inherit;
  color:var(--text-primary);
  background:none;
  border:none;
}

/* subtle scale/tap feedback */
button:active,
div.step-btn:active,
div.life-btn:active,
div.tax-btn:active,
.end-turn-btn:active,
.cooldown-ack-btn:active,
.overlay-btn:active,
.setup-btn:active,
.setup-go:active,
.rng-btn:active,
.lookup-btn:active {
  transform:scale(.95);
  transition:transform .07s;
}

/* =========================================================
   APP SHELL
========================================================= */
.app-shell{
  width:100%;
  max-width:var(--sheet-max);
  min-height:100vh;
  background:var(--bg-main);
  display:flex;
  flex-direction:column;
  position:relative;
}

/* -------------------------------------------------
   TURN REMINDER STRIP
------------------------------------------------- */
.turn-reminder-bar{
  background:var(--bg-accent);
  border-bottom:1px solid var(--border-soft);
  padding:.5rem .75rem;
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  gap:.5rem .75rem;
  text-align:center;
  font-size:.8rem;
  line-height:1.3;
  position:relative;
  z-index:1000;
}
.turn-reminder-main{
  font-size:.8rem;
  font-weight:700;
  color:var(--gold);
  letter-spacing:.05em;
  text-shadow:0 0 8px var(--glow-current);
  transition:color .3s,text-shadow .3s;
}
.turn-reminder-extra{
  font-size:.7rem;
  font-weight:600;
  color:var(--red);
  line-height:1.3;
  animation:pulseWarn 1.5s infinite;
}
@keyframes pulseWarn{
  0%{opacity:1;}
  50%{opacity:.4;}
  100%{opacity:1;}
}

/* -------------------------------------------------
   HEADER BAR (title / global timer / theme cycle)
------------------------------------------------- */
.app-header{
  position:sticky;
  top:0;
  z-index:900;
  background:var(--bg-panel);
  border-bottom:1px solid var(--border-soft);
  padding:.6rem .75rem;
  display:flex;
  flex-wrap:wrap;
  justify-content:space-between;
  align-items:center;
  gap:.5rem .75rem;
  transition:background .3s,border-color .3s,box-shadow .3s;
}
.game-title{
  font-size:.8rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
  line-height:1.2;
  display:flex;
  flex-direction:column;
}
.game-sub{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  line-height:1.2;
}
#globalTimerBanner{
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  letter-spacing:.05em;
  min-width:4.5rem;
  text-align:center;
}
.theme-toggle-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.4rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  line-height:1;
  min-width:3.5rem;
  text-align:center;
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
  box-shadow:0 8px 16px rgba(0,0,0,.2);
}

/* -------------------------------------------------
   MAIN SCROLL CONTENT
------------------------------------------------- */
.content-area{
  flex:1;
  overflow-y:auto;
  scroll-behavior:smooth;
  padding:1rem .75rem 6rem; /* leave room for bottom bar trigger */
  display:flex;
  flex-direction:column;
  gap:.75rem;
  position:relative;
}

/* -------------------------------------------------
   ACTIVE PLAYER HUD CARD
------------------------------------------------- */
.hud-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.75rem;
  box-shadow:var(--shadow-card);
  position:relative;
  transition:border-color .25s, box-shadow .25s, background .25s;
  animation:fadeInUp .25s ease both;
}
.hud-card.glow-border{
  box-shadow:0 0 18px var(--glow-current),0 30px 60px rgba(0,0,0,.5);
}
@keyframes fadeInUp{
  0%{opacity:0;transform:translateY(8px) scale(.98);}
  100%{opacity:1;transform:translateY(0) scale(1);}
}

.hud-top-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  justify-content:space-between;
}
.hud-col{
  flex:1 1 220px;
  min-width:0;
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* reusable panel block inside hud */
.section-block-inline{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem .6rem .6rem;
  display:flex;
  flex-direction:column;
  gap:.6rem;
  box-shadow:0 15px 30px rgba(0,0,0,.15);
  transition:background .3s,border-color .3s,box-shadow .3s;
}

/* small caps label */
.label-sm{
  font-size:.6rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}

/* text fields */
.text-input{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.5rem .6rem;
  min-width:5rem;
  font-weight:600;
  width:100%;
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.text-input:focus{
  outline:2px solid var(--border-soft);
  box-shadow:0 0 8px var(--glow-current);
}

/* row of status + cooldown + etc */
.tiny-row{
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  gap:.6rem .75rem;
  font-size:.7rem;
}

/* status chip */
.status-chip{
  border-radius:.5rem;
  padding:.5rem .6rem;
  text-align:center;
  font-size:.7rem;
  font-weight:700;
  line-height:1.2;
  border:1px solid;
  cursor:pointer;
  min-width:5.5rem;
  user-select:none;
  transition:box-shadow .2s;
}
.status-active{
  color:var(--lime);
  border-color:var(--lime);
  background:rgba(44,255,44,.08);
  box-shadow:0 0 12px rgba(44,255,44,.35);
}
.status-cooldown{
  color:var(--red);
  border-color:var(--red);
  background:rgba(255,44,44,.08);
  box-shadow:0 0 12px rgba(255,44,44,.35);
}
.status-elim{
  color:var(--off);
  border-color:var(--off);
  background:rgba(85,85,110,.12);
  box-shadow:0 0 12px rgba(85,85,110,.35);
}
.cd-info-inline{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
}
.cd-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.cd-val-box{
  min-width:2rem;
  text-align:center;
  font-size:.8rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
  color:var(--text-primary);
  transition:background .3s,border-color .3s,color .3s;
}

/* timers row */
.timer-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem 1rem;
  font-size:.7rem;
  line-height:1.3;
}
.timer-block{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.timer-label{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.timer-val{
  font-size:clamp(.8rem,.6rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  min-width:3.5rem;
  text-shadow:0 0 8px var(--glow-current);
}

/* Commander Tax */
.tax-row{
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.tax-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.tax-ctrl{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.tax-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:700;
  line-height:1;
  padding:.45rem .65rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.tax-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .6rem;
  color:var(--text-primary);
  transition:background .3s,border-color .3s,color .3s;
}

/* respawn reminder */
.respawn-draw-banner{
  background:var(--accent-warn-bg);
  border:1px solid var(--accent-warn-border);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.7rem;
  font-weight:600;
  line-height:1.3;
  color:var(--gold);
  text-shadow:0 0 8px var(--glow-current);
  animation:pulseWarn 1.5s infinite;
}

/* vitalsBlock */
.vitalsBlock .life-row{
  display:flex;
  align-items:center;
  gap:.5rem;
  flex-wrap:wrap;
}
.life-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:1rem;
  font-weight:700;
  line-height:1;
  padding:.5rem .7rem;
  min-width:2.2rem;
  text-align:center;
  color:var(--text-primary);
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.life-value{
  min-width:3rem;
  text-align:center;
  font-size:1.2rem;
  font-weight:700;
  color:var(--text-primary);
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .7rem;
  line-height:1.2;
  transition:background .3s,border-color .3s,color .3s;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
}

/* poison/rad/etc grid */
.mini-counters-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(160px,100%),1fr));
  gap:.75rem;
}

/* sub-box for each counter */
.sub-box{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
  box-shadow:0 15px 30px rgba(0,0,0,.2);
  transition:background .3s,border-color .3s,box-shadow .3s,color .3s;
}
.sub-box-label{
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  display:flex;
  align-items:center;
  gap:.4rem;
}
.sub-box-step-row{
  display:flex;
  align-items:center;
  gap:.5rem;
  flex-wrap:wrap;
}
.step-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.9rem;
  font-weight:700;
  line-height:1;
  padding:.45rem .65rem;
  min-width:2.1rem;
  text-align:center;
  color:var(--text-primary);
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.step-val{
  min-width:2.5rem;
  text-align:center;
  font-size:1rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.45rem .6rem;
  line-height:1.2;
  color:var(--text-primary);
  transition:background .3s,border-color .3s,color .3s;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
}

/* -------------------------------------------------
   END TURN BUTTON
------------------------------------------------- */
.end-turn-btn{
  background:var(--gold);
  border:none;
  border-radius:.5rem;
  padding:.9rem .9rem;
  font-size:clamp(.8rem,.5rem + .5vw,.95rem);
  font-weight:700;
  color:#000;
  text-align:center;
  box-shadow:0 20px 30px rgba(0,0,0,.5),0 0 20px var(--glow-current);
  width:100%;
  letter-spacing:.03em;
  position:relative;
  overflow:hidden;
}
.end-turn-btn::after{
  content:"";
  position:absolute;
  left:-20%;
  top:0;
  height:200%;
  width:40%;
  background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.6) 0%,rgba(255,255,255,0) 70%);
  transform:translateX(-100%) rotate(15deg);
  animation:shine 2.2s infinite;
}
@keyframes shine{
  0%{transform:translateX(-140%) rotate(15deg);}
  40%{transform:translateX(180%) rotate(15deg);}
  100%{transform:translateX(180%) rotate(15deg);}
}

/* -------------------------------------------------
   TOOLS ACCORDION
------------------------------------------------- */
.tools-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  display:flex;
  flex-direction:column;
  box-shadow:var(--shadow-card);
  transition:border-color .25s, box-shadow .25s, background .25s;
}
.tools-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
  gap:.5rem;
  padding:.75rem;
  cursor:pointer;
  user-select:none;
}
.tools-head-left{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.tools-title{
  font-size:.8rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.tools-hint{
  font-size:.7rem;
  font-weight:500;
  color:var(--text-dim);
  line-height:1.3;
}
.tools-chevron{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
  transition:transform .2s;
}
/* slide body */
.tools-body-wrapper{
  max-height:0;
  overflow:hidden;
  border-top:1px solid var(--border-soft);
  transition:max-height .25s ease;
}
.tools-body{
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
  display:flex;
  flex-direction:column;
  gap:1rem;
  padding:.75rem;
  background:var(--bg-panel);
}

/* individual tool block */
.tool-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.6rem;
  box-shadow:0 15px 30px rgba(0,0,0,.2);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.tool-block-label{
  font-size:.65rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}

/* lookup rows */
.lookup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  align-items:flex-end;
}
.lookup-col{
  flex:1;
  min-width:8rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.lookup-input{
  width:100%;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.5rem .6rem;
  font-weight:600;
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.lookup-input:focus{
  outline:2px solid var(--border-soft);
  box-shadow:0 0 8px var(--glow-current);
}
.lookup-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
  min-width:5rem;
  box-shadow:0 10px 20px rgba(0,0,0,.3);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}

/* mini viewer row */
.mini-viewer-block{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  font-size:.7rem;
  line-height:1.3;
  color:var(--text-primary);
}
.viewer-textbox{
  flex:2;
  min-width:10rem;
  white-space:pre-line;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem .6rem;
  font-size:.7rem;
  line-height:1.3;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.viewer-imgbox{
  flex:1;
  min-width:6rem;
  max-width:140px;
  border-radius:.5rem;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  overflow:hidden;
  align-self:flex-start;
  display:none;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,box-shadow .3s;
}
.viewer-imgbox img{
  width:100%;
  height:auto;
  display:block;
}

/* randomizers */
.rng-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.rng-btn{
  flex:1;
  min-width:4rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
  padding:.6rem .75rem;
  text-align:center;
  box-shadow:0 10px 20px rgba(0,0,0,.3);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.rng-output{
  font-size:.8rem;
  font-weight:600;
  min-height:1em;
  line-height:1.2;
  color:var(--gold);
  word-break:break-word;
  text-shadow:0 0 8px var(--glow-current);
}

/* theme backup select */
.theme-select{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:100%;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}

/* textarea notes */
.notes-area{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem .6rem;
  width:100%;
  min-height:3rem;
  resize:vertical;
  font-size:.75rem;
  line-height:1.3;
  color:var(--text-primary);
  font-weight:400;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.notes-area:focus{
  outline:2px solid var(--border-soft);
  box-shadow:0 0 8px var(--glow-current),0 10px 20px rgba(0,0,0,.4);
}

/* -------------------------------------------------
   OTHER PLAYERS ACCORDION
------------------------------------------------- */
.players-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  display:flex;
  flex-direction:column;
  box-shadow:var(--shadow-card);
  transition:border-color .25s, box-shadow .25s, background .25s;
}
.players-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
  gap:.5rem;
  padding:.75rem;
  cursor:pointer;
  user-select:none;
}
.players-head-left{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.players-title{
  font-size:.8rem;
  font-weight:700;
  color:var(--text-primary);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.players-hint{
  font-size:.7rem;
  font-weight:500;
  color:var(--text-dim);
  line-height:1.3;
}
.players-chevron{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
  transition:transform .2s;
}
/* sliding body */
.players-body-wrapper{
  max-height:0;
  overflow:hidden;
  border-top:1px solid var(--border-soft);
  transition:max-height .25s ease;
}
.players-body{
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
  display:flex;
  flex-direction:column;
  gap:.75rem;
  padding:.75rem;
  background:var(--bg-panel);
}

/* each "other player" block */
.other-player-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  overflow:hidden;
  box-shadow:0 15px 30px rgba(0,0,0,.2);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.other-top-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  cursor:pointer;
  padding:.75rem .75rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
  user-select:none;
}
.other-top-left{
  display:flex;
  flex-direction:column;
  line-height:1.3;
  gap:.25rem;
}
.other-top-name{
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-shadow:0 0 8px var(--glow-current);
}
.other-top-subline{
  font-size:.7rem;
  color:var(--text-dim);
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:center;
}
.other-chevron{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
  transition:transform .2s;
}

/* inner body for each other player (slide) */
.other-body-wrapper{
  max-height:0;
  overflow:hidden;
  border-top:1px solid var(--border-soft);
  transition:max-height .25s ease;
  background:var(--bg-panel);
}
.other-body{
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
  display:flex;
  flex-direction:column;
  gap:.75rem;
  padding:.75rem;
}

/* inline rows inside each other-player-body */
.inline-row-wrap{
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  gap:.75rem;
  font-size:.7rem;
}
.inline-col{
  display:flex;
  flex-direction:column;
  gap:.4rem;
  min-width:min(160px,100%);
  flex:1 1 160px;
}
.inline-col-label{
  font-size:.6rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.inline-life-row{
  display:flex;
  align-items:center;
  gap:.5rem;
  flex-wrap:wrap;
}
.inline-life-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .6rem;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}

/* small stepper in other players */
.player-stepper-label{
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
}
.player-stepper-row{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem;
  align-items:center;
}

/* commander damage grid */
.cdmg-wrap{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.cdmg-head{
  font-size:.6rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.cdmg-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(140px,100%),1fr));
  gap:.5rem .75rem;
}
.cdmg-cell{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  gap:.4rem;
  font-size:.7rem;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.cdmg-cell-label{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.2;
}
.cdmg-input-row input{
  width:3rem;
  text-align:center;
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.4rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
  box-shadow:0 10px 20px rgba(0,0,0,.25);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.cdmg-input-row input:focus{
  outline:2px solid var(--border-soft);
  box-shadow:0 0 8px var(--glow-current),0 10px 20px rgba(0,0,0,.4);
}

/* -------------------------------------------------
   SLIDE-UP RULES DRAWER (sticky footer trigger)
------------------------------------------------- */
.rules-trigger-bar{
  position:sticky;
  bottom:0;
  left:0;
  right:0;
  background:var(--tool-bg);
  border-top:1px solid var(--tool-border);
  font-size:.7rem;
  line-height:1.2;
  padding:.6rem .75rem calc(env(safe-area-inset-bottom,0px) + .6rem);
  display:flex;
  justify-content:center;
  align-items:center;
  cursor:pointer;
  user-select:none;
  box-shadow:0 -20px 40px rgba(0,0,0,.4);
  z-index:800;
  color:var(--gold);
  font-weight:700;
  letter-spacing:.05em;
  text-transform:uppercase;
  text-shadow:0 0 8px var(--glow-current);
}
.rules-trigger-bar span{
  font-size:.7rem;
  color:var(--text-dim);
  font-weight:500;
  margin-left:.5rem;
  text-transform:none;
  text-shadow:none;
  color:var(--text-dim);
}

/* fullscreen dim overlay behind rules drawer */
.rules-overlay-dim{
  position:fixed;
  inset:0;
  background:var(--overlay-bg);
  display:none;
  z-index:9998;
  opacity:0;
  transition:opacity .2s ease;
}

/* the sheet itself */
.rules-drawer{
  position:fixed;
  left:0;
  right:0;
  bottom:0;
  max-height:70vh;
  background:var(--tool-bg);
  border-top:2px solid var(--tool-border);
  border-radius:1rem 1rem 0 0;
  box-shadow:0 -40px 80px rgba(0,0,0,.9),
             0 0 40px var(--glow-current) inset;
  padding:1rem .75rem calc(env(safe-area-inset-bottom,0px) + 1rem);
  font-size:.7rem;
  line-height:1.4;
  color:var(--text-primary);
  font-weight:400;
  display:flex;
  flex-direction:column;
  gap:.75rem;
  transform:translateY(100%);
  opacity:0;
  z-index:9999;
  transition:transform .25s ease, opacity .25s ease,
             background .3s,border-color .3s,box-shadow .3s,color .3s;
}
.rules-drawer-header{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  flex-wrap:wrap;
  gap:.5rem;
}
.rules-drawer-title{
  font-size:.75rem;
  font-weight:700;
  color:var(--gold);
  letter-spacing:.05em;
  text-transform:uppercase;
  text-shadow:0 0 10px var(--glow-current);
}
.rules-close-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.45rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  line-height:1;
  box-shadow:0 10px 20px rgba(0,0,0,.45);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.rules-scroll{
  flex:1;
  overflow-y:auto;
  white-space:pre-line;
  border:1px solid var(--tool-border);
  border-radius:.5rem;
  background:var(--bg-panel);
  padding:.75rem;
  font-size:.7rem;
  line-height:1.4;
  box-shadow:inset 0 10px 20px rgba(0,0,0,.4),0 0 20px var(--glow-current);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}

/* open state of drawer */
.rules-overlay-dim.show{
  display:block;
  opacity:1;
}
.rules-drawer.show{
  transform:translateY(0%);
  opacity:1;
}

/* -------------------------------------------------
   OVERLAYS (Setup, Announce, Winner)
   fancy pulse glow + gentle pop
------------------------------------------------- */
.overlay-fullscreen{
  position:fixed;
  inset:0;
  background:var(--overlay-bg);
  z-index:10000;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:1rem;
}
.setup-card,
.announce-card,
.winner-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  display:flex;
  flex-direction:column;
  gap:1rem;
  text-align:center;
  box-shadow:0 30px 60px rgba(0,0,0,.6),
             0 0 25px var(--glow-current);
  font-size:.8rem;
  line-height:1.4;
  color:var(--text-primary);
  animation:popUp .25s ease both;
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
@keyframes popUp{
  0%{opacity:0;transform:scale(.85) translateY(10px);}
  100%{opacity:1;transform:scale(1) translateY(0);}
}
.setup-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
  text-shadow:0 0 10px var(--glow-current);
}
.setup-sub{
  font-size:.7rem;
  color:var(--text-dim);
  line-height:1.4;
}
.setup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  justify-content:center;
}
.setup-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
  box-shadow:0 15px 30px rgba(0,0,0,.45);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.setup-small{
  display:flex;
  flex-direction:column;
  gap:.5rem;
  align-items:center;
  width:100%;
}
.label-block{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
  text-align:center;
  font-weight:600;
}
.setup-number-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:5rem;
  text-align:center;
  box-shadow:0 10px 20px rgba(0,0,0,.4);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.setup-number-input:focus{
  outline:2px solid var(--border-soft);
  box-shadow:0 0 8px var(--glow-current),0 10px 20px rgba(0,0,0,.6);
}
.setup-go{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  box-shadow:0 15px 30px rgba(0,0,0,.45);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}
.helper-row{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.3;
  text-align:center;
}

/* announce specific tweaks */
.announce-card{
  border-color:var(--gold);
  border-radius:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.5),0 40px 80px rgba(0,0,0,.9);
}
.announce-strong{
  color:var(--gold);
  font-weight:700;
  font-size:.9rem;
  line-height:1.3;
  text-shadow:0 0 12px var(--glow-current);
}
.cooldown-ack-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
  width:100%;
  box-shadow:0 15px 30px rgba(0,0,0,.6);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}

/* winner card */
.winner-card{
  border-color:var(--gold);
  border-radius:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.6),0 40px 80px rgba(0,0,0,.9);
}
.winner-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--gold);
  line-height:1.3;
  word-break:break-word;
  text-shadow:0 0 15px var(--glow-current);
}
.winner-line{
  font-size:.8rem;
  font-weight:500;
  color:var(--text-primary);
  line-height:1.4;
}
.overlay-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
  box-shadow:0 15px 30px rgba(0,0,0,.6);
  transition:background .3s,border-color .3s,color .3s,box-shadow .3s;
}

/* we keep this hidden element for later if needed */
.winner-mini-banner{
  display:none;
  border:1px solid var(--gold);
  color:var(--gold);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1.4;
  word-break:break-word;
}

/* -------------------------------------------------
   MEDIA: desktop polish
------------------------------------------------- */
@media(min-width:600px){
  :root{
    --sheet-max:520px;
  }
  .app-header{
    border-radius:0 0 .75rem .75rem;
    margin:0 auto;
    max-width:var(--sheet-max);
    box-shadow:0 20px 40px rgba(0,0,0,.4);
  }
  .turn-reminder-bar{
    border-radius:0 0 .75rem .75rem;
    margin:0 auto;
    max-width:var(--sheet-max);
    box-shadow:0 20px 40px rgba(0,0,0,.4);
  }
  .content-area{
    margin:0 auto;
    max-width:var(--sheet-max);
  }
  .rules-trigger-bar{
    margin:0 auto;
    max-width:var(--sheet-max);
    border-radius:.75rem .75rem 0 0;
  }
  .rules-drawer{
    left:50%;
    right:auto;
    width:var(--sheet-max);
    max-width:90vw;
    margin-left:calc(var(--sheet-max)/-2);
    border-radius:1rem 1rem 0 0;
  }
}
</style>
</head>
<body>

<div class="app-shell">

  <!-- ===== SETUP OVERLAY ===== -->
  <div id="setupOverlay" class="overlay-fullscreen" style="display:flex;">
    <!-- STEP 1: MODE -->
    <div class="setup-card" id="setupStepMode">
      <div class="setup-title">Select Mode</div>
      <div class="setup-row">
        <button class="setup-btn" data-mode="regular">
          Mode 1 — Regular
          <div class="setup-sub">Normal Commander. No cooldown.</div>
        </button>
        <button class="setup-btn" data-mode="rumble">
          Mode 2 — Rumble
          <div class="setup-sub">Cooldown / Respawn / Reigning Rumbler.</div>
        </button>
      </div>
      <div class="helper-row">You'll choose player count next.</div>
    </div>

    <!-- STEP 2: PLAYER COUNT -->
    <div class="setup-card" id="setupStepPlayers" style="display:none;">
      <div class="setup-title">How many players?</div>
      <div class="setup-row">
        <button class="setup-btn" data-fixedplayers="2">2</button>
        <button class="setup-btn" data-fixedplayers="3">3</button>
        <button class="setup-btn" data-fixedplayers="4">4</button>
      </div>
      <div class="setup-small">
        <div class="label-block">Manual Entry (2–9)</div>
        <input id="manualPlayerCount" class="setup-number-input" type="number" min="2" max="9" value="4" />
        <button id="manualStartBtn" class="setup-go">Start Game</button>
      </div>
      <div class="helper-row">Rename yourself on your first turn.</div>
    </div>
  </div>

  <!-- ===== ANNOUNCE OVERLAY ===== -->
  <div id="announceOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="announce-card">
      <div class="announce-strong" id="announceMain">Announcement</div>
      <div id="announceBody">Body text.</div>
      <button class="cooldown-ack-btn" id="announceOkBtn">OK</button>
    </div>
  </div>

  <!-- ===== WINNER OVERLAY ===== -->
  <div id="winnerOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="winner-card">
      <div class="winner-title" id="winnerTitle">REIGNING RUMBLER!</div>
      <div class="winner-line" id="winnerTimeLine">Global Time: 00m 00s</div>
      <div class="winner-line" id="winnerPlayerTimeLine">Winner Player Time: 00m 00s</div>
      <button class="overlay-btn" id="winnerCloseBtn">OK</button>
    </div>
  </div>

  <!-- ===== DIM + RULES DRAWER ===== -->
  <div id="rulesDim" class="rules-overlay-dim"></div>
  <div id="rulesDrawer" class="rules-drawer">
    <div class="rules-drawer-header">
      <div class="rules-drawer-title">Rumble Rules</div>
      <button id="rulesCloseBtn" class="rules-close-btn">Close</button>
    </div>
    <div class="rules-scroll" id="rulesScroll">
Setup:
• 100-card singleton Commander decks, normal color identity.
• Everyone starts 40 life, 0 poison.
• You can still be permanently eliminated if:
  – You take 21+ combat damage from one commander.
  – You try to draw and cannot (decked out).

Temporary Death (Cooldown):
• If your life hits 0 or less, or you get 10+ poison, or an effect says “you lose the game,”
  you go on cooldown instead of leaving.
• “Win the game” effects do nothing in this mode.
• You get a cooldown length in turns.
  – Your cooldown length = 1 + number of *other* players already cooling right now.
  – snapshot when you enter.

Cooldown Turns:
• On each of your future turns:
  1. You get a popup saying you're still cooling down.
  2. You acknowledge. You are skipped this turn.
  3. If that was your FIRST skipped turn after you entered, your "armed" flag is now TRUE. Cooldown number stays the same.
  4. Otherwise:
     - If cooldown > 0, cooldown -= 1.
     - If cooldown is now 0:
         You are READY to respawn, but not yet spawned this cycle.

Respawn Timing:
• You only actually respawn at the *start* of a future turn of yours
  in which:
  – cooldown == 0
  – and you ALREADY had at least one skip after entering cooldown.
  In other words, you can't die and instantly pop back up. You must miss at least one full turn cycle.

Respawn Effects:
• When you respawn:
  – You become active again.
  – Life = ceiling(average life of all other active players).
  – Poison = 0.
  – Commander tax resets.
  – You keep any permanents you still control on the battlefield.
  – Your first full turn back: you skip your normal draw step, but at END of that turn you draw 1.

While Cooling Down (Not Active):
• You're not an active player.
• You can't cast/attack/block/respond/activate.
• You can't be targeted as a player.
• Your board stays in play and can still be attacked/blown up.
• Your zones (hand, exile, etc.) stay.
• Triggers that would need your decisions are ignored. Your static effects just sit there.

Reigning Rumbler:
• If exactly one player is active and everyone else is cooling or eliminated,
  that player becomes the Reigning Rumbler.
• After that player completes their NEXT full turn while still the only active player,
  they win the game.

Regular Mode:
• No cooldown. 0 life / 10 poison / "you lose the game" = permanent elimination.
• Last surviving player wins.
    </div>
  </div>

  <!-- ===== TOP TURN BANNER ===== -->
  <div class="turn-reminder-bar">
    <div class="turn-reminder-main" id="turnBanner">▶ PLAYER 1'S TURN ◀</div>
    <div class="turn-reminder-extra" id="turnReminderExtra" style="display:none;"></div>
  </div>

  <!-- ===== APP HEADER ===== -->
  <div class="app-header">
    <div class="game-title">
      <div>EDH RUMBLE TRACKER</div>
      <div class="game-sub" id="modeSmallLabel">Mode —</div>
    </div>
    <div id="globalTimerBanner">Global: 0:00</div>
    <button id="themeToggleBtn" class="theme-toggle-btn">Light</button>
  </div>

  <!-- ===== MAIN CONTENT ===== -->
  <div class="content-area" id="contentArea">

    <!-- ACTIVE PLAYER HUD -->
    <div id="hudArea"></div>

    <!-- END TURN BUTTON -->
    <button class="end-turn-btn" id="endTurnBtn">End Turn →</button>

    <!-- TOOLS ACCORDION -->
    <div class="tools-card" id="toolsCard">
      <div class="tools-head" id="toolsHead">
        <div class="tools-head-left">
          <div class="tools-title">Tools & Lookups</div>
          <div class="tools-hint">Card text, Dungeon / Emblem helper, Plane / Scheme, Randomizers</div>
        </div>
        <div class="tools-chevron" id="toolsChevron">▼</div>
      </div>
      <div class="tools-body-wrapper" id="toolsWrapper">
        <div class="tools-body" id="toolsBody">

          <!-- GLOBAL CARD LOOKUP -->
          <div class="tool-block">
            <div class="tool-block-label">Card Lookup (Scryfall)</div>
            <div class="lookup-row">
              <div class="lookup-col">
                <input id="globalLookupInput" class="lookup-input" placeholder="Any card..." />
                <button id="globalLookupBtn" class="lookup-btn">Search</button>
              </div>
            </div>
            <div class="mini-viewer-block">
              <div class="viewer-textbox" id="globalViewerText"></div>
              <div class="viewer-imgbox" id="globalViewerImgBox">
                <img id="globalViewerImg" alt="card art"/>
              </div>
            </div>
          </div>

          <!-- DUNGEON / EMBLEM (ACTIVE PLAYER) -->
          <div class="tool-block" id="dungeonEmblemBlock">
            <div class="tool-block-label">Dungeon / Emblem Tracking (Active Player)</div>

            <!-- Dungeon -->
            <div class="lookup-row">
              <div class="lookup-col">
                <input id="dungeonInput" class="lookup-input" placeholder="Lookup Dungeon..." />
                <button id="dungeonBtn" class="lookup-btn">Dungeon</button>
              </div>
            </div>
            <div class="mini-viewer-block">
              <div class="viewer-textbox" id="dungeonViewerText"></div>
              <div class="viewer-imgbox" id="dungeonViewerImgBox">
                <img id="dungeonViewerImg" alt="dungeon art"/>
              </div>
            </div>

            <!-- Emblem -->
            <div class="lookup-row">
              <div class="lookup-col">
                <input id="emblemInput" class="lookup-input" placeholder="Lookup Emblem / Walker Ult..." />
                <button id="emblemBtn" class="lookup-btn">Emblem</button>
              </div>
            </div>
            <div class="mini-viewer-block">
              <div class="viewer-textbox" id="emblemViewerText"></div>
              <div class="viewer-imgbox" id="emblemViewerImgBox">
                <img id="emblemViewerImg" alt="emblem art"/>
              </div>
            </div>

            <div class="lookup-col">
              <div class="tool-block-label" style="text-transform:none;letter-spacing:0;font-size:.7rem;">
                Dungeon / Undercity / Progress
              </div>
              <textarea id="dungeonProgressArea" class="notes-area" style="min-height:4rem;"></textarea>
            </div>

            <div class="lookup-col">
              <div class="tool-block-label" style="text-transform:none;letter-spacing:0;font-size:.7rem;">
                Emblems / Globals
              </div>
              <textarea id="emblemsArea" class="notes-area" style="min-height:4rem;"></textarea>
            </div>
          </div>

          <!-- PLANE / SCHEME -->
          <div class="tool-block" id="planeSchemeBlock">
            <div class="tool-block-label">Table-Wide Effects (Planechase / Archenemy)</div>

            <!-- Plane -->
            <div class="lookup-row">
              <div class="lookup-col">
                <input id="planeInput" class="lookup-input" placeholder="Current Plane..." />
                <button id="planeBtn" class="lookup-btn">Plane</button>
              </div>
            </div>
            <div class="mini-viewer-block">
              <div class="viewer-textbox" id="planeViewerText"></div>
              <div class="viewer-imgbox" id="planeViewerImgBox">
                <img id="planeViewerImg" alt="plane art"/>
              </div>
            </div>

            <!-- Scheme -->
            <div class="lookup-row">
              <div class="lookup-col">
                <input id="schemeInput" class="lookup-input" placeholder="Current Scheme..." />
                <button id="schemeBtn" class="lookup-btn">Scheme</button>
              </div>
            </div>
            <div class="mini-viewer-block">
              <div class="viewer-textbox" id="schemeViewerText"></div>
              <div class="viewer-imgbox" id="schemeViewerImgBox">
                <img id="schemeViewerImg" alt="scheme art"/>
              </div>
            </div>
          </div>

          <!-- RANDOMIZERS + GAME CONTROL -->
          <div class="tool-block">
            <div class="tool-block-label">Randomizers</div>
            <div class="rng-row">
              <button class="rng-btn" id="flipCoinBtn">Coin Flip</button>
              <button class="rng-btn" id="rollD6Btn">d6</button>
              <button class="rng-btn" id="rollD20Btn">d20</button>
            </div>
            <div class="rng-output" id="rngOutput"></div>
          </div>

          <div class="tool-block">
            <div class="tool-block-label">Game Control</div>
            <div style="font-size:.7rem;line-height:1.3;" id="modeStatusText">Mode —</div>

            <div class="rng-row" style="gap:.5rem;">
              <button class="rng-btn" id="newGameBtn" style="min-width:6rem;">New Game</button>
              <button class="rng-btn" id="changeModeBtn" style="min-width:6rem;">Change Mode</button>
            </div>

            <div class="tool-block-label" style="text-transform:none;letter-spacing:0;font-size:.7rem;">
              Theme (backup)
            </div>
            <select id="themeSelect" class="theme-select">
              <option value="">Light</option>
              <option value="theme-dark">Dark</option>
              <option value="theme-neon">Neon</option>
            </select>
          </div>

        </div>
      </div>
    </div>

    <!-- OTHER PLAYERS ACCORDION -->
    <div class="players-card" id="playersCard">
      <div class="players-head" id="playersHead">
        <div class="players-head-left">
          <div class="players-title">Other Players</div>
          <div class="players-hint">Life / status / commander damage / politics notes</div>
        </div>
        <div class="players-chevron" id="playersChevron">▼</div>
      </div>
      <div class="players-body-wrapper" id="playersWrapper">
        <div class="players-body" id="playersBody"></div>
      </div>
    </div>

  </div> <!-- /content-area -->

  <!-- STICKY RULES TRIGGER BAR -->
  <div class="rules-trigger-bar" id="rulesTrigger">
    RUMBLE RULES
    <span>(Tap to View)</span>
  </div>

</div> <!-- /app-shell -->

<script>
/* =========================================================
   GLOBAL STATE
========================================================= */
let gameMode = null; // "regular" | "rumble"
let players = [];
let turnIndex = 0;
let turnCounter = 0;
let gameStartTime = null;

/*
Cooldown logic (the refined "armed" model):

When a player is knocked out in Rumble:
- status="cooldown"
- armed=false
- cooldownRemaining = snapshotBase (1 + othersCoolingAtDeath)

On each of THEIR turns while in cooldown:
1. Popup.
2. If(!armed):
     armed=true
   Else:
     if(cooldownRemaining>0) cooldownRemaining--
3. If(after step 2, cooldownRemaining===0 AND armed===true):
     mark them READY to respawn next time their turn STARTS.
     We'll represent "readyToRespawn" = true.
4. That skipped turn still ends immediately (they don't take actions).

After we cycle around and it's their turn AGAIN:
- If(status==="cooldown" AND readyToRespawn===true):
     Respawn now (become active, reset poison, etc)
     Give them this turn as normal active turn
     pendingEOTDraw=true, skipDrawOnThisTurn=true

So we need fields:
- armed:boolean
- readyToRespawn:boolean
*/

let reigningCandidateIndex = null;
let reigningCandidateTurnStamp = null;

let winnerLocked = false;
let renderIntervalId = null;

let showingAnnounce = false;
let pendingClearAfterAnnounce = null;

/* plane/scheme global shared state */
let currentPlaneName   = "";
let currentPlaneText   = "";
let currentPlaneImg    = "";
let currentSchemeName  = "";
let currentSchemeText  = "";
let currentSchemeImg   = "";

/* accordion open flags */
let toolsOpen   = false;
let playersOpen = false;
let otherOpen   = {}; // per non-active player row expand

/* DOM refs */
const setupOverlay         = document.getElementById("setupOverlay");
const setupStepMode        = document.getElementById("setupStepMode");
const setupStepPlayers     = document.getElementById("setupStepPlayers");
const manualPlayerCount    = document.getElementById("manualPlayerCount");
const manualStartBtn       = document.getElementById("manualStartBtn");

const announceOverlay      = document.getElementById("announceOverlay");
const announceMain         = document.getElementById("announceMain");
const announceBody         = document.getElementById("announceBody");
const announceOkBtn        = document.getElementById("announceOkBtn");

const winnerOverlay        = document.getElementById("winnerOverlay");
const winnerTitle          = document.getElementById("winnerTitle");
const winnerTimeLine       = document.getElementById("winnerTimeLine");
const winnerPlayerTimeLine = document.getElementById("winnerPlayerTimeLine");
const winnerCloseBtn       = document.getElementById("winnerCloseBtn");

const turnBanner           = document.getElementById("turnBanner");
const turnReminderExtra    = document.getElementById("turnReminderExtra");
const globalTimerBanner    = document.getElementById("globalTimerBanner");
const modeSmallLabel       = document.getElementById("modeSmallLabel");

const themeToggleBtn       = document.getElementById("themeToggleBtn");

const hudArea              = document.getElementById("hudArea");
const endTurnBtn           = document.getElementById("endTurnBtn");

const toolsHead            = document.getElementById("toolsHead");
const toolsChevron         = document.getElementById("toolsChevron");
const toolsWrapper         = document.getElementById("toolsWrapper");
const toolsBody            = document.getElementById("toolsBody");

const playersHead          = document.getElementById("playersHead");
const playersChevron       = document.getElementById("playersChevron");
const playersWrapper       = document.getElementById("playersWrapper");
const playersBody          = document.getElementById("playersBody");

const modeStatusText       = document.getElementById("modeStatusText");

const flipCoinBtn          = document.getElementById("flipCoinBtn");
const rollD6Btn            = document.getElementById("rollD6Btn");
const rollD20Btn           = document.getElementById("rollD20Btn");
const rngOutput            = document.getElementById("rngOutput");

const newGameBtn           = document.getElementById("newGameBtn");
const changeModeBtn        = document.getElementById("changeModeBtn");

const themeSelect          = document.getElementById("themeSelect");

const globalLookupInput    = document.getElementById("globalLookupInput");
const globalLookupBtn      = document.getElementById("globalLookupBtn");
const globalViewerText     = document.getElementById("globalViewerText");
const globalViewerImgBox   = document.getElementById("globalViewerImgBox");
const globalViewerImg      = document.getElementById("globalViewerImg");

const dungeonInput         = document.getElementById("dungeonInput");
const dungeonBtn           = document.getElementById("dungeonBtn");
const dungeonViewerText    = document.getElementById("dungeonViewerText");
const dungeonViewerImgBox  = document.getElementById("dungeonViewerImgBox");
const dungeonViewerImg     = document.getElementById("dungeonViewerImg");

const emblemInput          = document.getElementById("emblemInput");
const emblemBtn            = document.getElementById("emblemBtn");
const emblemViewerText     = document.getElementById("emblemViewerText");
const emblemViewerImgBox   = document.getElementById("emblemViewerImgBox");
const emblemViewerImg      = document.getElementById("emblemViewerImg");

const dungeonProgressArea  = document.getElementById("dungeonProgressArea");
const emblemsArea          = document.getElementById("emblemsArea");

const planeInput           = document.getElementById("planeInput");
const planeBtn             = document.getElementById("planeBtn");
const planeViewerText      = document.getElementById("planeViewerText");
const planeViewerImgBox    = document.getElementById("planeViewerImgBox");
const planeViewerImg       = document.getElementById("planeViewerImg");

const schemeInput          = document.getElementById("schemeInput");
const schemeBtn            = document.getElementById("schemeBtn");
const schemeViewerText     = document.getElementById("schemeViewerText");
const schemeViewerImgBox   = document.getElementById("schemeViewerImgBox");
const schemeViewerImg      = document.getElementById("schemeViewerImg");

const rulesTrigger         = document.getElementById("rulesTrigger");
const rulesDrawer          = document.getElementById("rulesDrawer");
const rulesDim             = document.getElementById("rulesDim");
const rulesCloseBtn        = document.getElementById("rulesCloseBtn");

/* =========================================================
   UTILS
========================================================= */
function msToClock(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins + ":" + (secs<10?("0"+secs):secs);
}
function formatDurationMs(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins+"m "+secs+"s";
}
function getGameElapsedMs(){
  if(!gameStartTime) return 0;
  return Date.now()-gameStartTime;
}
function getAvgActiveLifeCeil(excludeIndex){
  let sum=0;
  let ct=0;
  players.forEach((pl,i)=>{
    if(i===excludeIndex) return;
    if(pl.status==="active"){
      sum+=pl.life;
      ct++;
    }
  });
  if(ct===0){ return 1; }
  return Math.ceil(sum/ct);
}
function getSeatColor(i){
  const cols=["var(--gold)","var(--cyan)","var(--magenta)","var(--lime)"];
  return cols[i % cols.length];
}
function rotateClockwiseIndex(i){
  if(players.length===0) return i;
  return (i+1)%players.length;
}

/* =========================================================
   PLAYER MODEL
========================================================= */
function makePlayer(defaultName){
  return {
    name: defaultName,

    status:"active",          // "active"|"cooldown"|"eliminated"
    cooldownRemaining:0,
    armed:false,
    readyToRespawn:false,

    life:40,
    poison:0,
    radiation:0,
    energy:0,
    experience:0,
    storm:0,

    notesText:"",

    commanderTaxSteps:0,

    commanderDamage:[], // victim.commanderDamage[srcIdx] = dmg

    totalActiveMs:0,
    turnStartMs:null,
    isTiming:false,

    pendingEOTDraw:false,
    skipDrawThisTurn:false, // only true on the first respawn turn

    // dungeon / emblem tracking for THIS player
    dungeonLookupName:"",
    dungeonPreviewText:"",
    dungeonPreviewImg:"",
    dungeonProgress:"",

    emblemLookupName:"",
    emblemPreviewText:"",
    emblemPreviewImg:"",
    emblemsText:""
  };
}
function syncCommanderDamageArrays(){
  players.forEach(p=>{
    while(p.commanderDamage.length < players.length){
      p.commanderDamage.push(0);
    }
    if(p.commanderDamage.length > players.length){
      p.commanderDamage.length = players.length;
    }
  });
}

/* =========================================================
   TIMING
========================================================= */
function startTimingPlayer(i){
  const p=players[i];
  if(!p || p.status!=="active") return;
  p.isTiming=true;
  p.turnStartMs=Date.now();
}
function stopTimingPlayer(i){
  const p=players[i];
  if(!p || !p.isTiming) return;
  const now=Date.now();
  const diff = now-(p.turnStartMs||now);
  p.totalActiveMs += diff;
  p.turnStartMs=null;
  p.isTiming=false;
}
function getPlayerTurnMs(p){
  if(p.isTiming && p.turnStartMs!=null){
    return Date.now()-p.turnStartMs;
  }
  return 0;
}
function getPlayerTotalMs(p){
  return p.totalActiveMs+getPlayerTurnMs(p);
}
function getActivePlayers(){
  const arr=[];
  players.forEach((pl,i)=>{
    if(pl.status==="active"){
      arr.push(i);
    }
  });
  return arr;
}

/* =========================================================
   ANNOUNCEMENTS
========================================================= */
function showAnnounce(mainTxt, bodyTxt, cb){
  showingAnnounce=true;
  announceMain.textContent = mainTxt;
  announceBody.textContent = bodyTxt;
  announceOverlay.style.display="flex";

  announceOkBtn.onclick = ()=>{
    announceOverlay.style.display="none";
    showingAnnounce=false;
    if(pendingClearAfterAnnounce!==null){
      const pp=players[pendingClearAfterAnnounce];
      if(pp){
        pp.pendingEOTDraw=false;
      }
      pendingClearAfterAnnounce=null;
    }
    if(typeof cb==="function"){
      cb();
    }
  };
}

/* end-of-turn draw reminder */
function runEndOfTurnDrawIfNeeded(idx){
  const p=players[idx];
  if(!p) return;
  if(p.pendingEOTDraw){
    pendingClearAfterAnnounce = idx;
    showAnnounce(
      (p.name||("Player "+(idx+1)))+" draw reminder",
      "Draw 1 card now. This is your respawn recovery draw because you skipped your draw step this turn.",
      function(){}
    );
  }
}

/* =========================================================
   ELIM / COOLDOWN / RESPAWN
========================================================= */
function permanentlyEliminate(i){
  const p=players[i];
  stopTimingPlayer(i);
  p.status="eliminated";
  p.cooldownRemaining=0;
  p.armed=false;
  p.readyToRespawn=false;
  p.pendingEOTDraw=false;
  p.skipDrawThisTurn=false;

  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

function checkCommanderDamageElim(victimIdx){
  const p=players[victimIdx];
  for(let src=0; src<p.commanderDamage.length; src++){
    if(p.commanderDamage[src] >= 21){
      permanentlyEliminate(victimIdx);
      break;
    }
  }
}

/* lethal events -> goes to cooldown in rumble, or elim in regular */
function knockOutToCooldown(i){
  const p=players[i];

  if(gameMode==="regular"){
    permanentlyEliminate(i);
    showAnnounce(
      (p.name||("Player "+(i+1)))+" eliminated",
      "Regular Mode: 0 life / 10 poison / lose-the-game is permanent.",
      null
    );
    return;
  }

  if(p.status==="eliminated") return;
  if(p.status==="cooldown") return;

  stopTimingPlayer(i);

  // snapshot how many OTHER players are already cooling
  let othersCooling=0;
  players.forEach((q,qi)=>{
    if(qi!==i && q.status==="cooldown"){
      othersCooling++;
    }
  });

  p.status="cooldown";
  p.cooldownRemaining=1+othersCooling;
  p.armed=false;
  p.readyToRespawn=false;
  p.pendingEOTDraw=false;
  p.skipDrawThisTurn=false;

  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }

  showAnnounce(
    (p.name||("Player "+(i+1)))+" knocked out",
    "Entered cooldown. Will miss a turn, then count down.\nThey'll respawn when cooldown hits 0 on a future turn of theirs.",
    null
  );
}

/* respawn now on start of turn IF readyToRespawn===true && cooldownRemaining===0 */
function respawnPlayer(i){
  const p=players[i];
  if(p.status!=="cooldown") return;
  if(!p.readyToRespawn || p.cooldownRemaining!==0) return;

  const newLife=getAvgActiveLifeCeil(i);
  p.status="active";
  p.poison=0;
  p.life=newLife;
  p.commanderTaxSteps=0;

  p.readyToRespawn=false;
  p.armed=true; // irrelevant but keep consistent
  p.skipDrawThisTurn=true; // skip normal draw step this turn
  p.pendingEOTDraw=true;   // then draw 1 at end of turn

  showAnnounce(
    (p.name||("Player "+(i+1)))+" respawned",
    "Life "+newLife+" (avg rounded up), poison=0, commander tax reset.\nThis turn: skip normal draw step; draw 1 at END of turn.",
    null
  );
}

/* lethal check triggers */
function lethalCheck(i,source){
  const p=players[i];
  if(!p) return;
  if(source==="life" && p.life<=0){
    knockOutToCooldown(i);
    return;
  }
  if(source==="poison" && p.poison>=10){
    knockOutToCooldown(i);
    return;
  }
}

/* manual admin tap status chip */
function cycleStatusAdmin(i){
  const p=players[i];
  if(gameMode==="rumble"){
    if(p.status==="active"){
      knockOutToCooldown(i);
    }else if(p.status==="cooldown"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction.",
        null
      );
    }else{ // eliminated -> active
      p.status="active";
      p.cooldownRemaining=0;
      p.armed=true;
      p.readyToRespawn=false;
      p.pendingEOTDraw=false;
      p.skipDrawThisTurn=false;
    }
  }else{
    if(p.status==="active"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction.",
        null
      );
    }else{
      p.status="active";
      p.cooldownRemaining=0;
      p.armed=true;
      p.readyToRespawn=false;
      p.pendingEOTDraw=false;
      p.skipDrawThisTurn=false;
    }
  }
  renderAll();
}

/* =========================================================
   REIGNING RUMBLER / WIN LOGIC
========================================================= */
function updateReigningCandidateOnTurnEnd(){
  if(gameMode!=="rumble" || winnerLocked) return;
  const actives=getActivePlayers();
  if(actives.length===1){
    const onlyIdx=actives[0];
    if(reigningCandidateIndex!==onlyIdx){
      reigningCandidateIndex=onlyIdx;
      reigningCandidateTurnStamp=turnCounter;
      showAnnounce(
        (players[onlyIdx].name||("Player "+(onlyIdx+1)))+" is now REIGNING RUMBLER",
        "If they remain the only active player through their next full turn, they win.",
        null
      );
    }
  }else{
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}
function checkReigningWin(){
  if(gameMode!=="rumble" || winnerLocked) return false;
  if(reigningCandidateIndex===null) return false;
  const actives=getActivePlayers();
  if(actives.length!==1) return false;
  const onlyIdx=actives[0];
  if(onlyIdx!==reigningCandidateIndex) return false;

  if(turnCounter>(reigningCandidateTurnStamp+1)){
    lockWinner(onlyIdx,true);
    return true;
  }
  return false;
}
function checkForWinRegular(){
  if(gameMode!=="regular" || winnerLocked) return false;
  const alive = players.filter(p=>p.status!=="eliminated");
  if(alive.length===1){
    const idx = players.indexOf(alive[0]);
    lockWinner(idx,false);
    return true;
  }
  return false;
}
function lockWinner(idx,isRumble){
  winnerLocked=true;
  const p=players[idx];
  const winnerName = p.name || ("Player "+(idx+1));
  const totalMs = Date.now()-gameStartTime;
  const activeMs = getPlayerTotalMs(p);

  if(isRumble){
    winnerTitle.textContent = winnerName.toUpperCase()+" — REIGNING RUMBLER!";
  } else {
    winnerTitle.textContent = winnerName+" wins the game!";
  }
  winnerTimeLine.textContent =
    "Global Time: "+formatDurationMs(totalMs);
  winnerPlayerTimeLine.textContent =
    "Winner Player Time: "+formatDurationMs(activeMs);

  winnerOverlay.style.display="flex";
}

/* =========================================================
   TURN FLOW
========================================================= */
/*
passTurn() is called by the active player.

Process:
1. stop timing them
2. EOT draw reminder if pending
3. turnCounter++ (a real turn finished)
4. check/crown Reigning Rumbler, check wins
5. move to next seat, resolve that seat

resolve next seat:
- eliminated -> skip forward (no increment)
- cooldown:
   a) if p.readyToRespawn && p.cooldownRemaining===0:
        -> respawnPlayer(i), startTimingPlayer(i) and we STOP
        (this is an actual turn, NOT skipped)
   b) else:
        show popup: "cooling down"
        if(!p.armed) p.armed=true else if(p.cooldownRemaining>0) p.cooldownRemaining--
        if(p.cooldownRemaining===0 && p.armed===true) p.readyToRespawn=true
        skip them -> move on (no turnCounter++)
- active:
    startTimingPlayer(i) and STOP

We loop until we land on someone who actually takes a turn (active or newly respawned),
or we wrap crazy many times.
*/

function passTurn(){
  if(winnerLocked){
    renderAll();
    return;
  }

  // current player finishing
  stopTimingPlayer(turnIndex);
  runEndOfTurnDrawIfNeeded(turnIndex);

  // full real turn ended
  turnCounter += 1;

  // update reigning-candidate stuff
  if(gameMode==="rumble"){
    updateReigningCandidateOnTurnEnd();
  }

  // check wins
  if(gameMode==="regular" && checkForWinRegular()){
    renderAll();
    return;
  }
  if(checkReigningWin()){
    renderAll();
    return;
  }

  // next seat
  turnIndex = rotateClockwiseIndex(turnIndex);
  advanceTurnCore();
}

/* Advance forward until we find who actually acts this turn */
function advanceTurnCore(){
  let guard=0;
  while(guard<50){
    guard++;

    const p=players[turnIndex];
    if(!p){
      turnIndex=rotateClockwiseIndex(turnIndex);
      continue;
    }

    if(p.status==="eliminated"){
      turnIndex=rotateClockwiseIndex(turnIndex);
      continue;
    }

    if(p.status==="cooldown"){
      // check if they're fully ready to respawn NOW
      if(p.readyToRespawn && p.cooldownRemaining===0){
        respawnPlayer(turnIndex);
        if(!winnerLocked){
          startTimingPlayer(turnIndex);
        }
        renderAll();
        return;
      }

      // else they are cooling this turn (skip turn)
      handleCooldownTurn(turnIndex);
      // after handling, move to next seat
      turnIndex=rotateClockwiseIndex(turnIndex);
      continue;
    }

    // ACTIVE seat -> this is who takes the turn
    if(!winnerLocked){
      startTimingPlayer(turnIndex);
    }
    renderAll();
    return;
  }
  console.warn("advanceTurnCore guard stop");
  renderAll();
}

/* Player at i gets "you are cooling down, you skip" popup and logic updates */
function handleCooldownTurn(i){
  const p=players[i];
  if(!p || p.status!=="cooldown") return;

  const mainTxt = (p.name||("Player "+(i+1)))+" is cooling down";
  let bodyTxt = "You are skipped this turn.";

  showAnnounce(mainTxt, bodyTxt, function afterAck(){
    // after ack:
    if(!p.armed){
      // first skip after entering cooldown
      p.armed=true;
    }else{
      // already armed: burn down cooldownRemaining if >0
      if(p.cooldownRemaining>0){
        p.cooldownRemaining--;
      }
    }

    // If cooldownRemaining is now 0 AND armed true => mark readyToRespawn
    if(p.cooldownRemaining===0 && p.armed){
      p.readyToRespawn=true;
    }

    renderAll();
  });
}

/* =========================================================
   SCRYFALL LOOKUPS
========================================================= */
function pickCardImage(card){
  if(card?.image_uris?.normal) return card.image_uris.normal;
  if(Array.isArray(card?.card_faces)){
    for(const face of card.card_faces){
      if(face?.image_uris?.normal){
        return face.image_uris.normal;
      }
    }
  }
  return "";
}
async function scryfallFetch(url){
  try{
    const resp = await fetch(url);
    if(!resp.ok) return null;
    return await resp.json();
  }catch(e){
    return null;
  }
}
async function smartContextSearch(query, context){
  if(!query || !query.trim()) return {error:"Enter a name first."};
  const base="https://api.scryfall.com";

  let primaryURL;
  let cardFilter = null;

  if(context==="dungeon"){
    primaryURL = base+"/cards/search?q=type%3ADungeon+"+encodeURIComponent(query);
    cardFilter = c=> (c.layout==="dungeon" || /Dungeon/i.test(c.type_line||""));
  }else if(context==="emblem"){
    primaryURL = base+"/cards/search?q=layout%3Aemblem+"+encodeURIComponent(query);
    cardFilter = c=> (c.layout==="emblem");
  }else if(context==="plane"){
    primaryURL = base+"/cards/search?q=(type%3APlane+OR+type%3APhenomenon)+"+encodeURIComponent(query);
    cardFilter = c=> (/Plane|Phenomenon/i.test(c.type_line||""));
  }else if(context==="scheme"){
    primaryURL = base+"/cards/search?q=type%3AScheme+"+encodeURIComponent(query);
    cardFilter = c=> (/Scheme/i.test(c.type_line||""));
  }else{
    primaryURL = base+"/cards/named?fuzzy="+encodeURIComponent(query);
  }

  // first attempt
  let data = await scryfallFetch(primaryURL);

  let card = null;
  if(data && Array.isArray(data.data) && data.data.length){
    if(cardFilter){
      const filtered = data.data.find(cardFilter);
      if(filtered) card = filtered;
    }
    if(!card) card = data.data[0];
  }else if(data && !Array.isArray(data.data) && !data.object?.includes("error")){
    card = data;
  }

  if((!card || (cardFilter && !cardFilter(card))) && context!=="global"){
    const fallbackURL = base+"/cards/named?fuzzy="+encodeURIComponent(query);
    let data2 = await scryfallFetch(fallbackURL);
    if(data2 && !data2.object?.includes("error")){
      if(!cardFilter || cardFilter(data2)){
        card = data2;
      }
    }
  }

  if(!card || card.object==="error"){
    return {error:"Not found / offline."};
  }

  return {
    name:card.name||query.trim(),
    type:card.type_line||"",
    text:card.oracle_text||"(No rules text)",
    image:pickCardImage(card)
  };
}

/* each button */
async function runGlobalLookup(){
  const q=globalLookupInput.value||"";
  const res=await smartContextSearch(q,"global");
  if(res.error){
    globalViewerText.textContent=res.error;
    globalViewerImgBox.style.display="none";
    globalViewerImg.removeAttribute("src");
    return;
  }
  globalViewerText.textContent=
    (res.type?res.type+"\n":"")+res.text;
  if(res.image){
    globalViewerImg.src=res.image;
    globalViewerImgBox.style.display="block";
  }else{
    globalViewerImgBox.style.display="none";
    globalViewerImg.removeAttribute("src");
  }
}
async function runDungeonLookup(){
  const p=players[turnIndex];
  if(!p)return;
  const q=dungeonInput.value||"";
  const res=await smartContextSearch(q,"dungeon");
  if(res.error){
    p.dungeonPreviewText=res.error;
    p.dungeonPreviewImg="";
  }else{
    p.dungeonPreviewText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    p.dungeonPreviewImg  = res.image||"";
    if(p.dungeonProgress.toLowerCase().indexOf(res.name.toLowerCase())===-1){
      p.dungeonProgress += (p.dungeonProgress? "\n":"")+"Dungeon: "+res.name;
    }
  }
  renderAll();
}
async function runEmblemLookup(){
  const p=players[turnIndex];
  if(!p)return;
  const q=emblemInput.value||"";
  const res=await smartContextSearch(q,"emblem");
  if(res.error){
    p.emblemPreviewText=res.error;
    p.emblemPreviewImg="";
  }else{
    p.emblemPreviewText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    p.emblemPreviewImg  = res.image||"";
    if(p.emblemsText.toLowerCase().indexOf(res.name.toLowerCase())===-1){
      p.emblemsText += (p.emblemsText? "\n":"")+"Emblem: "+res.name+" — "+res.text;
    }
  }
  renderAll();
}
async function runPlaneLookup(){
  const q=planeInput.value||"";
  const res=await smartContextSearch(q,"plane");
  if(res.error){
    currentPlaneText=res.error;
    currentPlaneImg="";
  }else{
    currentPlaneText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    currentPlaneImg  = res.image||"";
    currentPlaneName = res.name;
  }
  renderAll();
}
async function runSchemeLookup(){
  const q=schemeInput.value||"";
  const res=await smartContextSearch(q,"scheme");
  if(res.error){
    currentSchemeText=res.error;
    currentSchemeImg="";
  }else{
    currentSchemeText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    currentSchemeImg  = res.image||"";
    currentSchemeName = res.name;
  }
  renderAll();
}

/* =========================================================
   RENDER HELPERS
========================================================= */
function renderGlobalTimerBanner(){
  globalTimerBanner.textContent = "Global: "+msToClock(getGameElapsedMs());
}
function renderTimersOnly(){
  renderGlobalTimerBanner();

  const p=players[turnIndex];
  if(p){
    const turnVal = document.querySelector(".timer-turn-val");
    const plVal   = document.querySelector(".timer-player-val");
    if(turnVal) turnVal.textContent = msToClock(getPlayerTurnMs(p));
    if(plVal)   plVal.textContent   = msToClock(getPlayerTotalMs(p));
  }

  // update others' total time
  players.forEach((pl,i)=>{
    if(i===turnIndex) return;
    const node=document.querySelector(`.player-time-val[data-idx="${i}"]`);
    if(node){
      node.textContent = "Time "+msToClock(getPlayerTotalMs(pl));
    }
  });
}

/* create sub-stepper for active main HUD right-col */
function makeSubStepper(label,val,onSet){
  const box=document.createElement("div");
  box.className="sub-box";

  const l=document.createElement("div");
  l.className="sub-box-label";
  l.textContent=label;

  const row=document.createElement("div");
  row.className="sub-box-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1; if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1; if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);

  box.appendChild(l);
  box.appendChild(row);
  return box;
}

/* little stepper used in "other players" lists */
function smallStepper(labelText,val,onSet){
  const container=document.createElement("div");
  container.style.display="flex";
  container.style.flexDirection="column";
  container.style.gap=".4rem";
  container.style.minWidth="6rem";

  const lab=document.createElement("div");
  lab.className="player-stepper-label";
  lab.textContent=labelText;

  const row=document.createElement("div");
  row.className="player-stepper-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1; if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1; if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);
  container.appendChild(lab);
  container.appendChild(row);
  return container;
}

/* HUD (active player card) */
function renderHUD(){
  hudArea.innerHTML="";
  const p=players[turnIndex];
  if(!p)return;

  // turn banner side note (skip draw etc)
  if(p.skipDrawThisTurn){
    turnReminderExtra.style.display="block";
    turnReminderExtra.textContent="Skip draw step; draw 1 at END of this turn.";
  }else{
    turnReminderExtra.style.display="none";
    turnReminderExtra.textContent="";
  }

  const card=document.createElement("div");
  card.className="hud-card glow-border";

  // seat color border glow
  const seatColor=getSeatColor(turnIndex);
  card.style.borderColor=seatColor;
  card.style.boxShadow=
    `0 0 18px ${seatColor},0 30px 60px rgba(0,0,0,.5)`;

  const topRow=document.createElement("div");
  topRow.className="hud-top-row";

  /* LEFT COL (name/status/time/tax/etc) */
  const leftCol=document.createElement("div");
  leftCol.className="hud-col";

  const nameBlock=document.createElement("div");
  nameBlock.className="section-block-inline";

  const nmLabel=document.createElement("div");
  nmLabel.className="label-sm";
  nmLabel.textContent="Your Name";

  const nmInput=document.createElement("input");
  nmInput.className="text-input";
  nmInput.value=p.name;
  nmInput.addEventListener("input",e=>{
    p.name=e.target.value;
  });
  nmInput.addEventListener("blur",()=>{ renderAll(); });
  nmInput.addEventListener("keydown",ev=>{
    if(ev.key==="Enter"){
      ev.preventDefault();
      nmInput.blur();
    }
  });

  // status chip row
  const statusWrap=document.createElement("div");
  statusWrap.className="tiny-row";

  const stChip=document.createElement("div");
  stChip.className="status-chip "+
    (p.status==="active"?"status-active":
     p.status==="cooldown"?"status-cooldown":
     "status-elim");
  stChip.textContent=
    p.status==="active"?"ACTIVE":
    p.status==="cooldown"?"COOLDOWN":
    "ELIMINATED";
  stChip.title=(gameMode==="rumble")
    ?"Tap: Active ↔ Cooldown ↔ Eliminated"
    :"Tap: Active ↔ Eliminated";
  stChip.addEventListener("click",()=>cycleStatusAdmin(turnIndex));
  statusWrap.appendChild(stChip);

  if(p.status==="cooldown" && gameMode==="rumble"){
    const cdDiv=document.createElement("div");
    cdDiv.className="cd-info-inline";

    const cdLab=document.createElement("div");
    cdLab.className="cd-label";
    cdLab.textContent="Cooldown:";

    const cdVal=document.createElement("div");
    cdVal.className="cd-val-box";
    cdVal.textContent=p.cooldownRemaining+(p.readyToRespawn?"*":"");
    cdDiv.appendChild(cdLab);
    cdDiv.appendChild(cdVal);
    statusWrap.appendChild(cdDiv);
  }

  // timers block
  const timeRow=document.createElement("div");
  timeRow.className="timer-row";

  const blockTurn=document.createElement("div");
  blockTurn.className="timer-block";
  const labTurn=document.createElement("div");
  labTurn.className="timer-label";
  labTurn.textContent="Turn Time";
  const valTurn=document.createElement("div");
  valTurn.className="timer-val timer-turn-val";
  valTurn.textContent=msToClock(getPlayerTurnMs(p));
  blockTurn.appendChild(labTurn);
  blockTurn.appendChild(valTurn);

  const blockPlayer=document.createElement("div");
  blockPlayer.className="timer-block";
  const labPlayer=document.createElement("div");
  labPlayer.className="timer-label";
  labPlayer.textContent="Player Time";
  const valPlayer=document.createElement("div");
  valPlayer.className="timer-val timer-player-val";
  valPlayer.textContent=msToClock(getPlayerTotalMs(p));
  blockPlayer.appendChild(labPlayer);
  blockPlayer.appendChild(valPlayer);

  timeRow.appendChild(blockTurn);
  timeRow.appendChild(blockPlayer);

  // Commander Tax
  const taxRow=document.createElement("div");
  taxRow.className="tax-row";

  const taxLabel=document.createElement("div");
  taxLabel.className="tax-label";
  taxLabel.textContent="Commander Tax: +2 ×";

  const taxCtrl=document.createElement("div");
  taxCtrl.className="tax-ctrl";

  const taxMinus=document.createElement("div");
  taxMinus.className="tax-btn";
  taxMinus.textContent="-";
  taxMinus.addEventListener("click",()=>{
    if(p.commanderTaxSteps>0)p.commanderTaxSteps--;
    renderAll();
  });
  const taxVal=document.createElement("div");
  taxVal.className="tax-val";
  taxVal.textContent=p.commanderTaxSteps;
  const taxPlus=document.createElement("div");
  taxPlus.className="tax-btn";
  taxPlus.textContent="+";
  taxPlus.addEventListener("click",()=>{
    p.commanderTaxSteps++;
    renderAll();
  });

  taxCtrl.appendChild(taxMinus);
  taxCtrl.appendChild(taxVal);
  taxCtrl.appendChild(taxPlus);

  taxRow.appendChild(taxLabel);
  taxRow.appendChild(taxCtrl);

  nameBlock.appendChild(nmLabel);
  nameBlock.appendChild(nmInput);
  nameBlock.appendChild(statusWrap);
  nameBlock.appendChild(timeRow);
  nameBlock.appendChild(taxRow);

  if(p.skipDrawThisTurn){
    const reminder=document.createElement("div");
    reminder.className="respawn-draw-banner";
    reminder.textContent="Respawn Turn: Skip draw step. Draw 1 at END of turn.";
    nameBlock.appendChild(reminder);
  }

  leftCol.appendChild(nameBlock);

  /* RIGHT COL (life/poison/etc) */
  const rightCol=document.createElement("div");
  rightCol.className="hud-col";

  const vitalsBlock=document.createElement("div");
  vitalsBlock.className="section-block-inline vitalsBlock";

  const lfLabel=document.createElement("div");
  lfLabel.className="label-sm";
  lfLabel.textContent="Life Total";

  const lfRow=document.createElement("div");
  lfRow.className="life-row";

  const minusBtn=document.createElement("div");
  minusBtn.className="life-btn";
  minusBtn.textContent="-";
  minusBtn.addEventListener("click",()=>{
    p.life = p.life-1;
    lethalCheck(turnIndex,"life");
    renderAll();
  });

  const lifeVal=document.createElement("div");
  lifeVal.className="life-value";
  lifeVal.textContent=p.life;

  const plusBtn=document.createElement("div");
  plusBtn.className="life-btn";
  plusBtn.textContent="+";
  plusBtn.addEventListener("click",()=>{
    p.life = p.life+1;
    renderAll();
  });

  lfRow.appendChild(minusBtn);
  lfRow.appendChild(lifeVal);
  lfRow.appendChild(plusBtn);

  const grid=document.createElement("div");
  grid.className="mini-counters-grid";

  grid.appendChild(makeSubStepper("☠ Poison",p.poison,(val)=>{
    p.poison=val;
    lethalCheck(turnIndex,"poison");
    renderAll();
  }));
  grid.appendChild(makeSubStepper("☢ Rad",p.radiation,(val)=>{
    p.radiation=val;
    renderAll();
  }));
  grid.appendChild(makeSubStepper("⚡ Energy",p.energy,(val)=>{
    p.energy=val;
    renderAll();
  }));
  grid.appendChild(makeSubStepper("★ Exp",p.experience,(val)=>{
    p.experience=val;
    renderAll();
  }));
  grid.appendChild(makeSubStepper("☁ Storm",p.storm,(val)=>{
    p.storm=val;
    renderAll();
  }));

  vitalsBlock.appendChild(lfLabel);
  vitalsBlock.appendChild(lfRow);
  vitalsBlock.appendChild(grid);
  rightCol.appendChild(vitalsBlock);

  topRow.appendChild(leftCol);
  topRow.appendChild(rightCol);
  card.appendChild(topRow);

  hudArea.appendChild(card);

  // sync the tools panel with active player's stored tracking + globals
  dungeonInput.value = p.dungeonLookupName||"";
  dungeonViewerText.textContent = p.dungeonPreviewText||"";
  if(p.dungeonPreviewImg){
    dungeonViewerImg.src=p.dungeonPreviewImg;
    dungeonViewerImgBox.style.display="block";
  }else{
    dungeonViewerImgBox.style.display="none";
    dungeonViewerImg.removeAttribute("src");
  }

  emblemInput.value = p.emblemLookupName||"";
  emblemViewerText.textContent = p.emblemPreviewText||"";
  if(p.emblemPreviewImg){
    emblemViewerImg.src=p.emblemPreviewImg;
    emblemViewerImgBox.style.display="block";
  }else{
    emblemViewerImgBox.style.display="none";
    emblemViewerImg.removeAttribute("src");
  }

  dungeonProgressArea.value = p.dungeonProgress||"";
  emblemsArea.value         = p.emblemsText||"";

  planeInput.value = currentPlaneName||"";
  planeViewerText.textContent = currentPlaneText||"";
  if(currentPlaneImg){
    planeViewerImg.src=currentPlaneImg;
    planeViewerImgBox.style.display="block";
  }else{
    planeViewerImgBox.style.display="none";
    planeViewerImg.removeAttribute("src");
  }

  schemeInput.value = currentSchemeName||"";
  schemeViewerText.textContent = currentSchemeText||"";
  if(currentSchemeImg){
    schemeViewerImg.src=currentSchemeImg;
    schemeViewerImgBox.style.display="block";
  }else{
    schemeViewerImgBox.style.display="none";
    schemeViewerImg.removeAttribute("src");
  }

  modeStatusText.textContent =
    (gameMode==="regular"?"Mode 1 — Regular":"Mode 2 — Rumble");
  modeSmallLabel.textContent =
    "Mode: "+(gameMode==="regular"?"Regular":"Rumble");
}

/* RENDER OTHER PLAYERS */
function renderPlayers(){
  // accordion outer
  playersChevron.textContent = playersOpen?"▲":"▼";
  playersWrapper.style.maxHeight = playersOpen ? playersWrapper.scrollHeight+"px" : "0";

  playersBody.innerHTML="";

  players.forEach((pl,i)=>{
    if(i===turnIndex) return; // don't render current player here

    const block=document.createElement("div");
    block.className="other-player-block";

    const top=document.createElement("div");
    top.className="other-top-row";

    const topLeft=document.createElement("div");
    topLeft.className="other-top-left";

    const nm=pl.name||("Player "+(i+1));
    const nmEl=document.createElement("div");
    nmEl.className="other-top-name";
    nmEl.textContent=nm;
    topLeft.appendChild(nmEl);

    const subline=document.createElement("div");
    subline.className="other-top-subline";

    let stChunk="Status: "+pl.status.toUpperCase();
    if(pl.status==="cooldown" && gameMode==="rumble"){
      stChunk+=" ("+pl.cooldownRemaining+(pl.readyToRespawn?"*":"")+")";
    }
    const stSpan=document.createElement("span");
    stSpan.textContent=stChunk;
    subline.appendChild(stSpan);

    const tSpan=document.createElement("span");
    tSpan.className="player-time-val";
    tSpan.setAttribute("data-idx",i);
    tSpan.textContent="Time "+msToClock(getPlayerTotalMs(pl));
    subline.appendChild(tSpan);

    topLeft.appendChild(subline);

    const chev=document.createElement("div");
    chev.className="other-chevron";
    const isOpen=!!otherOpen[i];
    chev.textContent=isOpen?"▲":"▼";
    if(isOpen){
      chev.style.transform="rotate(0deg)";
    }else{
      chev.style.transform="rotate(0deg)";
    }

    top.appendChild(topLeft);
    top.appendChild(chev);

    // inner collapsible
    const wrapInner=document.createElement("div");
    wrapInner.className="other-body-wrapper";
    wrapInner.style.maxHeight = isOpen ? "1000px" : "0";

    const body=document.createElement("div");
    body.className="other-body";

    // vitals + counters
    const inlineVitals=document.createElement("div");
    inlineVitals.className="inline-row-wrap";

    // life controls
    const lifeCol=document.createElement("div");
    lifeCol.className="inline-col";

    const lifeLab=document.createElement("div");
    lifeLab.className="inline-col-label";
    lifeLab.textContent="Life Total ("+nm+")";

    const lifeRow=document.createElement("div");
    lifeRow.className="inline-life-row";

    const minusBtn=document.createElement("div");
    minusBtn.className="step-btn";
    minusBtn.textContent="-";
    minusBtn.addEventListener("click",()=>{
      pl.life=pl.life-1;
      lethalCheck(i,"life");
      renderAll();
    });

    const lifeVal=document.createElement("div");
    lifeVal.className="inline-life-val";
    lifeVal.textContent=pl.life;

    const plusBtn=document.createElement("div");
    plusBtn.className="step-btn";
    plusBtn.textContent="+";
    plusBtn.addEventListener("click",()=>{
      pl.life=pl.life+1;
      renderAll();
    });

    lifeRow.appendChild(minusBtn);
    lifeRow.appendChild(lifeVal);
    lifeRow.appendChild(plusBtn);
    lifeCol.appendChild(lifeLab);
    lifeCol.appendChild(lifeRow);

    // counters
    const countersCol=document.createElement("div");
    countersCol.className="inline-col";

    const countersLab=document.createElement("div");
    countersLab.className="inline-col-label";
    countersLab.textContent="Counters ("+nm+")";

    const ctrRow=document.createElement("div");
    ctrRow.className="inline-row-wrap";

    ctrRow.appendChild(smallStepper("☠ Poison",pl.poison,(v)=>{
      pl.poison=v;
      lethalCheck(i,"poison");
      renderAll();
    }));
    ctrRow.appendChild(smallStepper("☢ Rad",pl.radiation,(v)=>{
      pl.radiation=v;
      renderAll();
    }));
    ctrRow.appendChild(smallStepper("★ Exp",pl.experience,(v)=>{
      pl.experience=v;
      renderAll();
    }));
    ctrRow.appendChild(smallStepper("☁ Storm",pl.storm,(v)=>{
      pl.storm=v;
      renderAll();
    }));

    countersCol.appendChild(countersLab);
    countersCol.appendChild(ctrRow);

    inlineVitals.appendChild(lifeCol);
    inlineVitals.appendChild(countersCol);
    body.appendChild(inlineVitals);

    // commander damage grid
    const cdmg=document.createElement("div");
    cdmg.className="cdmg-wrap";

    const cdmgHead=document.createElement("div");
    cdmgHead.className="cdmg-head";
    cdmgHead.textContent="Commander Damage Taken by "+nm+" (21 from one source = elim)";
    cdmg.appendChild(cdmgHead);

    const cdmgGrid=document.createElement("div");
    cdmgGrid.className="cdmg-grid";

    players.forEach((srcPl,srcIdx)=>{
      const srcName=srcPl.name||("P"+(srcIdx+1));
      const cell=document.createElement("div");
      cell.className="cdmg-cell";

      const label=document.createElement("div");
      label.className="cdmg-cell-label";
      label.textContent="from "+srcName;

      const row=document.createElement("div");
      row.className="cdmg-input-row";

      const dmgIn=document.createElement("input");
      dmgIn.type="number";
      dmgIn.min="0";
      dmgIn.value=pl.commanderDamage[srcIdx]||0;
      dmgIn.addEventListener("input",e=>{
        let v=parseInt(e.target.value,10);
        if(isNaN(v)||v<0)v=0;
        pl.commanderDamage[srcIdx]=v;
        checkCommanderDamageElim(i);
        renderAll();
      });

      row.appendChild(dmgIn);
      cell.appendChild(label);
      cell.appendChild(row);
      cdmgGrid.appendChild(cell);
    });
    cdmg.appendChild(cdmgGrid);
    body.appendChild(cdmg);

    // politics note
    const noteWrap=document.createElement("div");
    noteWrap.className="inline-col";
    const noteLab=document.createElement("div");
    noteLab.className="inline-col-label";
    noteLab.textContent="Note on "+nm+" (Deals, Goaded, etc.)";
    const noteTa=document.createElement("textarea");
    noteTa.className="notes-area";
    noteTa.value=pl.notesText;
    noteTa.addEventListener("input",e=>{
      pl.notesText=e.target.value;
    });
    noteWrap.appendChild(noteLab);
    noteWrap.appendChild(noteTa);
    body.appendChild(noteWrap);

    wrapInner.appendChild(body);

    // clicking header toggles
    top.addEventListener("click",()=>{
      otherOpen[i]=!otherOpen[i];
      renderPlayers();
    });

    block.appendChild(top);
    block.appendChild(wrapInner);
    playersBody.appendChild(block);
  });

  // recalc wrapper height (smooth close/open)
  playersWrapper.style.maxHeight = playersOpen ? playersWrapper.scrollHeight+"px" : "0";
}

/* MAIN FULL RENDER */
function renderAll(){
  syncCommanderDamageArrays();

  const cur=players[turnIndex]||{};
  const nm=cur.name||("Player "+(turnIndex+1));
  turnBanner.textContent="▶ "+nm.toUpperCase()+"'S TURN ◀";

  renderHUD();
  renderPlayers();
  renderGlobalTimerBanner();

  // update themeSelect to match
  const bodyClass = document.body.classList.contains("theme-neon")
    ?"theme-neon"
    :document.body.classList.contains("theme-dark")
      ?"theme-dark"
      :"";
  themeSelect.value = bodyClass;
  themeToggleBtn.textContent =
    bodyClass==="theme-neon" ? "Neon" :
    bodyClass==="theme-dark" ? "Dark" : "Light";

  // update tools accordion height + chevron
  toolsChevron.textContent = toolsOpen?"▲":"▼";
  toolsWrapper.style.maxHeight = toolsOpen ? toolsWrapper.scrollHeight+"px" : "0";
}

/* =========================================================
   SETUP / RESET
========================================================= */
function resetGameStateKeepMode(){
  players=[];
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;
  otherOpen={};

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  // reset globals
  currentPlaneName   ="";
  currentPlaneText   ="";
  currentPlaneImg    ="";
  currentSchemeName  ="";
  currentSchemeText  ="";
  currentSchemeImg   ="";
}

/* show mode picker */
function showModeStep(){
  resetGameStateKeepMode();
  gameMode=null;
  setupStepMode.style.display="flex";
  setupStepPlayers.style.display="none";
  setupOverlay.style.display="flex";
}

/* show player count picker */
function showPlayerCountStep(){
  resetGameStateKeepMode();
  setupStepMode.style.display="none";
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

/* hook up mode choices */
setupStepMode.querySelectorAll("[data-mode]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const m=btn.getAttribute("data-mode");
    gameMode = (m==="regular")?"regular":"rumble";
    showPlayerCountStep();
  });
});

setupStepPlayers.querySelectorAll("[data-fixedplayers]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const n=parseInt(btn.getAttribute("data-fixedplayers"),10);
    startGameWith(n);
  });
});
manualStartBtn.addEventListener("click",()=>{
  let n=parseInt(manualPlayerCount.value,10);
  if(isNaN(n)||n<2)n=2;
  if(n>9)n=9;
  startGameWith(n);
});

/* actually start */
function startGameWith(nPlayers){
  players=[];
  for(let i=0;i<nPlayers;i++){
    players.push(makePlayer("Player "+(i+1)));
  }

  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;

  gameStartTime=Date.now();

  syncCommanderDamageArrays();
  setupOverlay.style.display="none";

  if(players[0] && players[0].status==="active"){
    startTimingPlayer(0);
  }

  toolsOpen=false;
  playersOpen=false;

  renderAll();

  if(renderIntervalId){
    clearInterval(renderIntervalId);
  }
  renderIntervalId=setInterval(()=>{
    if(!winnerLocked){
      renderTimersOnly();
    }
  },1000);
}

/* =========================================================
   THEME
========================================================= */
function cycleTheme(){
  const body=document.body;
  if(body.classList.contains("theme-neon")){
    body.classList.remove("theme-neon");
    body.classList.remove("theme-dark");
  }else if(body.classList.contains("theme-dark")){
    body.classList.remove("theme-dark");
    body.classList.add("theme-neon");
  }else{
    body.classList.add("theme-dark");
  }
  renderAll();
}
themeToggleBtn.addEventListener("click",cycleTheme);

themeSelect.addEventListener("change",()=>{
  document.body.classList.remove("theme-dark","theme-neon");
  const val=themeSelect.value;
  if(val){
    document.body.classList.add(val);
  }
  renderAll();
});

/* =========================================================
   ACCORDIONS
========================================================= */
toolsHead.addEventListener("click",()=>{
  toolsOpen=!toolsOpen;
  renderAll();
});
playersHead.addEventListener("click",()=>{
  playersOpen=!playersOpen;
  renderAll();
});

/* =========================================================
   RULES DRAWER
========================================================= */
rulesTrigger.addEventListener("click",()=>{
  rulesDrawer.classList.add("show");
  rulesDim.classList.add("show");
});
rulesCloseBtn.addEventListener("click",()=>{
  rulesDrawer.classList.remove("show");
  rulesDim.classList.remove("show");
});
rulesDim.addEventListener("click",()=>{
  rulesDrawer.classList.remove("show");
  rulesDim.classList.remove("show");
});

/* =========================================================
   OTHER UI BUTTONS
========================================================= */
endTurnBtn.addEventListener("click",()=>{ passTurn(); });
winnerCloseBtn.addEventListener("click",()=>{
  winnerOverlay.style.display="none";
});

flipCoinBtn.addEventListener("click",()=>{
  rngOutput.textContent="Coin: "+(Math.random()<0.5?"Heads":"Tails");
});
rollD6Btn.addEventListener("click",()=>{
  rngOutput.textContent="d6: "+(Math.floor(Math.random()*6)+1);
});
rollD20Btn.addEventListener("click",()=>{
  rngOutput.textContent="d20: "+(Math.floor(Math.random()*20)+1);
});

newGameBtn.addEventListener("click",()=>{
  if(!confirm("Start a new game in the same mode? This clears all data.")) return;
  showPlayerCountStep();
});
changeModeBtn.addEventListener("click",()=>{
  if(!confirm("Change mode? This restarts the game.")) return;
  showModeStep();
});

/* lookups */
globalLookupBtn.addEventListener("click",runGlobalLookup);

dungeonBtn.addEventListener("click",()=>{
  const p=players[turnIndex];
  if(p){ p.dungeonLookupName=dungeonInput.value||""; }
  runDungeonLookup();
});
emblemBtn.addEventListener("click",()=>{
  const p=players[turnIndex];
  if(p){ p.emblemLookupName=emblemInput.value||""; }
  runEmblemLookup();
});
planeBtn.addEventListener("click",()=>{
  currentPlaneName=planeInput.value||"";
  runPlaneLookup();
});
schemeBtn.addEventListener("click",()=>{
  currentSchemeName=schemeInput.value||"";
  runSchemeLookup();
});

/* bind textareas to player fields live */
dungeonProgressArea.addEventListener("input",e=>{
  const p=players[turnIndex];
  if(p){
    p.dungeonProgress=e.target.value;
  }
});
emblemsArea.addEventListener("input",e=>{
  const p=players[turnIndex];
  if(p){
    p.emblemsText=e.target.value;
  }
});

/* =========================================================
   INIT
========================================================= */
showModeStep();
renderAll();
</script>
</body>
</html>