<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>EDH RUMBLE TRACKER</title>
<style>
/* -------------------------------------------------
   THEME VARIABLES
   Light = default on <body>, .theme-dark / .theme-neon get toggled
------------------------------------------------- */
:root {
  --bg-main:#ffffff;
  --bg-panel:#ffffff;
  --bg-accent:#f4f4fa;
  --border-soft:#bfbfd4;

  --text-primary:#1a1a22;
  --text-dim:#5a5a77;

  --gold:#9c7a1f;
  --cyan:#2a8f8f;
  --magenta:#b51882;
  --lime:#2a8f2a;
  --red:#a63f3f;
  --off:#8a8aa5;

  --button-bg:#ffffff;
  --button-border:#bfbfd4;

  --overlay-bg:rgba(0,0,0,0.6);

  --tool-bg:#ffffff;
  --tool-border:#bfbfd4;
}

.theme-dark {
  --bg-main:#0f0f12;
  --bg-panel:#1a1a22;
  --bg-accent:#2a2a36;
  --border-soft:#3a3a4f;

  --text-primary:#f5f5fa;
  --text-dim:#8a8aa5;

  --gold:#d4a94f;
  --cyan:#5fd8d8;
  --magenta:#ff4acb;
  --lime:#5fd85f;
  --red:#d85f5f;
  --off:#55556e;

  --button-bg:#2a2a36;
  --button-border:#3a3a4f;

  --overlay-bg:rgba(0,0,0,0.8);

  --tool-bg:#1a1a22;
  --tool-border:#3a3a4f;
}

.theme-neon {
  --bg-main:#050509;
  --bg-panel:#0e0e1a;
  --bg-accent:#1a1a33;
  --border-soft:#4a4aff;

  --text-primary:#ffeefe;
  --text-dim:#ff4aeb;

  --gold:#ffef5a;
  --cyan:#5fd8ff;
  --magenta:#ff4acb;
  --lime:#5CFFB6;
  --red:#ff4a6b;
  --off:#4f4f80;

  --button-bg:#1a1a33;
  --button-border:#4a4aff;

  --overlay-bg:rgba(0,0,30,0.8);

  --tool-bg:#0e0e1a;
  --tool-border:#4a4aff;
}

/* -------------------------------------------------
   GLOBAL BASE
------------------------------------------------- */
*{
  box-sizing:border-box;
  font-family:system-ui, Roboto, "Helvetica Neue", Arial, sans-serif;
}
body{
  margin:0;
  background:var(--bg-main);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  justify-content:center;
}
button{
  cursor:pointer;
  font-family:inherit;
  color:var(--text-primary);
}
input, textarea, select {
  font-family:inherit;
  color:var(--text-primary);
}

/* -------------------------------------------------
   APP SHELL LAYOUT
------------------------------------------------- */
.app-shell{
  width:100%;
  max-width:480px;
  min-height:100vh;
  background:var(--bg-main);
  display:flex;
  flex-direction:column;
  position:relative;
}

/* TOP TURN REMINDER BAR ("▶ PLAYER X'S TURN ◀" + any urgent reminder) */
.turn-reminder-bar{
  background:var(--bg-accent);
  border-bottom:1px solid var(--border-soft);
  padding:.5rem .75rem;
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  gap:.5rem .75rem;
  text-align:center;
}
.turn-reminder-main{
  font-size:.8rem;
  font-weight:700;
  color:var(--gold);
  letter-spacing:.05em;
}
.turn-reminder-extra{
  font-size:.7rem;
  font-weight:600;
  color:var(--red);
  line-height:1.3;
}

/* APP HEADER ROW: Title | Global Timer | Theme Toggle */
.app-header{
  position:sticky;
  top:0;
  z-index:1000;
  background:var(--bg-panel);
  border-bottom:1px solid var(--border-soft);
  padding:.6rem .75rem;
  display:flex;
  flex-wrap:wrap;
  justify-content:space-between;
  align-items:center;
  gap:.5rem .75rem;
}
.game-title{
  font-size:.8rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
}
#globalTimerBanner{
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.theme-toggle-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.4rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  line-height:1;
  min-width:3.5rem;
  text-align:center;
}

/* MAIN SCROLL AREA */
.content-area{
  flex:1;
  overflow-y:auto;
  padding:1rem .75rem 8rem; /* leave room for footer rules */
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* ACTIVE PLAYER HUD CARD */
.hud-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  box-shadow:0 20px 40px rgba(0,0,0,.12);
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.75rem;
}
.hud-card.glow-border{
  box-shadow:0 0 20px rgba(0,0,0,.15),0 30px 60px rgba(0,0,0,.2);
}
.hud-top-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  justify-content:space-between;
}
.hud-col{
  flex:1 1 220px;
  min-width:0;
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* sub-panels in HUD */
.section-block-inline{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem .6rem .6rem;
  display:flex;
  flex-direction:column;
  gap:.6rem;
}

/* labels + inputs */
.label-sm{
  font-size:.6rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.text-input{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.5rem .6rem;
  min-width:5rem;
  font-weight:600;
  width:100%;
}
.text-input:focus{
  outline:2px solid var(--border-soft);
}

/* status row */
.tiny-row{
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  gap:.6rem .75rem;
  font-size:.7rem;
}
.status-chip{
  border-radius:.5rem;
  padding:.5rem .6rem;
  text-align:center;
  font-size:.7rem;
  font-weight:700;
  line-height:1.2;
  border:1px solid;
  cursor:pointer;
  min-width:5.5rem;
}
.status-active{
  color:var(--lime);
  border-color:var(--lime);
  background:rgba(44,255,44,.08);
}
.status-cooldown{
  color:var(--red);
  border-color:var(--red);
  background:rgba(255,44,44,.08);
}
.status-elim{
  color:var(--off);
  border-color:var(--off);
  background:rgba(85,85,110,.12);
}

.cd-info-inline{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
}
.cd-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.cd-val-box{
  min-width:2rem;
  text-align:center;
  font-size:.8rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
  color:var(--text-primary);
}

/* timers */
.timer-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem 1rem;
  font-size:.7rem;
  line-height:1.3;
}
.timer-block{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.timer-label{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.timer-val{
  font-size:clamp(.8rem,.6rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  min-width:3.5rem;
}

/* commander tax */
.tax-row{
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.tax-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.tax-ctrl{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.tax-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:700;
  line-height:1;
  padding:.45rem .65rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.tax-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .6rem;
  color:var(--text-primary);
}

/* respawn reminder */
.respawn-draw-banner{
  background:rgba(212,169,79,.07);
  border:1px solid var(--gold);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.7rem;
  font-weight:600;
  line-height:1.3;
  color:var(--gold);
}

/* life + counters */
.vitalsBlock .life-row{
  display:flex;
  align-items:center;
  gap:.5rem;
  flex-wrap:wrap;
}
.life-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:1rem;
  font-weight:700;
  line-height:1;
  padding:.5rem .7rem;
  min-width:2.2rem;
  text-align:center;
  color:var(--text-primary);
}
.life-value{
  min-width:3rem;
  text-align:center;
  font-size:1.2rem;
  font-weight:700;
  color:var(--text-primary);
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .7rem;
  line-height:1.2;
}

/* grid of poison/rad/etc */
.mini-counters-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(160px,100%),1fr));
  gap:.75rem;
}
.sub-box{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.sub-box-label{
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  display:flex;
  align-items:center;
  gap:.4rem;
}
.sub-box-step-row{
  display:flex;
  align-items:center;
  gap:.5rem;
  flex-wrap:wrap;
}
.step-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.9rem;
  font-weight:700;
  line-height:1;
  padding:.45rem .65rem;
  min-width:2.1rem;
  text-align:center;
  color:var(--text-primary);
}
.step-val{
  min-width:2.5rem;
  text-align:center;
  font-size:1rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.45rem .6rem;
  line-height:1.2;
  color:var(--text-primary);
}

/* END TURN */
.end-turn-btn{
  background:var(--gold);
  border:none;
  border-radius:.5rem;
  padding:.9rem .9rem;
  font-size:clamp(.8rem,.5rem + .5vw,.95rem);
  font-weight:700;
  color:#000;
  text-align:center;
  box-shadow:0 10px 20px rgba(0,0,0,.2);
  width:100%;
}

/* -------------------------------------------------
   TOOLS ACCORDION (GLOBAL SEARCH / DUNGEON / ETC / RANDOMIZERS / THEME)
------------------------------------------------- */
.tools-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  box-shadow:0 20px 40px rgba(0,0,0,.12);
  display:flex;
  flex-direction:column;
}
.tools-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
  gap:.5rem;
  padding:.75rem;
  cursor:pointer;
}
.tools-head-left{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.tools-title{
  font-size:.8rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.tools-hint{
  font-size:.7rem;
  font-weight:500;
  color:var(--text-dim);
  line-height:1.3;
}
.tools-chevron{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
}
.tools-body{
  display:none;
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
  display:flex;
  flex-direction:column;
  gap:1rem;
}

/* each tool block */
.tool-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.6rem;
}
.tool-block-label{
  font-size:.65rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}

/* lookup rows */
.lookup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  align-items:flex-end;
}
.lookup-col{
  flex:1;
  min-width:8rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.lookup-input{
  width:100%;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.5rem .6rem;
  font-weight:600;
}
.lookup-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
  min-width:5rem;
}
.mini-viewer-block{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  font-size:.7rem;
  line-height:1.3;
  color:var(--text-primary);
}
.viewer-textbox{
  flex:2;
  min-width:10rem;
  white-space:pre-line;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem .6rem;
  font-size:.7rem;
  line-height:1.3;
}
.viewer-imgbox{
  flex:1;
  min-width:6rem;
  max-width:140px;
  border-radius:.5rem;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  overflow:hidden;
  align-self:flex-start;
  display:none;
}
.viewer-imgbox img{
  width:100%;
  height:auto;
  display:block;
}

/* randomizers row */
.rng-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.rng-btn{
  flex:1;
  min-width:4rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
  padding:.6rem .75rem;
  text-align:center;
}
.rng-output{
  font-size:.8rem;
  font-weight:600;
  min-height:1em;
  line-height:1.2;
  color:var(--gold);
  word-break:break-word;
}

/* inline theme selector backup */
.theme-select{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:100%;
}

/* -------------------------------------------------
   PLAYERS ACCORDION
------------------------------------------------- */
.players-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  box-shadow:0 20px 40px rgba(0,0,0,.12);
  display:flex;
  flex-direction:column;
}
.players-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
  gap:.5rem;
  padding:.75rem;
  cursor:pointer;
}
.players-head-left{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.players-title{
  font-size:.8rem;
  font-weight:700;
  color:var(--text-primary);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.players-hint{
  font-size:.7rem;
  font-weight:500;
  color:var(--text-dim);
  line-height:1.3;
}
.players-chevron{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
}
.players-body{
  display:none;
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* individual other player block */
.other-player-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  overflow:hidden;
}
.other-top-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  cursor:pointer;
  padding:.75rem .75rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
}
.other-top-left{
  display:flex;
  flex-direction:column;
  line-height:1.3;
  gap:.25rem;
}
.other-top-name{
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
}
.other-top-subline{
  font-size:.7rem;
  color:var(--text-dim);
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:center;
}
.other-chevron{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
}
.other-body{
  display:none;
  padding:.75rem;
  border-top:1px solid var(--border-soft);
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* player inline data chunks */
.inline-row-wrap{
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  gap:.75rem;
  font-size:.7rem;
}
.inline-col{
  display:flex;
  flex-direction:column;
  gap:.4rem;
  min-width:min(160px,100%);
  flex:1 1 160px;
}
.inline-col-label{
  font-size:.6rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.inline-life-row{
  display:flex;
  align-items:center;
  gap:.5rem;
  flex-wrap:wrap;
}
.inline-life-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .6rem;
}

/* small steppers for other players' counters */
.player-stepper-label{
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
}
.player-stepper-row{
  display:flex;
  flex-wrap:wrap;
  gap:.4rem;
  align-items:center;
}

/* commander damage grid */
.cdmg-wrap{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.cdmg-head{
  font-size:.6rem;
  font-weight:600;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.cdmg-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(140px,100%),1fr));
  gap:.5rem .75rem;
}
.cdmg-cell{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  gap:.4rem;
  font-size:.7rem;
}
.cdmg-cell-label{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.2;
}
.cdmg-input-row input{
  width:3rem;
  text-align:center;
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.4rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
}

/* per-player politics note */
.notes-area{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem .6rem;
  width:100%;
  min-height:3rem;
  resize:vertical;
  font-size:.75rem;
  line-height:1.3;
  color:var(--text-primary);
  font-weight:400;
}

/* -------------------------------------------------
   FOOTER RULES BANNER (always visible at bottom)
------------------------------------------------- */
.rules-footer{
  position:sticky;
  bottom:0;
  background:var(--tool-bg);
  border-top:1px solid var(--tool-border);
  color:var(--text-primary);
  font-size:.7rem;
  line-height:1.4;
  padding:.75rem .75rem calc(env(safe-area-inset-bottom,0px) + .75rem);
  box-shadow:0 -20px 40px rgba(0,0,0,.2);
  white-space:pre-line;
  max-height:35vh;
  overflow-y:auto;
  font-weight:400;
}
.rules-footer-title{
  font-size:.7rem;
  font-weight:700;
  color:var(--gold);
  margin-bottom:.5rem;
  text-transform:uppercase;
  letter-spacing:.05em;
}

/* -------------------------------------------------
   OVERLAYS (Setup, Announce, Winner)
------------------------------------------------- */
.overlay-fullscreen{
  position:fixed;
  inset:0;
  background:var(--overlay-bg);
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:1rem;
}

/* setup cards */
.setup-card{
  background:var(--bg-panel);
  border:2px solid var(--border-soft);
  border-radius:.75rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  display:flex;
  flex-direction:column;
  gap:1rem;
  text-align:center;
  box-shadow:0 30px 60px rgba(0,0,0,.4);
}
.setup-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.setup-sub{
  font-size:.7rem;
  color:var(--text-dim);
  line-height:1.4;
}
.setup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  justify-content:center;
}
.setup-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.setup-small{
  display:flex;
  flex-direction:column;
  gap:.5rem;
  align-items:center;
  width:100%;
}
.label-block{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
  text-align:center;
  font-weight:600;
}
.setup-number-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:5rem;
  text-align:center;
}
.setup-go{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
}
.helper-row{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.3;
  text-align:center;
}

/* announce / cooldown modal */
.announce-card{
  background:var(--bg-panel);
  border:2px solid var(--gold);
  border-radius:1rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  text-align:center;
  display:flex;
  flex-direction:column;
  gap:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.4),0 40px 80px rgba(0,0,0,.8);
  font-size:.8rem;
  line-height:1.4;
  color:var(--text-primary);
}
.announce-strong{
  color:var(--gold);
  font-weight:700;
  font-size:.9rem;
  line-height:1.3;
}
.cooldown-ack-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
  width:100%;
}

/* winner card */
.winner-card{
  background:var(--bg-panel);
  border:2px solid var(--gold);
  border-radius:1rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  text-align:center;
  display:flex;
  flex-direction:column;
  gap:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.4),0 40px 80px rgba(0,0,0,.8);
}
.winner-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--gold);
  line-height:1.3;
  word-break:break-word;
}
.winner-line{
  font-size:.8rem;
  font-weight:500;
  color:var(--text-primary);
  line-height:1.4;
}
.overlay-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}

/* winner mini ribbon (used nowhere visible right now but kept) */
.winner-mini-banner{
  display:none;
  border:1px solid var(--gold);
  color:var(--gold);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1.4;
  word-break:break-word;
}
</style>
</head>
<body>

<div class="app-shell">

  <!-- ===== SETUP OVERLAY ===== -->
  <div id="setupOverlay" class="overlay-fullscreen" style="display:flex;">
    <!-- Step 1: Mode -->
    <div class="setup-card" id="setupStepMode">
      <div class="setup-title">Select Mode</div>
      <div class="setup-row">
        <button class="setup-btn" data-mode="regular">
          Mode 1 — Regular
          <div class="setup-sub">Standard Commander. No respawn.</div>
        </button>
        <button class="setup-btn" data-mode="rumble">
          Mode 2 — Rumble
          <div class="setup-sub">Cooldown / Respawn / Reigning Rumbler.</div>
        </button>
      </div>
      <div class="helper-row">You'll pick player count next.</div>
    </div>

    <!-- Step 2: Players -->
    <div class="setup-card" id="setupStepPlayers" style="display:none;">
      <div class="setup-title">How many players?</div>
      <div class="setup-row">
        <button class="setup-btn" data-fixedplayers="2">2</button>
        <button class="setup-btn" data-fixedplayers="3">3</button>
        <button class="setup-btn" data-fixedplayers="4">4</button>
      </div>
      <div class="setup-small">
        <div class="label-block">Manual Entry (2–8)</div>
        <input id="manualPlayerCount" class="setup-number-input" type="number" min="2" max="8" value="4" />
        <button id="manualStartBtn" class="setup-go">Start Game</button>
      </div>
      <div class="helper-row">Rename yourself on your first turn.</div>
    </div>
  </div>

  <!-- ===== ANNOUNCE OVERLAY (cooldown / respawn / draw reminders) ===== -->
  <div id="announceOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="announce-card">
      <div class="announce-strong" id="announceMain">Announcement</div>
      <div id="announceBody">Body text.</div>
      <button class="cooldown-ack-btn" id="announceOkBtn">OK</button>
    </div>
  </div>

  <!-- ===== WINNER OVERLAY ===== -->
  <div id="winnerOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="winner-card">
      <div class="winner-title" id="winnerTitle">REIGNING RUMBLER!</div>
      <div class="winner-line" id="winnerTimeLine">Global Time: 00m 00s</div>
      <div class="winner-line" id="winnerPlayerTimeLine">Winner Player Time: 00m 00s</div>
      <button class="overlay-btn" id="winnerCloseBtn">OK</button>
    </div>
  </div>

  <!-- ===== TURN REMINDER BAR ===== -->
  <div class="turn-reminder-bar">
    <div class="turn-reminder-main" id="turnBanner">▶ PLAYER 1'S TURN ◀</div>
    <div class="turn-reminder-extra" id="turnReminderExtra" style="display:none;"></div>
  </div>

  <!-- ===== APP HEADER ===== -->
  <div class="app-header">
    <div class="game-title">EDH RUMBLE TRACKER</div>
    <div id="globalTimerBanner">Global: 0:00</div>
    <button id="themeToggleBtn" class="theme-toggle-btn">Light</button>
  </div>

  <!-- ===== MAIN CONTENT ===== -->
  <div class="content-area" id="contentArea">

    <!-- ACTIVE PLAYER HUD -->
    <div id="hudArea"></div>

    <!-- END TURN -->
    <button class="end-turn-btn" id="endTurnBtn">End Turn →</button>

    <!-- TOOLS ACCORDION -->
    <div class="tools-card" id="toolsCard">
      <div class="tools-head" id="toolsHead">
        <div class="tools-head-left">
          <div class="tools-title">Tools & Lookups</div>
          <div class="tools-hint">Card text, Dungeon / Emblem helper, Plane / Scheme, Randomizers</div>
        </div>
        <div class="tools-chevron" id="toolsChevron">▲</div>
      </div>
      <div class="tools-body" id="toolsBody" style="display:none;">

        <!-- GLOBAL CARD LOOKUP -->
        <div class="tool-block">
          <div class="tool-block-label">Card Lookup (Scryfall)</div>
          <div class="lookup-row">
            <div class="lookup-col">
              <input id="globalLookupInput" class="lookup-input" placeholder="Any card..." />
              <button id="globalLookupBtn" class="lookup-btn">Search</button>
            </div>
          </div>
          <div class="mini-viewer-block">
            <div class="viewer-textbox" id="globalViewerText"></div>
            <div class="viewer-imgbox" id="globalViewerImgBox">
              <img id="globalViewerImg" alt="card art"/>
            </div>
          </div>
        </div>

        <!-- DUNGEON / EMBLEM HELPERS (per current active player) -->
        <div class="tool-block" id="dungeonEmblemBlock">
          <div class="tool-block-label">Dungeon / Emblem Tracking (Active Player)</div>

          <!-- Dungeon -->
          <div class="lookup-row">
            <div class="lookup-col">
              <input id="dungeonInput" class="lookup-input" placeholder="Lookup Dungeon..." />
              <button id="dungeonBtn" class="lookup-btn">Search Dungeon</button>
            </div>
          </div>
          <div class="mini-viewer-block">
            <div class="viewer-textbox" id="dungeonViewerText"></div>
            <div class="viewer-imgbox" id="dungeonViewerImgBox">
              <img id="dungeonViewerImg" alt="dungeon art"/>
            </div>
          </div>

          <!-- Emblem -->
          <div class="lookup-row">
            <div class="lookup-col">
              <input id="emblemInput" class="lookup-input" placeholder="Lookup Emblem / Walker Ult..." />
              <button id="emblemBtn" class="lookup-btn">Search Emblem</button>
            </div>
          </div>
          <div class="mini-viewer-block">
            <div class="viewer-textbox" id="emblemViewerText"></div>
            <div class="viewer-imgbox" id="emblemViewerImgBox">
              <img id="emblemViewerImg" alt="emblem art"/>
            </div>
          </div>

          <!-- we keep the player's stored dungeonProgress/emblemsText editable -->
          <div class="lookup-col">
            <div class="tool-block-label" style="text-transform:none;letter-spacing:0;font-size:.7rem;">
              Dungeon / Undercity / Progress
            </div>
            <textarea id="dungeonProgressArea" class="notes-area" style="min-height:4rem;"></textarea>
          </div>

          <div class="lookup-col">
            <div class="tool-block-label" style="text-transform:none;letter-spacing:0;font-size:.7rem;">
              Emblems / Globals
            </div>
            <textarea id="emblemsArea" class="notes-area" style="min-height:4rem;"></textarea>
          </div>
        </div>

        <!-- TABLE-WIDE Plane / Scheme -->
        <div class="tool-block" id="planeSchemeBlock">
          <div class="tool-block-label">Table-Wide Effects (Planechase / Archenemy)</div>

          <!-- Plane -->
          <div class="lookup-row">
            <div class="lookup-col">
              <input id="planeInput" class="lookup-input" placeholder="Current Plane..." />
              <button id="planeBtn" class="lookup-btn">Search Plane</button>
            </div>
          </div>
          <div class="mini-viewer-block">
            <div class="viewer-textbox" id="planeViewerText"></div>
            <div class="viewer-imgbox" id="planeViewerImgBox">
              <img id="planeViewerImg" alt="plane art"/>
            </div>
          </div>

          <!-- Scheme -->
          <div class="lookup-row">
            <div class="lookup-col">
              <input id="schemeInput" class="lookup-input" placeholder="Current Scheme..." />
              <button id="schemeBtn" class="lookup-btn">Search Scheme</button>
            </div>
          </div>
          <div class="mini-viewer-block">
            <div class="viewer-textbox" id="schemeViewerText"></div>
            <div class="viewer-imgbox" id="schemeViewerImgBox">
              <img id="schemeViewerImg" alt="scheme art"/>
            </div>
          </div>
        </div>

        <!-- RANDOMIZERS -->
        <div class="tool-block">
          <div class="tool-block-label">Randomizers</div>
          <div class="rng-row">
            <button class="rng-btn" id="flipCoinBtn">Coin Flip</button>
            <button class="rng-btn" id="rollD6Btn">d6</button>
            <button class="rng-btn" id="rollD20Btn">d20</button>
          </div>
          <div class="rng-output" id="rngOutput"></div>
        </div>

        <!-- GAME CONTROL (NEW GAME / CHANGE MODE / DEBUG THEME) -->
        <div class="tool-block">
          <div class="tool-block-label">Game Control</div>
          <div style="font-size:.7rem;line-height:1.3;" id="modeStatusText">Mode —</div>

          <div class="rng-row" style="gap:.5rem;">
            <button class="rng-btn" id="newGameBtn" style="min-width:6rem;">New Game</button>
            <button class="rng-btn" id="changeModeBtn" style="min-width:6rem;">Change Mode</button>
          </div>

          <div class="tool-block-label" style="text-transform:none;letter-spacing:0;font-size:.7rem;">
            Theme (backup)
          </div>
          <select id="themeSelect" class="theme-select">
            <option value="">Light</option>
            <option value="theme-dark">Dark</option>
            <option value="theme-neon">Neon</option>
          </select>
        </div>

      </div>
    </div>

    <!-- PLAYERS ACCORDION -->
    <div class="players-card" id="playersCard">
      <div class="players-head" id="playersHead">
        <div class="players-head-left">
          <div class="players-title">Other Players</div>
          <div class="players-hint">Life / status / commander damage / politics notes</div>
        </div>
        <div class="players-chevron" id="playersChevron">▲</div>
      </div>
      <div class="players-body" id="playersBody" style="display:none;"></div>
    </div>

  </div> <!-- /content-area -->

  <!-- RULES FOOTER -->
  <div class="rules-footer" id="rulesFooter">
    <div class="rules-footer-title">Rumble Rules</div>
Setup:
• 100-card singleton Commander decks, normal color identity.
• Everyone starts 40 life, 0 poison.
• You can still be permanently eliminated if:
  – You take 21+ combat damage from one commander.
  – You try to draw and cannot (decked out).

Temporary Death (Cooldown):
• If your life hits 0 or less, or you get 10+ poison, or an effect says “you lose the game,”
  you go on cooldown instead of leaving.
• “Win the game” effects do nothing in this mode.
• You get a cooldown value in turns.

Cooldown Turns:
• On each future turn where it would be you:
  1. You get a popup saying you're cooling down.
  2. You acknowledge. Your cooldownRemaining goes down by 1.
  3. If it’s still >0, you skip that turn completely.
  4. If it just hit 0, you immediately respawn and actually take this turn.

While Cooling Down:
• You aren’t an active player.
• You can’t cast/attack/block/respond/activate.
• You can’t be targeted as a player.
• Your board stays in play and can still be attacked/destroyed.
• Your zones (hand, exile, etc.) stay.
• Triggers that would need your decisions are ignored. Other static effects still sit there.

Respawn:
• You rejoin as active, cooldownRemaining = 0.
• Your life becomes the ceiling of the average life total of all current active players.
• Poison resets to 0.
• Commander tax resets.
• You keep anything you still own on the battlefield.
• Your first full turn back: skip normal draw step, then draw 1 at END of that turn.

Reigning Rumbler:
• If exactly one player is active and everyone else is cooling or eliminated,
  that player becomes the Reigning Rumbler.
• After that player completes their NEXT full turn and is still the only active player,
  they win the game.

Regular Mode:
• No cooldown. 0 life / 10 poison / “you lose the game” is just elimination.
• Last surviving player wins.
  </div>

</div> <!-- /app-shell -->

<script>
/* =========================================================
   GLOBAL STATE
========================================================= */
let gameMode = null; // "regular" | "rumble"
let players = [];
let turnIndex = 0;
let turnCounter = 0;
let gameStartTime = null;

let reigningCandidateIndex = null;
let reigningCandidateTurnStamp = null;

let winnerLocked = false;

let renderIntervalId = null;

let showingAnnounce = false;
let pendingClearAfterAnnounce = null;

/* plane/scheme global shared state */
let currentPlaneName   = "";
let currentPlaneText   = "";
let currentPlaneImg    = "";
let currentSchemeName  = "";
let currentSchemeText  = "";
let currentSchemeImg   = "";

/* DOM refs */
const setupOverlay         = document.getElementById("setupOverlay");
const setupStepMode        = document.getElementById("setupStepMode");
const setupStepPlayers     = document.getElementById("setupStepPlayers");
const manualPlayerCount    = document.getElementById("manualPlayerCount");
const manualStartBtn       = document.getElementById("manualStartBtn");

const announceOverlay      = document.getElementById("announceOverlay");
const announceMain         = document.getElementById("announceMain");
const announceBody         = document.getElementById("announceBody");
const announceOkBtn        = document.getElementById("announceOkBtn");

const winnerOverlay        = document.getElementById("winnerOverlay");
const winnerTitle          = document.getElementById("winnerTitle");
const winnerTimeLine       = document.getElementById("winnerTimeLine");
const winnerPlayerTimeLine = document.getElementById("winnerPlayerTimeLine");
const winnerCloseBtn       = document.getElementById("winnerCloseBtn");

const turnBanner           = document.getElementById("turnBanner");
const turnReminderExtra    = document.getElementById("turnReminderExtra");
const globalTimerBanner    = document.getElementById("globalTimerBanner");

const themeToggleBtn       = document.getElementById("themeToggleBtn");

const hudArea              = document.getElementById("hudArea");
const endTurnBtn           = document.getElementById("endTurnBtn");

const toolsCard            = document.getElementById("toolsCard");
const toolsHead            = document.getElementById("toolsHead");
const toolsChevron         = document.getElementById("toolsChevron");
const toolsBody            = document.getElementById("toolsBody");

const playersCard          = document.getElementById("playersCard");
const playersHead          = document.getElementById("playersHead");
const playersChevron       = document.getElementById("playersChevron");
const playersBody          = document.getElementById("playersBody");

const modeStatusText       = document.getElementById("modeStatusText");

const flipCoinBtn          = document.getElementById("flipCoinBtn");
const rollD6Btn            = document.getElementById("rollD6Btn");
const rollD20Btn           = document.getElementById("rollD20Btn");
const rngOutput            = document.getElementById("rngOutput");

const newGameBtn           = document.getElementById("newGameBtn");
const changeModeBtn        = document.getElementById("changeModeBtn");

const themeSelect          = document.getElementById("themeSelect");

/* lookups */
const globalLookupInput    = document.getElementById("globalLookupInput");
const globalLookupBtn      = document.getElementById("globalLookupBtn");
const globalViewerText     = document.getElementById("globalViewerText");
const globalViewerImgBox   = document.getElementById("globalViewerImgBox");
const globalViewerImg      = document.getElementById("globalViewerImg");

const dungeonInput         = document.getElementById("dungeonInput");
const dungeonBtn           = document.getElementById("dungeonBtn");
const dungeonViewerText    = document.getElementById("dungeonViewerText");
const dungeonViewerImgBox  = document.getElementById("dungeonViewerImgBox");
const dungeonViewerImg     = document.getElementById("dungeonViewerImg");

const emblemInput          = document.getElementById("emblemInput");
const emblemBtn            = document.getElementById("emblemBtn");
const emblemViewerText     = document.getElementById("emblemViewerText");
const emblemViewerImgBox   = document.getElementById("emblemViewerImgBox");
const emblemViewerImg      = document.getElementById("emblemViewerImg");

const dungeonProgressArea  = document.getElementById("dungeonProgressArea");
const emblemsArea          = document.getElementById("emblemsArea");

const planeInput           = document.getElementById("planeInput");
const planeBtn             = document.getElementById("planeBtn");
const planeViewerText      = document.getElementById("planeViewerText");
const planeViewerImgBox    = document.getElementById("planeViewerImgBox");
const planeViewerImg       = document.getElementById("planeViewerImg");

const schemeInput          = document.getElementById("schemeInput");
const schemeBtn            = document.getElementById("schemeBtn");
const schemeViewerText     = document.getElementById("schemeViewerText");
const schemeViewerImgBox   = document.getElementById("schemeViewerImgBox");
const schemeViewerImg      = document.getElementById("schemeViewerImg");

/* tracking accordion open state */
let toolsOpen = false;
let playersOpen = false;
/* per-player internal expand under "Other Players" */
let otherOpen = {};

/* =========================================================
   UTILITIES
========================================================= */
function msToClock(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins + ":" + (secs<10?("0"+secs):secs);
}
function formatDurationMs(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins+"m "+secs+"s";
}
function getGameElapsedMs(){
  if(!gameStartTime) return 0;
  return Date.now()-gameStartTime;
}
function getAvgActiveLifeCeil(excludeIndex){
  let sum=0;
  let ct=0;
  players.forEach((pl,i)=>{
    if(i===excludeIndex) return;
    if(pl.status==="active"){
      sum+=pl.life;
      ct++;
    }
  });
  if(ct===0){ return 1; }
  return Math.ceil(sum/ct);
}
function getSeatColor(i){
  const cols=["var(--gold)","var(--cyan)","var(--magenta)","var(--lime)"];
  return cols[i % cols.length];
}

/* =========================================================
   PLAYER OBJECT + TIMING
========================================================= */
function makePlayer(defaultName){
  return {
    name: defaultName,

    status:"active",          // "active"|"cooldown"|"eliminated"
    cooldownRemaining:0,

    life:40,
    poison:0,
    radiation:0,
    energy:0,
    experience:0,
    storm:0,

    notesText:"", // politics note (other players can edit theirs too)

    commanderTaxSteps:0,

    commanderDamage:[], // victim.commanderDamage[srcIdx] = dmg

    totalActiveMs:0,
    turnStartMs:null,
    isTiming:false,

    pendingEOTDraw:false, // respawn recovery draw at EOT

    // dungeon / emblem tracking (for tools panel based on active player)
    dungeonLookupName:"",
    dungeonPreviewText:"",
    dungeonPreviewImg:"",
    dungeonProgress:"",

    emblemLookupName:"",
    emblemPreviewText:"",
    emblemPreviewImg:"",
    emblemsText:""
  };
}
function syncCommanderDamageArrays(){
  players.forEach(p=>{
    while(p.commanderDamage.length < players.length){
      p.commanderDamage.push(0);
    }
    if(p.commanderDamage.length > players.length){
      p.commanderDamage.length = players.length;
    }
  });
}

/* time */
function startTimingPlayer(i){
  const p=players[i];
  if(!p || p.status!=="active") return;
  p.isTiming=true;
  p.turnStartMs=Date.now();
}
function stopTimingPlayer(i){
  const p=players[i];
  if(!p || !p.isTiming) return;
  const now=Date.now();
  const diff = now-(p.turnStartMs||now);
  p.totalActiveMs += diff;
  p.turnStartMs=null;
  p.isTiming=false;
}
function getPlayerTurnMs(p){
  if(p.isTiming && p.turnStartMs!=null){
    return Date.now()-p.turnStartMs;
  }
  return 0;
}
function getPlayerTotalMs(p){
  return p.totalActiveMs+getPlayerTurnMs(p);
}
function getActivePlayers(){
  const arr=[];
  players.forEach((pl,i)=>{
    if(pl.status==="active"){
      arr.push(i);
    }
  });
  return arr;
}

/* =========================================================
   ANNOUNCE MODAL HELPER
========================================================= */
function showAnnounce(mainTxt, bodyTxt, cb){
  showingAnnounce=true;
  announceMain.textContent = mainTxt;
  announceBody.textContent = bodyTxt;
  announceOverlay.style.display="flex";

  announceOkBtn.onclick = ()=>{
    announceOverlay.style.display="none";
    showingAnnounce=false;
    // clear pendingEOTDraw if needed
    if(pendingClearAfterAnnounce!==null){
      const pp=players[pendingClearAfterAnnounce];
      if(pp){
        pp.pendingEOTDraw=false;
      }
      pendingClearAfterAnnounce=null;
    }
    if(typeof cb==="function"){
      cb();
    }
  };
}

/* =========================================================
   KNOCKOUT / COOLDOWN / RESPAWN
========================================================= */
function permanentlyEliminate(i){
  const p=players[i];
  stopTimingPlayer(i);
  p.status="eliminated";
  p.cooldownRemaining=0;
  p.pendingEOTDraw=false;
  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

function checkCommanderDamageElim(victimIdx){
  const p = players[victimIdx];
  for(let src=0; src<p.commanderDamage.length; src++){
    if(p.commanderDamage[src] >= 21){
      permanentlyEliminate(victimIdx);
      break;
    }
  }
}

function knockOutToCooldown(i){
  const p=players[i];

  if(gameMode==="regular"){
    permanentlyEliminate(i);
    showAnnounce(
      (p.name||("Player "+(i+1)))+" eliminated",
      "Regular Mode: 0 life / 10 poison / lose-the-game is permanent.",
      null
    );
    return;
  }

  if(p.status==="eliminated") return;
  if(p.status==="cooldown") return;

  stopTimingPlayer(i);

  let othersCooling=0;
  players.forEach((q,qi)=>{
    if(qi!==i && q.status==="cooldown") othersCooling++;
  });

  p.status="cooldown";
  p.cooldownRemaining=1+othersCooling;
  p.pendingEOTDraw=false;

  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }

  showAnnounce(
    (p.name||("Player "+(i+1)))+" knocked out",
    "Entered cooldown for "+p.cooldownRemaining+" turn(s). On each of their turns they just acknowledge and skip until cooldown hits 0.",
    null
  );
}

function respawnPlayer(i){
  const p=players[i];
  if(p.status!=="cooldown") return;

  const newLife=getAvgActiveLifeCeil(i);
  p.status="active";
  p.cooldownRemaining=0;
  p.poison=0;
  p.life=newLife;
  p.commanderTaxSteps=0;
  p.pendingEOTDraw=true;

  showAnnounce(
    (p.name||("Player "+(i+1)))+" respawned",
    "Life "+newLife+" (avg rounded up), poison = 0, commander tax reset.\nOn this first full turn back: skip normal draw step; instead draw 1 at END of turn.",
    null
  );
}

function lethalCheck(i,source){
  const p=players[i];
  if(!p) return;
  if(source==="life" && p.life<=0){
    knockOutToCooldown(i);
    return;
  }
  if(source==="poison" && p.poison>=10){
    knockOutToCooldown(i);
    return;
  }
}

/* admin cycle status chip tap */
function cycleStatusAdmin(i){
  const p=players[i];
  if(gameMode==="rumble"){
    if(p.status==="active"){
      knockOutToCooldown(i);
    }else if(p.status==="cooldown"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction.",
        null
      );
    }else{ // eliminated -> active
      p.status="active";
      p.cooldownRemaining=0;
      p.pendingEOTDraw=false;
    }
  }else{
    // regular: active <-> eliminated
    if(p.status==="active"){
      permanentlyEliminate(i);
      showAnnounce(
        (p.name||("Player "+(i+1)))+" eliminated",
        "Manual correction.",
        null
      );
    }else{
      p.status="active";
      p.cooldownRemaining=0;
      p.pendingEOTDraw=false;
    }
  }
  renderAll();
}

/* =========================================================
   REIGNING RUMBLER / WIN LOGIC
========================================================= */
function updateReigningCandidateOnTurnEnd(){
  if(gameMode!=="rumble" || winnerLocked) return;
  const actives=getActivePlayers();
  if(actives.length===1){
    const onlyIdx=actives[0];
    if(reigningCandidateIndex!==onlyIdx){
      reigningCandidateIndex=onlyIdx;
      reigningCandidateTurnStamp=turnCounter;
      showAnnounce(
        (players[onlyIdx].name||("Player "+(onlyIdx+1)))+" is now REIGNING RUMBLER",
        "If they remain the only active player through their next full turn, they win.",
        null
      );
    }
  }else{
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}
function checkReigningWin(){
  if(gameMode!=="rumble" || winnerLocked) return false;
  if(reigningCandidateIndex===null) return false;
  const actives=getActivePlayers();
  if(actives.length!==1) return false;
  const onlyIdx=actives[0];
  if(onlyIdx!==reigningCandidateIndex) return false;

  if(turnCounter>(reigningCandidateTurnStamp+1)){
    lockWinner(onlyIdx,true);
    return true;
  }
  return false;
}
function checkForWinRegular(){
  if(gameMode!=="regular" || winnerLocked) return false;
  const alive = players.filter(p=>p.status!=="eliminated");
  if(alive.length===1){
    const idx = players.indexOf(alive[0]);
    lockWinner(idx,false);
    return true;
  }
  return false;
}
function lockWinner(idx,isRumble){
  winnerLocked=true;
  const p=players[idx];
  const winnerName = p.name || ("Player "+(idx+1));
  const totalMs = Date.now()-gameStartTime;
  const activeMs = getPlayerTotalMs(p);

  if(isRumble){
    winnerTitle.textContent = winnerName.toUpperCase()+" — REIGNING RUMBLER!";
  } else {
    winnerTitle.textContent = winnerName+" wins the game!";
  }
  winnerTimeLine.textContent =
    "Global Time: "+formatDurationMs(totalMs);
  winnerPlayerTimeLine.textContent =
    "Winner Player Time: "+formatDurationMs(activeMs);

  winnerOverlay.style.display="flex";
}

/* =========================================================
   TURN FLOW
========================================================= */

/*
Turn resolution contract:

1. Active player taps End Turn.
   - Stop timing them.
   - If they had pendingEOTDraw (respawn bonus draw), remind now.
   - turnCounter++ because a real turn just ended.
   - Crown/check Reigning Rumbler.
   - Check win(s).

2. Move clockwise seat -> resolve seat:
   - If eliminated: skip to next (no turnCounter++).
   - If cooldown:
        Show popup: "cooling down, cooldownRemaining X".
        After ACK:
           cooldownRemaining -= 1
           If still >0:
             skip them, move to next seat (no turnCounter++).
           If now ==0:
             respawnPlayer(i) immediately.
             That player now takes an actual turn:
                startTimingPlayer(i), renderAll().
             (This counts as them being the "current" player WITHOUT extra turnCounter++)
   - If active:
        startTimingPlayer(i), renderAll().

Important: We DON'T increment turnCounter when we skip cooldown seats or eliminated seats.
We only increment turnCounter when we end an actual played turn (passTurn()).
*/

function runEndOfTurnDrawIfNeeded(idx){
  const p=players[idx];
  if(!p) return;
  if(p.pendingEOTDraw){
    pendingClearAfterAnnounce = idx;
    showAnnounce(
      (p.name||("Player "+(idx+1)))+" draw reminder",
      "Draw 1 card now. This is your respawn recovery draw because you skipped your draw step this turn.",
      function(){}
    );
  }
}

function rotateClockwiseIndex(i){
  if(players.length===0) return i;
  return (i+1)%players.length;
}

function advanceTurnCore(){
  // safety to avoid infinite loop
  let safety=0;
  while(safety<50){
    safety++;

    const p=players[turnIndex];
    if(!p){
      turnIndex=rotateClockwiseIndex(turnIndex);
      continue;
    }

    if(p.status==="eliminated"){
      turnIndex=rotateClockwiseIndex(turnIndex);
      continue;
    }

    if(p.status==="cooldown"){
      return handleCooldownSeat(turnIndex);
    }

    // ACTIVE seat. start timing unless winnerLocked
    if(!winnerLocked){
      startTimingPlayer(turnIndex);
    }
    renderAll();
    return;
  }
  console.warn("advanceTurnCore safety stop");
  renderAll();
}

/* cooldown seat handling */
function handleCooldownSeat(i){
  const p = players[i];
  if(!p){
    turnIndex=rotateClockwiseIndex(i);
    return advanceTurnCore();
  }

  if(p.cooldownRemaining>0){
    // show popup that they do nothing this turn
    showAnnounce(
      (p.name||("Player "+(i+1)))+" is cooling down",
      "Cooldown remaining: "+p.cooldownRemaining+" turn(s). Tap OK to continue.",
      function afterAck(){
        p.cooldownRemaining -=1;
        if(p.cooldownRemaining>0){
          // still cooling, skip to next
          turnIndex=rotateClockwiseIndex(i);
          return advanceTurnCore();
        }else{
          // cooldown just hit 0 -> respawn NOW and this same seat actually takes a turn
          respawnPlayer(i);
          if(!winnerLocked){
            startTimingPlayer(i);
          }
          renderAll();
        }
      }
    );
    return;
  } else {
    // edge case: marked cooldown but already 0
    respawnPlayer(i);
    if(!winnerLocked){
      startTimingPlayer(i);
    }
    renderAll();
  }
}

function passTurn(){
  if(winnerLocked){
    renderAll();
    return;
  }

  // stop timing current
  stopTimingPlayer(turnIndex);

  // end-of-turn draw reminder for respawn-turn players
  runEndOfTurnDrawIfNeeded(turnIndex);

  // just finished a REAL turn -> increment global turnCounter
  turnCounter += 1;

  // Reigning Rumbler crown check
  if(gameMode==="rumble"){
    updateReigningCandidateOnTurnEnd();
  }

  // Win checks
  if(gameMode==="regular" && checkForWinRegular()){
    renderAll();
    return;
  }
  if(checkReigningWin()){
    renderAll();
    return;
  }

  // next seat
  turnIndex = rotateClockwiseIndex(turnIndex);
  advanceTurnCore();
}

/* =========================================================
   SCRYFALL LOOKUPS
   - robust-ish, offline tolerant
========================================================= */
function pickCardImage(card){
  if(card?.image_uris?.normal) return card.image_uris.normal;
  if(Array.isArray(card?.card_faces)){
    for(const face of card.card_faces){
      if(face?.image_uris?.normal){
        return face.image_uris.normal;
      }
    }
  }
  return "";
}
async function scryfallFetch(url){
  try{
    const resp = await fetch(url);
    if(!resp.ok) return null;
    return await resp.json();
  }catch(e){
    return null;
  }
}

/* general helper that tries context search first, then fuzzy fallback */
async function smartContextSearch(query, context){
  if(!query || !query.trim()) return {error:"Enter a name first."};
  const base="https://api.scryfall.com";

  let primaryURL;
  let cardFilter = null;

  if(context==="dungeon"){
    primaryURL = base+"/cards/search?q=type%3ADungeon+"+encodeURIComponent(query);
    cardFilter = c=> (c.layout==="dungeon" || /Dungeon/i.test(c.type_line||""));
  }else if(context==="emblem"){
    primaryURL = base+"/cards/search?q=layout%3Aemblem+"+encodeURIComponent(query);
    cardFilter = c=> (c.layout==="emblem");
  }else if(context==="plane"){
    primaryURL = base+"/cards/search?q=(type%3APlane+OR+type%3APhenomenon)+"+encodeURIComponent(query);
    cardFilter = c=> (/Plane|Phenomenon/i.test(c.type_line||""));
  }else if(context==="scheme"){
    primaryURL = base+"/cards/search?q=type%3AScheme+"+encodeURIComponent(query);
    cardFilter = c=> (/Scheme/i.test(c.type_line||""));
  }else{
    // global / fallback
    primaryURL = base+"/cards/named?fuzzy="+encodeURIComponent(query);
  }

  // 1. try primary
  let data = await scryfallFetch(primaryURL);

  // If we got an array, pick match or first
  let card = null;
  if(data && Array.isArray(data.data) && data.data.length){
    if(cardFilter){
      const filtered = data.data.find(cardFilter);
      if(filtered) card = filtered;
    }
    if(!card) card = data.data[0];
  }else if(data && !Array.isArray(data.data) && !data.object?.includes("error")){
    // single-card style
    card = data;
  }

  // if we still failed OR card doesn't match filter, fallback to fuzzy named
  if((!card || (cardFilter && !cardFilter(card))) && context!=="global"){
    const fallbackURL = base+"/cards/named?fuzzy="+encodeURIComponent(query);
    let data2 = await scryfallFetch(fallbackURL);
    if(data2 && !data2.object?.includes("error")){
      // accept fallback if matches filter (or no filter)
      if(!cardFilter || cardFilter(data2)){
        card = data2;
      }
    }
  }

  if(!card || card.object==="error"){
    return {error:"Not found / offline."};
  }

  return {
    name:card.name||query.trim(),
    type:card.type_line||"",
    text:card.oracle_text||"(No rules text)",
    image:pickCardImage(card)
  };
}

/* hook up individual lookups -------------------------------- */
async function runGlobalLookup(){
  const q=globalLookupInput.value||"";
  const res=await smartContextSearch(q,"global");
  if(res.error){
    globalViewerText.textContent=res.error;
    globalViewerImgBox.style.display="none";
    globalViewerImg.removeAttribute("src");
    return;
  }
  globalViewerText.textContent=
    (res.type?res.type+"\n":"")+res.text;
  if(res.image){
    globalViewerImg.src=res.image;
    globalViewerImgBox.style.display="block";
  }else{
    globalViewerImgBox.style.display="none";
    globalViewerImg.removeAttribute("src");
  }
}

/* for current active player dungeon helper */
async function runDungeonLookup(){
  const p=players[turnIndex];
  if(!p)return;
  const q=dungeonInput.value||"";
  const res=await smartContextSearch(q,"dungeon");
  if(res.error){
    p.dungeonPreviewText=res.error;
    p.dungeonPreviewImg="";
  }else{
    p.dungeonPreviewText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    p.dungeonPreviewImg  = res.image||"";

    // seed dungeonProgress if not present
    if(p.dungeonProgress.toLowerCase().indexOf(res.name.toLowerCase())===-1){
      p.dungeonProgress += (p.dungeonProgress? "\n":"")+"Dungeon: "+res.name;
    }
  }
  renderAll(); // will push text/img into UI
}
async function runEmblemLookup(){
  const p=players[turnIndex];
  if(!p)return;
  const q=emblemInput.value||"";
  const res=await smartContextSearch(q,"emblem");
  if(res.error){
    p.emblemPreviewText=res.error;
    p.emblemPreviewImg="";
  }else{
    p.emblemPreviewText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    p.emblemPreviewImg  = res.image||"";

    if(p.emblemsText.toLowerCase().indexOf(res.name.toLowerCase())===-1){
      p.emblemsText += (p.emblemsText? "\n":"")+"Emblem: "+res.name+" — "+res.text;
    }
  }
  renderAll();
}

/* plane/scheme shared to entire table */
async function runPlaneLookup(){
  const q=planeInput.value||"";
  const res=await smartContextSearch(q,"plane");
  if(res.error){
    currentPlaneText=res.error;
    currentPlaneImg="";
  }else{
    currentPlaneText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    currentPlaneImg  = res.image||"";
    currentPlaneName = res.name;
  }
  renderAll();
}
async function runSchemeLookup(){
  const q=schemeInput.value||"";
  const res=await smartContextSearch(q,"scheme");
  if(res.error){
    currentSchemeText=res.error;
    currentSchemeImg="";
  }else{
    currentSchemeText = res.name+(res.type?("\n"+res.type):"")+(res.text?("\n"+res.text):"");
    currentSchemeImg  = res.image||"";
    currentSchemeName = res.name;
  }
  renderAll();
}

/* =========================================================
   RENDER HELPERS
========================================================= */
function renderGlobalTimerBanner(){
  globalTimerBanner.textContent = "Global: "+msToClock(getGameElapsedMs());
}
function renderTimersOnly(){
  renderGlobalTimerBanner();

  const p=players[turnIndex];
  if(p){
    const turnVal = document.querySelector(".timer-turn-val");
    const plVal   = document.querySelector(".timer-player-val");
    if(turnVal) turnVal.textContent = msToClock(getPlayerTurnMs(p));
    if(plVal)   plVal.textContent   = msToClock(getPlayerTotalMs(p));
  }

  // also update playerTime lines in playersBody
  players.forEach((pl,i)=>{
    if(i===turnIndex) return;
    const node=document.querySelector(`.player-time-val[data-idx="${i}"]`);
    if(node){
      node.textContent = msToClock(getPlayerTotalMs(pl));
    }
  });
}

/* HUD */
function renderHUD(){
  hudArea.innerHTML="";
  const p=players[turnIndex];
  if(!p)return;

  // reminder (skip draw etc) goes in turnReminderExtra
  if(p.pendingEOTDraw){
    turnReminderExtra.style.display="block";
    turnReminderExtra.textContent="Skip draw step this turn; draw 1 at END of turn.";
  }else{
    turnReminderExtra.style.display="none";
    turnReminderExtra.textContent="";
  }

  const card=document.createElement("div");
  card.className="hud-card glow-border";
  const seatColor=getSeatColor(turnIndex);
  card.style.borderColor=seatColor;
  card.style.boxShadow=
    `0 0 20px ${seatColor}66,0 30px 60px rgba(0,0,0,.35)`;

  const topRow=document.createElement("div");
  topRow.className="hud-top-row";

  /* LEFT COL */
  const leftCol=document.createElement("div");
  leftCol.className="hud-col";

  const nameBlock=document.createElement("div");
  nameBlock.className="section-block-inline";

  const nmLabel=document.createElement("div");
  nmLabel.className="label-sm";
  nmLabel.textContent="Your Name";

  const nmInput=document.createElement("input");
  nmInput.className="text-input";
  nmInput.value=p.name;
  nmInput.addEventListener("input",e=>{
    p.name=e.target.value;
  });
  nmInput.addEventListener("blur",()=>{ renderAll(); });
  nmInput.addEventListener("keydown",ev=>{
    if(ev.key==="Enter"){
      ev.preventDefault();
      nmInput.blur();
    }
  });

  // status row
  const statusWrap=document.createElement("div");
  statusWrap.className="tiny-row";

  const stChip=document.createElement("div");
  stChip.className="status-chip "+
    (p.status==="active"?"status-active":
     p.status==="cooldown"?"status-cooldown":
     "status-elim");
  stChip.textContent=
    p.status==="active"?"ACTIVE":
    p.status==="cooldown"?"COOLDOWN":
    "ELIMINATED";
  stChip.title=(gameMode==="rumble")
    ?"Tap to correct: Active ↔ Cooldown ↔ Eliminated"
    :"Tap to correct: Active ↔ Eliminated";
  stChip.addEventListener("click",()=>cycleStatusAdmin(turnIndex));
  statusWrap.appendChild(stChip);

  if(p.status==="cooldown" && gameMode==="rumble"){
    const cdDiv=document.createElement("div");
    cdDiv.className="cd-info-inline";

    const cdLab=document.createElement("div");
    cdLab.className="cd-label";
    cdLab.textContent="Cooldown:";

    const cdVal=document.createElement("div");
    cdVal.className="cd-val-box";
    cdVal.textContent=p.cooldownRemaining;

    cdDiv.appendChild(cdLab);
    cdDiv.appendChild(cdVal);
    statusWrap.appendChild(cdDiv);
  }

  // timers row
  const timeRow=document.createElement("div");
  timeRow.className="timer-row";

  const blockTurn=document.createElement("div");
  blockTurn.className="timer-block";
  const labTurn=document.createElement("div");
  labTurn.className="timer-label";
  labTurn.textContent="Turn Time";
  const valTurn=document.createElement("div");
  valTurn.className="timer-val timer-turn-val";
  valTurn.textContent=msToClock(getPlayerTurnMs(p));
  blockTurn.appendChild(labTurn);
  blockTurn.appendChild(valTurn);

  const blockPlayer=document.createElement("div");
  blockPlayer.className="timer-block";
  const labPlayer=document.createElement("div");
  labPlayer.className="timer-label";
  labPlayer.textContent="Player Time";
  const valPlayer=document.createElement("div");
  valPlayer.className="timer-val timer-player-val";
  valPlayer.textContent=msToClock(getPlayerTotalMs(p));
  blockPlayer.appendChild(labPlayer);
  blockPlayer.appendChild(valPlayer);

  timeRow.appendChild(blockTurn);
  timeRow.appendChild(blockPlayer);

  // Commander Tax
  const taxRow=document.createElement("div");
  taxRow.className="tax-row";

  const taxLabel=document.createElement("div");
  taxLabel.className="tax-label";
  taxLabel.textContent="Commander Tax: +2 ×";

  const taxCtrl=document.createElement("div");
  taxCtrl.className="tax-ctrl";

  const taxMinus=document.createElement("div");
  taxMinus.className="tax-btn";
  taxMinus.textContent="-";
  taxMinus.addEventListener("click",()=>{
    if(p.commanderTaxSteps>0)p.commanderTaxSteps--;
    renderAll();
  });
  const taxVal=document.createElement("div");
  taxVal.className="tax-val";
  taxVal.textContent=p.commanderTaxSteps;
  const taxPlus=document.createElement("div");
  taxPlus.className="tax-btn";
  taxPlus.textContent="+";
  taxPlus.addEventListener("click",()=>{
    p.commanderTaxSteps++;
    renderAll();
  });

  taxCtrl.appendChild(taxMinus);
  taxCtrl.appendChild(taxVal);
  taxCtrl.appendChild(taxPlus);

  taxRow.appendChild(taxLabel);
  taxRow.appendChild(taxCtrl);

  nameBlock.appendChild(nmLabel);
  nameBlock.appendChild(nmInput);
  nameBlock.appendChild(statusWrap);
  nameBlock.appendChild(timeRow);
  nameBlock.appendChild(taxRow);

  if(p.pendingEOTDraw){
    const reminder=document.createElement("div");
    reminder.className="respawn-draw-banner";
    reminder.textContent="Respawn Turn: Skip draw step. Draw 1 at END of turn.";
    nameBlock.appendChild(reminder);
  }

  leftCol.appendChild(nameBlock);

  /* RIGHT COL */
  const rightCol=document.createElement("div");
  rightCol.className="hud-col";

  const vitalsBlock=document.createElement("div");
  vitalsBlock.className="section-block-inline vitalsBlock";

  const lfLabel=document.createElement("div");
  lfLabel.className="label-sm";
  lfLabel.textContent="Life Total";

  const lfRow=document.createElement("div");
  lfRow.className="life-row";

  const minusBtn=document.createElement("div");
  minusBtn.className="life-btn";
  minusBtn.textContent="-";
  minusBtn.addEventListener("click",()=>{
    p.life = p.life-1;
    lethalCheck(turnIndex,"life");
    renderAll();
  });

  const lifeVal=document.createElement("div");
  lifeVal.className="life-value";
  lifeVal.textContent=p.life;

  const plusBtn=document.createElement("div");
  plusBtn.className="life-btn";
  plusBtn.textContent="+";
  plusBtn.addEventListener("click",()=>{
    p.life = p.life+1;
    renderAll();
  });

  lfRow.appendChild(minusBtn);
  lfRow.appendChild(lifeVal);
  lfRow.appendChild(plusBtn);

  const grid=document.createElement("div");
  grid.className="mini-counters-grid";

  grid.appendChild(makeSubStepper("☠ Poison",p.poison,(val)=>{
    p.poison=val;
    lethalCheck(turnIndex,"poison");
    renderAll();
  }));
  grid.appendChild(makeSubStepper("☢ Rad",p.radiation,(val)=>{
    p.radiation=val;
    renderAll();
  }));
  grid.appendChild(makeSubStepper("⚡ Energy",p.energy,(val)=>{
    p.energy=val;
    renderAll();
  }));
  grid.appendChild(makeSubStepper("★ Exp",p.experience,(val)=>{
    p.experience=val;
    renderAll();
  }));
  grid.appendChild(makeSubStepper("☁ Storm",p.storm,(val)=>{
    p.storm=val;
    renderAll();
  }));

  vitalsBlock.appendChild(lfLabel);
  vitalsBlock.appendChild(lfRow);
  vitalsBlock.appendChild(grid);
  rightCol.appendChild(vitalsBlock);

  topRow.appendChild(leftCol);
  topRow.appendChild(rightCol);
  card.appendChild(topRow);

  hudArea.appendChild(card);

  /* also sync dungeon/emblem/plane/scheme viewers for active player into tools panel fields */
  dungeonInput.value = p.dungeonLookupName||"";
  dungeonViewerText.textContent = p.dungeonPreviewText||"";
  if(p.dungeonPreviewImg){
    dungeonViewerImg.src=p.dungeonPreviewImg;
    dungeonViewerImgBox.style.display="block";
  }else{
    dungeonViewerImgBox.style.display="none";
    dungeonViewerImg.removeAttribute("src");
  }

  emblemInput.value = p.emblemLookupName||"";
  emblemViewerText.textContent = p.emblemPreviewText||"";
  if(p.emblemPreviewImg){
    emblemViewerImg.src=p.emblemPreviewImg;
    emblemViewerImgBox.style.display="block";
  }else{
    emblemViewerImgBox.style.display="none";
    emblemViewerImg.removeAttribute("src");
  }

  dungeonProgressArea.value = p.dungeonProgress||"";
  emblemsArea.value         = p.emblemsText||"";

  planeInput.value = currentPlaneName||"";
  planeViewerText.textContent = currentPlaneText||"";
  if(currentPlaneImg){
    planeViewerImg.src=currentPlaneImg;
    planeViewerImgBox.style.display="block";
  }else{
    planeViewerImgBox.style.display="none";
    planeViewerImg.removeAttribute("src");
  }

  schemeInput.value = currentSchemeName||"";
  schemeViewerText.textContent = currentSchemeText||"";
  if(currentSchemeImg){
    schemeViewerImg.src=currentSchemeImg;
    schemeViewerImgBox.style.display="block";
  }else{
    schemeViewerImgBox.style.display="none";
    schemeViewerImg.removeAttribute("src");
  }

  modeStatusText.textContent =
    (gameMode==="regular"?"Mode 1 — Regular":"Mode 2 — Rumble");
}

function makeSubStepper(label,val,onSet){
  const box=document.createElement("div");
  box.className="sub-box";

  const l=document.createElement("div");
  l.className="sub-box-label";
  l.textContent=label;

  const row=document.createElement("div");
  row.className="sub-box-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1; if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1; if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);

  box.appendChild(l);
  box.appendChild(row);
  return box;
}

/* PLAYERS ACCORDION BODY */
function renderPlayers(){
  playersBody.innerHTML="";

  playersChevron.textContent = playersOpen?"▲":"▼";
  playersBody.style.display = playersOpen?"flex":"none";

  players.forEach((pl,i)=>{
    if(i===turnIndex) return; // hide self from "Other Players"

    const block=document.createElement("div");
    block.className="other-player-block";

    const top=document.createElement("div");
    top.className="other-top-row";

    const topLeft=document.createElement("div");
    topLeft.className="other-top-left";

    const nm=pl.name||("Player "+(i+1));
    const nmEl=document.createElement("div");
    nmEl.className="other-top-name";
    nmEl.textContent=nm;
    topLeft.appendChild(nmEl);

    // status/time subline
    const subline=document.createElement("div");
    subline.className="other-top-subline";

    let stChunk="Status: "+pl.status.toUpperCase();
    if(pl.status==="cooldown" && gameMode==="rumble"){
      stChunk+=" ("+pl.cooldownRemaining+")";
    }
    const stSpan=document.createElement("span");
    stSpan.textContent=stChunk;
    subline.appendChild(stSpan);

    const tSpan=document.createElement("span");
    tSpan.className="player-time-val";
    tSpan.setAttribute("data-idx",i);
    tSpan.textContent="Time "+msToClock(getPlayerTotalMs(pl));
    subline.appendChild(tSpan);

    topLeft.appendChild(subline);

    const chev=document.createElement("div");
    chev.className="other-chevron";
    const isOpen=!!otherOpen[i];
    chev.textContent=isOpen?"▲":"▼";

    top.appendChild(topLeft);
    top.appendChild(chev);

    const body=document.createElement("div");
    body.className="other-body";
    body.style.display=isOpen?"flex":"none";

    // vitals
    const inlineVitals=document.createElement("div");
    inlineVitals.className="inline-row-wrap";

    // Life edit
    const lifeCol=document.createElement("div");
    lifeCol.className="inline-col";

    const lifeLab=document.createElement("div");
    lifeLab.className="inline-col-label";
    lifeLab.textContent="Life Total ("+nm+")";

    const lifeRow=document.createElement("div");
    lifeRow.className="inline-life-row";

    const minusBtn=document.createElement("div");
    minusBtn.className="step-btn";
    minusBtn.textContent="-";
    minusBtn.addEventListener("click",()=>{
      pl.life=pl.life-1;
      lethalCheck(i,"life");
      renderAll();
    });

    const lifeVal=document.createElement("div");
    lifeVal.className="inline-life-val";
    lifeVal.textContent=pl.life;

    const plusBtn=document.createElement("div");
    plusBtn.className="step-btn";
    plusBtn.textContent="+";
    plusBtn.addEventListener("click",()=>{
      pl.life=pl.life+1;
      renderAll();
    });

    lifeRow.appendChild(minusBtn);
    lifeRow.appendChild(lifeVal);
    lifeRow.appendChild(plusBtn);
    lifeCol.appendChild(lifeLab);
    lifeCol.appendChild(lifeRow);

    // Poison / Rad / Exp / Storm steppers
    const countersCol=document.createElement("div");
    countersCol.className="inline-col";

    const countersLab=document.createElement("div");
    countersLab.className="inline-col-label";
    countersLab.textContent="Counters ("+nm+")";

    const ctrRow=document.createElement("div");
    ctrRow.className="inline-row-wrap";

    ctrRow.appendChild(smallStepper("☠ Poison",pl.poison,(v)=>{
      pl.poison=v;
      lethalCheck(i,"poison");
      renderAll();
    }));
    ctrRow.appendChild(smallStepper("☢ Rad",pl.radiation,(v)=>{
      pl.radiation=v;
      renderAll();
    }));
    ctrRow.appendChild(smallStepper("★ Exp",pl.experience,(v)=>{
      pl.experience=v;
      renderAll();
    }));
    ctrRow.appendChild(smallStepper("☁ Storm",pl.storm,(v)=>{
      pl.storm=v;
      renderAll();
    }));

    countersCol.appendChild(countersLab);
    countersCol.appendChild(ctrRow);

    inlineVitals.appendChild(lifeCol);
    inlineVitals.appendChild(countersCol);
    body.appendChild(inlineVitals);

    // Commander Damage
    const cdmg=document.createElement("div");
    cdmg.className="cdmg-wrap";

    const cdmgHead=document.createElement("div");
    cdmgHead.className="cdmg-head";
    cdmgHead.textContent="Commander Damage Taken by "+nm+" (21 from one source = elim)";
    cdmg.appendChild(cdmgHead);

    const cdmgGrid=document.createElement("div");
    cdmgGrid.className="cdmg-grid";

    players.forEach((srcPl,srcIdx)=>{
      const srcName=srcPl.name||("P"+(srcIdx+1));
      const cell=document.createElement("div");
      cell.className="cdmg-cell";

      const label=document.createElement("div");
      label.className="cdmg-cell-label";
      label.textContent="from "+srcName;

      const row=document.createElement("div");
      row.className="cdmg-input-row";

      const dmgIn=document.createElement("input");
      dmgIn.type="number";
      dmgIn.min="0";
      dmgIn.value=pl.commanderDamage[srcIdx]||0;
      dmgIn.addEventListener("input",e=>{
        let v=parseInt(e.target.value,10);
        if(isNaN(v)||v<0)v=0;
        pl.commanderDamage[srcIdx]=v;
        checkCommanderDamageElim(i);
        renderAll();
      });

      row.appendChild(dmgIn);
      cell.appendChild(label);
      cell.appendChild(row);
      cdmgGrid.appendChild(cell);
    });
    cdmg.appendChild(cdmgGrid);
    body.appendChild(cdmg);

    // Politics Note
    const noteWrap=document.createElement("div");
    noteWrap.className="inline-col";
    const noteLab=document.createElement("div");
    noteLab.className="inline-col-label";
    noteLab.textContent="Note on "+nm+" (Deals, Goaded, 'don't hit me', etc.)";
    const noteTa=document.createElement("textarea");
    noteTa.className="notes-area";
    noteTa.value=pl.notesText;
    noteTa.addEventListener("input",e=>{
      pl.notesText=e.target.value;
    });
    noteWrap.appendChild(noteLab);
    noteWrap.appendChild(noteTa);
    body.appendChild(noteWrap);

    top.addEventListener("click",()=>{
      otherOpen[i]=!otherOpen[i];
      renderPlayers();
    });

    block.appendChild(top);
    block.appendChild(body);
    playersBody.appendChild(block);
  });
}

function smallStepper(labelText,val,onSet){
  const container=document.createElement("div");
  container.style.display="flex";
  container.style.flexDirection="column";
  container.style.gap=".4rem";
  container.style.minWidth="6rem";

  const lab=document.createElement("div");
  lab.className="player-stepper-label";
  lab.textContent=labelText;

  const row=document.createElement("div");
  row.className="player-stepper-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1; if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1; if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);
  container.appendChild(lab);
  container.appendChild(row);
  return container;
}

/* FULL RENDER */
function renderAll(){
  syncCommanderDamageArrays();

  const cur=players[turnIndex]||{};
  const nm=cur.name||("Player "+(turnIndex+1));
  turnBanner.textContent="▶ "+nm.toUpperCase()+"'S TURN ◀";

  renderHUD();
  renderPlayers();
  renderGlobalTimerBanner();

  // update backup themeSelect label text to actual current body class
  const bodyClass = document.body.classList.contains("theme-neon")
    ?"theme-neon"
    :document.body.classList.contains("theme-dark")
      ?"theme-dark"
      :"";
  themeSelect.value = bodyClass;
  themeToggleBtn.textContent =
    bodyClass==="theme-neon" ? "Neon" :
    bodyClass==="theme-dark" ? "Dark" : "Light";
}

/* =========================================================
   SETUP / MODE
========================================================= */
function resetGameStateKeepMode(){
  players=[];
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  otherOpen={};

  // reset plane/scheme text
  currentPlaneName   ="";
  currentPlaneText   ="";
  currentPlaneImg    ="";
  currentSchemeName  ="";
  currentSchemeText  ="";
  currentSchemeImg   ="";
}
function showModeStep(){
  resetGameStateKeepMode();
  gameMode=null;
  setupStepMode.style.display="flex";
  setupStepPlayers.style.display="none";
  setupOverlay.style.display="flex";
}
function showPlayerCountStep(){
  resetGameStateKeepMode();
  setupStepMode.style.display="none";
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

setupStepMode.querySelectorAll("[data-mode]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const m=btn.getAttribute("data-mode");
    gameMode = (m==="regular")?"regular":"rumble";
    showPlayerCountStep();
  });
});

setupStepPlayers.querySelectorAll("[data-fixedplayers]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const n=parseInt(btn.getAttribute("data-fixedplayers"),10);
    startGameWith(n);
  });
});
manualStartBtn.addEventListener("click",()=>{
  let n=parseInt(manualPlayerCount.value,10);
  if(isNaN(n)||n<2)n=2;
  if(n>8)n=8;
  startGameWith(n);
});

function startGameWith(nPlayers){
  players=[];
  for(let i=0;i<nPlayers;i++){
    players.push(makePlayer("Player "+(i+1)));
  }

  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;

  gameStartTime=Date.now();

  syncCommanderDamageArrays();
  setupOverlay.style.display="none";

  // start first player's timer if active
  if(players[0] && players[0].status==="active"){
    startTimingPlayer(0);
  }

  toolsOpen=false;
  playersOpen=false;

  renderAll();

  if(renderIntervalId){
    clearInterval(renderIntervalId);
  }
  renderIntervalId=setInterval(()=>{
    if(!winnerLocked){
      renderTimersOnly();
    }
  },1000);
}

/* =========================================================
   EVENT LISTENERS
========================================================= */

/* End Turn */
endTurnBtn.addEventListener("click",()=>{ passTurn(); });

/* Winner close */
winnerCloseBtn.addEventListener("click",()=>{
  winnerOverlay.style.display="none";
});

/* Tools accordion */
toolsHead.addEventListener("click",()=>{
  toolsOpen=!toolsOpen;
  toolsBody.style.display = toolsOpen?"flex":"none";
  toolsChevron.textContent = toolsOpen?"▲":"▼";
});

/* Players accordion */
playersHead.addEventListener("click",()=>{
  playersOpen=!playersOpen;
  renderPlayers();
});

/* Randomizers */
flipCoinBtn.addEventListener("click",()=>{
  rngOutput.textContent="Coin: "+(Math.random()<0.5?"Heads":"Tails");
});
rollD6Btn.addEventListener("click",()=>{
  rngOutput.textContent="d6: "+(Math.floor(Math.random()*6)+1);
});
rollD20Btn.addEventListener("click",()=>{
  rngOutput.textContent="d20: "+(Math.floor(Math.random()*20)+1);
});

/* Theme dropdown (backup) */
themeSelect.addEventListener("change",()=>{
  document.body.classList.remove("theme-dark","theme-neon");
  const val=themeSelect.value;
  if(val){
    document.body.classList.add(val);
  }
  renderAll();
});

/* Theme toggle button in header (cycles Light -> Dark -> Neon -> Light) */
themeToggleBtn.addEventListener("click",()=>{
  const body=document.body;
  if(body.classList.contains("theme-neon")){
    body.classList.remove("theme-neon");
    body.classList.remove("theme-dark");
  }else if(body.classList.contains("theme-dark")){
    body.classList.remove("theme-dark");
    body.classList.add("theme-neon");
  }else{
    body.classList.add("theme-dark");
  }
  renderAll();
});

/* New game / change mode */
newGameBtn.addEventListener("click",()=>{
  if(!confirm("Start a new game in the same mode? This clears all data.")) return;
  showPlayerCountStep();
});
changeModeBtn.addEventListener("click",()=>{
  if(!confirm("Change mode? This restarts the game.")) return;
  showModeStep();
});

/* Global card lookup */
globalLookupBtn.addEventListener("click",()=>{
  runGlobalLookup();
});

/* Dungeon/emblem lookups for active player */
dungeonBtn.addEventListener("click",()=>{
  const p=players[turnIndex];
  if(p){ p.dungeonLookupName=dungeonInput.value||""; }
  runDungeonLookup();
});
emblemBtn.addEventListener("click",()=>{
  const p=players[turnIndex];
  if(p){ p.emblemLookupName=emblemInput.value||""; }
  runEmblemLookup();
});

/* player dungeonProgress / emblemsText persistence */
dungeonProgressArea.addEventListener("input",e=>{
  const p=players[turnIndex];
  if(p){
    p.dungeonProgress=e.target.value;
  }
});
emblemsArea.addEventListener("input",e=>{
  const p=players[turnIndex];
  if(p){
    p.emblemsText=e.target.value;
  }
});

/* plane / scheme lookups */
planeBtn.addEventListener("click",()=>{
  currentPlaneName = planeInput.value||"";
  runPlaneLookup();
});
schemeBtn.addEventListener("click",()=>{
  currentSchemeName = schemeInput.value||"";
  runSchemeLookup();
});

/* =========================================================
   INIT
========================================================= */
showModeStep();
renderAll();
</script>
</body>
</html>