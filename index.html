<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>EDH RUMBLE TRACKER v16</title>
<style>
/* THEME VARS */
:root {
  --bg-main:#0f0f12;
  --bg-panel:#1a1a22;
  --bg-accent:#2a2a36;
  --border-soft:#3a3a4f;

  --text-primary:#f5f5fa;
  --text-dim:#8a8aa5;

  --gold:#d4a94f;
  --cyan:#5fd8d8;
  --magenta:#ff4acb;
  --lime:#5fd85f;
  --red:#d85f5f;
  --off:#55556e;

  --button-bg:#2a2a36;
  --button-border:#3a3a4f;

  --overlay-bg:rgba(0,0,0,0.8);

  --tool-bg:#1a1a22;
  --tool-border:#3a3a4f;
}

.theme-light {
  --bg-main:#ffffff;
  --bg-panel:#ffffff;
  --bg-accent:#f4f4fa;
  --border-soft:#bfbfd4;

  --text-primary:#1a1a22;
  --text-dim:#5a5a77;

  --gold:#9c7a1f;
  --cyan:#2a8f8f;
  --magenta:#b51882;
  --lime:#2a8f2a;
  --red:#a63f3f;
  --off:#8a8aa5;

  --button-bg:#ffffff;
  --button-border:#bfbfd4;

  --overlay-bg:rgba(0,0,0,0.6);

  --tool-bg:#ffffff;
  --tool-border:#bfbfd4;
}

.theme-neon {
  --bg-main:#050509;
  --bg-panel:#0e0e1a;
  --bg-accent:#1a1a33;
  --border-soft:#4a4aff;

  --text-primary:#ffeefe;
  --text-dim:#ff4aeb;

  --gold:#ffef5a;
  --cyan:#5fd8ff;
  --magenta:#ff4acb;
  --lime:#5CFFB6;
  --red:#ff4a6b;
  --off:#4f4f80;

  --button-bg:#1a1a33;
  --button-border:#4a4aff;

  --overlay-bg:rgba(0,0,30,0.8);

  --tool-bg:#0e0e1a;
  --tool-border:#4a4aff;
}

/* BASE */
*{
  box-sizing:border-box;
  font-family:system-ui, Roboto, "Helvetica Neue", Arial, sans-serif;
}
body{
  margin:0;
  background:var(--bg-main);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  justify-content:center;
}
button{
  cursor:pointer;
}
input, textarea, select, button {
  font-family:inherit;
}

/* APP SHELL */
.app-shell{
  width:100%;
  max-width:480px;
  min-height:100vh;
  background:var(--bg-main);
  display:flex;
  flex-direction:column;
  position:relative;
}

/* STICKY HEADER */
.top-header{
  position:sticky;
  top:0;
  z-index:1000;
  background:var(--bg-panel);
  border-bottom:1px solid var(--border-soft);
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:.6rem .75rem .5rem;
  gap:.4rem;
}
.game-title{
  font-size:clamp(.8rem,.6rem + .5vw,1rem);
  font-weight:700;
  letter-spacing:.05em;
  color:var(--text-primary);
  text-align:center;
}
#turnBanner{
  font-size:clamp(.7rem,.5rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  letter-spacing:.05em;
  text-align:center;
}

/* CONTENT AREA */
.content-area{
  flex:1;
  overflow-y:auto;
  padding:1rem .75rem 5rem; /* bottom pad so footer doesn't cover */
  display:flex;
  flex-direction:column;
  gap:.75rem;
}

/* HUD CARD */
.hud-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  box-shadow:0 20px 40px rgba(0,0,0,.7);
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.hud-top-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  justify-content:space-between;
}
.hud-col{
  flex:1 1 220px;
  min-width:0;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.section-block-inline{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.label-sm{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.text-input{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.45rem .5rem;
  min-width:5rem;
  font-weight:600;
  width:100%;
}

/* STATUS + TAX + TIMERS */
.tiny-col-stack{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.tiny-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.status-chip{
  border-radius:.5rem;
  padding:.5rem;
  text-align:center;
  font-size:.7rem;
  font-weight:600;
  line-height:1.3;
  border:1px solid;
  cursor:pointer;
  min-width:5.5rem;
}
.status-active{
  color:var(--lime);
  border-color:var(--lime);
  background:rgba(95,216,95,.07);
}
.status-cooldown{
  color:var(--red);
  border-color:var(--red);
  background:rgba(216,95,95,.08);
}
.status-elim{
  color:var(--off);
  border-color:var(--off);
  background:rgba(85,85,110,.15);
}
.cooldown-inline-wrap{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
}
.cd-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.mini-step-row{
  display:flex;
  align-items:center;
  gap:.4rem;
  font-size:.8rem;
  font-weight:600;
}
.step-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.step-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
  color:var(--text-primary);
}

.tax-row{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.tax-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.tax-ctrl{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.tax-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.tax-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
}

.timer-row{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem 1rem;
  font-size:.7rem;
  line-height:1.3;
}
.timer-block{
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.timer-label{
  font-size:.6rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.timer-val{
  font-size:clamp(.8rem,.6rem + .4vw,.9rem);
  font-weight:700;
  color:var(--gold);
  min-width:3.5rem;
}

/* VITALS */
.vitalsBlock .life-row{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.life-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:1rem;
  font-weight:700;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2.2rem;
  text-align:center;
  color:var(--text-primary);
}
.life-value{
  min-width:3rem;
  text-align:center;
  font-size:1.2rem;
  font-weight:700;
  color:var(--text-primary);
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .6rem;
  line-height:1.2;
}
.mini-counters-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(100px,100%),1fr));
  gap:.5rem;
}
.mini-counter-box{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:.4rem;
  font-size:.7rem;
  text-align:center;
}
.mini-counter-label{
  font-size:.65rem;
  line-height:1.2;
  color:var(--text-dim);
}

/* END TURN BUTTON */
.end-turn-btn{
  background:var(--gold);
  border:none;
  border-radius:.5rem;
  padding:.8rem .9rem;
  font-size:clamp(.8rem,.5rem + .5vw,.9rem);
  font-weight:700;
  color:#000;
  text-align:center;
  box-shadow:0 10px 20px rgba(0,0,0,.6);
  width:100%;
}

/* OTHERS */
.others-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  padding:.75rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.other-header{
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.other-player-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  overflow:hidden;
}
.other-player-top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  cursor:pointer;
}
.other-expand-indicator{
  font-size:.8rem;
  color:var(--text-dim);
  font-weight:400;
}
.other-player-body{
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  display:none;
  flex-direction:column;
  gap:.75rem;
  font-size:.75rem;
}

/* LINES INSIDE OTHER PLAYER */
.status-line-other{
  font-size:.7rem;
  font-weight:600;
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:center;
}
.cool-row-inline{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:.5rem .75rem;
  font-size:.7rem;
}
.cool-btn-inline{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.4rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.cool-val-box{
  min-width:2rem;
  text-align:center;
  font-size:.8rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  line-height:1.2;
}

.life-edit-inline{
  display:flex;
  align-items:center;
  gap:.5rem;
}
.life-inline-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1;
  padding:.4rem .6rem;
  min-width:2rem;
  text-align:center;
  color:var(--text-primary);
}
.life-inline-val{
  min-width:2.5rem;
  text-align:center;
  font-size:.9rem;
  font-weight:700;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
}

.mini-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
  align-items:flex-start;
}
.mini-col{
  display:flex;
  flex-direction:column;
  gap:.4rem;
}

/* COMMANDER DAMAGE GRID */
.cdmg-section-wrap{
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.cdmg-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
  line-height:1.2;
}
.cdmg-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(140px,100%),1fr));
  gap:.5rem .75rem;
}
.cdmg-cell{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem;
  display:flex;
  flex-direction:column;
  gap:.4rem;
  font-size:.7rem;
}
.cdmg-cell-label{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.2;
}
.cdmg-input-row{
  display:flex;
  gap:.5rem;
  align-items:flex-end;
}
.cdmg-input-row input{
  width:3rem;
  text-align:center;
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.4rem;
  padding:.4rem .5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
}

/* PLAYER NOTES IN OTHERS */
.mini-note-box{
  display:flex;
  flex-direction:column;
  gap:.4rem;
  width:100%;
}
.mini-note-label{
  font-size:.6rem;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.mini-area-input{
  width:100%;
  min-height:2rem;
  resize:vertical;
  font-size:.7rem;
  padding:.5rem .6rem;
  line-height:1.3;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
}

/* ACCORDIONS */
.accordion-block{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  overflow:hidden;
}
.accordion-head{
  background:var(--bg-accent);
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:.6rem .75rem;
  cursor:pointer;
  font-size:.75rem;
  font-weight:600;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.accordion-head .hint{
  color:var(--text-dim);
  font-size:.6rem;
  font-weight:400;
  margin-left:.5rem;
}
.accordion-body{
  border-top:1px solid var(--border-soft);
  padding:.75rem;
  display:none;
  font-size:.75rem;
  color:var(--text-primary);
  line-height:1.4;
}

.row-flex{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem .75rem;
}
.toggle-chip{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.4rem .5rem;
  font-size:.7rem;
  color:var(--text-primary);
  text-align:center;
  cursor:pointer;
}
.toggle-chip.active{
  box-shadow:0 0 10px var(--magenta);
  border-color:var(--text-dim);
  font-weight:600;
}
.area-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  width:100%;
  min-height:3rem;
  resize:vertical;
  font-size:.7rem;
  font-weight:400;
  color:var(--text-primary);
  line-height:1.3;
}

/* SCRYFALL LOOKUP */
.lookup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.lookup-input{
  flex:2;
  min-width:8rem;
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  line-height:1.3;
  padding:.45rem .5rem;
  font-weight:600;
}
.lookup-btn{
  flex:1;
  min-width:5rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.lookup-results{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  font-size:.7rem;
  line-height:1.3;
  color:var(--text-primary);
  margin-top:.5rem;
}
.lookup-cardtext{
  flex:2;
  min-width:10rem;
  white-space:pre-line;
}
.lookup-cardimg{
  flex:1;
  min-width:6rem;
  max-width:140px;
  border-radius:.5rem;
  border:1px solid var(--border-soft);
  background:var(--bg-panel);
  overflow:hidden;
}
.lookup-cardimg img{
  width:100%;
  height:auto;
  display:block;
}

/* FOOTER / TOOLS DOCK */
.tools-footer-wrap{
  position:sticky;
  bottom:0;
  z-index:1000;
  background:var(--tool-bg);
  border-top:1px solid var(--tool-border);
}
.tools-header-btn{
  width:100%;
  background:none;
  border:none;
  text-align:center;
  color:var(--text-primary);
  font-size:.75rem;
  font-weight:600;
  letter-spacing:.05em;
  padding:.6rem .75rem;
}
.tools-panel{
  border-top:1px solid var(--tool-border);
  display:none;
  padding:.75rem;
  font-size:.75rem;
  color:var(--text-primary);
  background:var(--tool-bg);
}
.tools-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(200px,100%),1fr));
  gap:.75rem;
}
.tool-block{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.6rem;
  display:flex;
  flex-direction:column;
  gap:.5rem;
}
.tool-title{
  font-size:.65rem;
  font-weight:500;
  color:var(--text-dim);
  text-transform:uppercase;
  letter-spacing:.05em;
}
.rng-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.rng-btn{
  flex:1;
  min-width:4rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  color:var(--text-primary);
  font-size:.8rem;
  font-weight:600;
  padding:.6rem .75rem;
  text-align:center;
}
.rng-output{
  font-size:.8rem;
  font-weight:600;
  min-height:1em;
  line-height:1.2;
  color:var(--gold);
  word-break:break-word;
}
.global-input{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.45rem .5rem;
  color:var(--text-primary);
  font-size:.7rem;
  min-height:3rem;
  resize:vertical;
  line-height:1.3;
  width:100%;
}
.theme-select{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:100%;
}

.winner-mini-banner{
  border:1px solid var(--gold);
  color:var(--gold);
  background:var(--bg-panel);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  line-height:1.4;
  display:none;
  word-break:break-word;
}

.mode-line{
  font-size:.7rem;
  line-height:1.3;
  display:flex;
  flex-direction:column;
  gap:.25rem;
}
.mode-btn-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
}
.mode-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.7rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}

/* OVERLAYS (setup, winner, respawn, cooldown-finish) */
.overlay-fullscreen{
  position:fixed;
  inset:0;
  background:var(--overlay-bg);
  z-index:9999;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:1rem;
}

.setup-card{
  background:var(--bg-panel);
  border:1px solid var(--border-soft);
  border-radius:.75rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  display:flex;
  flex-direction:column;
  gap:1rem;
  text-align:center;
}
.setup-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--text-primary);
  letter-spacing:.05em;
}
.setup-sub{
  font-size:.7rem;
  color:var(--text-dim);
  line-height:1.4;
}
.setup-row{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  justify-content:center;
}
.setup-btn{
  flex:1;
  min-width:6rem;
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}
.setup-small{
  display:flex;
  flex-direction:column;
  gap:.5rem;
  align-items:center;
}
.setup-number-input{
  background:var(--bg-accent);
  border:1px solid var(--border-soft);
  border-radius:.5rem;
  padding:.5rem .6rem;
  font-size:.8rem;
  color:var(--text-primary);
  width:5rem;
  text-align:center;
}
.setup-go{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.5rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
}

.winner-card,
.respawn-card,
.cooldown-card{
  background:var(--bg-panel);
  border:2px solid var(--gold);
  border-radius:1rem;
  padding:1rem;
  max-width:320px;
  width:100%;
  text-align:center;
  display:flex;
  flex-direction:column;
  gap:1rem;
  box-shadow:0 0 30px rgba(212,169,79,.6),0 40px 80px rgba(0,0,0,.9);
}
.winner-title{
  font-size:.9rem;
  font-weight:700;
  color:var(--gold);
  line-height:1.3;
  word-break:break-word;
}
.winner-line{
  font-size:.8rem;
  font-weight:500;
  color:var(--text-primary);
  line-height:1.4;
}
.respawn-q,
.cooldown-q{
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  line-height:1.4;
}
.small-hint{
  font-size:.6rem;
  color:var(--text-dim);
  line-height:1.3;
}
.overlay-btn{
  background:var(--button-bg);
  border:1px solid var(--button-border);
  border-radius:.5rem;
  padding:.6rem .75rem;
  font-size:.8rem;
  font-weight:600;
  color:var(--text-primary);
  text-align:center;
}

/* tiny helper text */
.helper-row{
  font-size:.65rem;
  color:var(--text-dim);
  line-height:1.3;
  text-align:center;
}
</style>
</head>
<body class="theme-dark">

<div class="app-shell">

  <!-- SETUP OVERLAY (2-step mode + players) -->
  <div id="setupOverlay" class="overlay-fullscreen">
    <div class="setup-card" id="setupStepMode">
      <div class="setup-title">Select Mode</div>
      <div class="setup-row">
        <button class="setup-btn" data-mode="regular">
          Mode 1 — Regular
          <div class="setup-sub">Standard Commander. No respawn.</div>
        </button>
        <button class="setup-btn" data-mode="rumble">
          Mode 2 — Rumble
          <div class="setup-sub">Cooldown / Respawn / Reigning Rumbler.</div>
        </button>
      </div>
      <div class="helper-row">You’ll pick player count next.</div>
    </div>

    <div class="setup-card" id="setupStepPlayers" style="display:none;">
      <div class="setup-title">How many players?</div>
      <div class="setup-row">
        <button class="setup-btn" data-fixedplayers="2">2</button>
        <button class="setup-btn" data-fixedplayers="3">3</button>
        <button class="setup-btn" data-fixedplayers="4">4</button>
      </div>
      <div class="setup-small">
        <div class="label-sm" style="text-align:center;">Manual Entry (2–8)</div>
        <input id="manualPlayerCount" class="setup-number-input" type="number" min="2" max="8" value="5" />
        <button id="manualStartBtn" class="setup-go">Start Game</button>
      </div>
      <div class="helper-row">Rename yourself on your turn.</div>
    </div>
  </div>

  <!-- WINNER OVERLAY -->
  <div id="winnerOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="winner-card">
      <div class="winner-title" id="winnerTitle">REIGNING RUMBLER!</div>
      <div class="winner-line" id="winnerTimeLine">Game Time: 00m 00s</div>
      <div class="winner-line" id="winnerPlayerTimeLine">Winner Active Time: 00m 00s</div>
      <button class="overlay-btn" id="winnerCloseBtn">OK</button>
    </div>
  </div>

  <!-- RESPAWN OVERLAY (for Rumble "last chance before win") -->
  <div id="respawnOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="respawn-card">
      <div class="respawn-q" id="respawnQuestion">Respawn this player?</div>
      <div class="small-hint" id="respawnHint">
        They re-enter active with avg life (rounded up), poison 0, and commander tax reset — blocking an auto-win.
      </div>
      <button class="overlay-btn" id="respawnYesBtn">Yes, Respawn</button>
      <button class="overlay-btn" id="respawnNoBtn">No, Eliminate</button>
    </div>
  </div>

  <!-- COOLDOWN FINISH OVERLAY (Rumble only) -->
  <div id="cooldownFinishOverlay" class="overlay-fullscreen" style="display:none;">
    <div class="cooldown-card">
      <div class="cooldown-q" id="cooldownFinishQuestion">[Player X] cooldown finished. What happens?</div>
      <div class="small-hint" id="cooldownFinishHint">
        Respawn = avg life up / poison 0 / tax reset<br>
        Keep Cooling = stay out 1 more turn<br>
        Eliminate = gone forever
      </div>
      <button class="overlay-btn" id="cooldownRespawnBtn">Respawn</button>
      <button class="overlay-btn" id="cooldownKeepBtn">Keep Cooling</button>
      <button class="overlay-btn" id="cooldownElimBtn">Eliminate</button>
    </div>
  </div>

  <!-- HEADER -->
  <div class="top-header">
    <div class="game-title">EDH RUMBLE TRACKER</div>
    <div id="turnBanner">▶ PLAYER 1'S TURN ◀</div>
  </div>

  <!-- MAIN CONTENT -->
  <div class="content-area" id="contentArea">
    <div id="hudArea"></div>

    <button class="end-turn-btn" id="endTurnBtn">End Turn →</button>

    <div id="othersArea"></div>

    <div id="accordionsArea"></div>
  </div>

  <!-- FOOTER / TOOLS -->
  <div class="tools-footer-wrap">
    <button class="tools-header-btn" id="toggleToolsBtn">Tools ▼</button>
    <div class="tools-panel" id="toolsPanel">
      <div class="tools-grid">

        <div class="tool-block">
          <div class="tool-title">Theme</div>
          <select id="themeSelect" class="theme-select">
            <option value="theme-dark" selected>Dark</option>
            <option value="theme-light">Light</option>
            <option value="theme-neon">Neon</option>
          </select>
        </div>

        <div class="tool-block">
          <div class="tool-title">Randomizers</div>
          <div class="rng-row">
            <button class="rng-btn" id="flipCoinBtn">Coin Flip</button>
            <button class="rng-btn" id="rollD6Btn">d6</button>
            <button class="rng-btn" id="rollD20Btn">d20</button>
          </div>
          <div class="rng-output" id="rngOutput"></div>
        </div>

        <div class="tool-block">
          <div class="tool-title">Current Plane (Planechase)</div>
          <textarea id="planeField" class="global-input" placeholder="Plane text / chaos effects..."></textarea>
        </div>

        <div class="tool-block">
          <div class="tool-title">Current Scheme (Archenemy)</div>
          <textarea id="schemeField" class="global-input" placeholder="Scheme text / ongoing..."></textarea>
        </div>

        <div class="tool-block">
          <div class="tool-title">Game Control</div>
          <div class="mode-line">
            <div id="modeStatusText">Mode 2 — Rumble</div>
            <div id="winnerMiniBanner" class="winner-mini-banner"></div>
            <div class="mode-btn-row">
              <button class="mode-btn" id="newGameBtn">New Game</button>
              <button class="mode-btn" id="changeModeBtn">Change Mode</button>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

</div> <!-- end .app-shell -->

<script>
/* =========================
   GLOBAL STATE
========================= */

let gameMode = null; // "regular" or "rumble"
let players = [];
let turnIndex = 0;
let turnCounter = 0;
let gameStartTime = null;

let reigningCandidateIndex = null;
let reigningCandidateTurnStamp = null;

let winnerLocked = false;
let winnerName = "";
let winnerTimeMs = 0;
let winnerActiveMs = 0;

let pendingRespawnIndex = null;           // for "last chance to stop auto-win"
let pendingCooldownFinishIndex = null;    // for cooldown finishing
let pendingCooldownMode = null;

let accordionsOpen = {
  statusEffects:false,
  notes:false,
  lookup:false,
};

let renderIntervalId = null;

/* DOM refs */
const setupOverlay           = document.getElementById("setupOverlay");
const setupStepMode          = document.getElementById("setupStepMode");
const setupStepPlayers       = document.getElementById("setupStepPlayers");
const manualPlayerCount      = document.getElementById("manualPlayerCount");
const manualStartBtn         = document.getElementById("manualStartBtn");

const winnerOverlay          = document.getElementById("winnerOverlay");
const winnerTitle            = document.getElementById("winnerTitle");
const winnerTimeLine         = document.getElementById("winnerTimeLine");
const winnerPlayerTimeLine   = document.getElementById("winnerPlayerTimeLine");
const winnerCloseBtn         = document.getElementById("winnerCloseBtn");
const winnerMiniBanner       = document.getElementById("winnerMiniBanner");

const respawnOverlay         = document.getElementById("respawnOverlay");
const respawnQuestion        = document.getElementById("respawnQuestion");
const respawnHint            = document.getElementById("respawnHint");
const respawnYesBtn          = document.getElementById("respawnYesBtn");
const respawnNoBtn           = document.getElementById("respawnNoBtn");

const cooldownFinishOverlay  = document.getElementById("cooldownFinishOverlay");
const cooldownFinishQuestion = document.getElementById("cooldownFinishQuestion");
const cooldownFinishHint     = document.getElementById("cooldownFinishHint");
const cooldownRespawnBtn     = document.getElementById("cooldownRespawnBtn");
const cooldownKeepBtn        = document.getElementById("cooldownKeepBtn");
const cooldownElimBtn        = document.getElementById("cooldownElimBtn");

const turnBanner             = document.getElementById("turnBanner");

const hudArea                = document.getElementById("hudArea");
const endTurnBtn             = document.getElementById("endTurnBtn");
const othersArea             = document.getElementById("othersArea");
const accordionsArea         = document.getElementById("accordionsArea");

const toggleToolsBtn         = document.getElementById("toggleToolsBtn");
const toolsPanel             = document.getElementById("toolsPanel");

const themeSelect            = document.getElementById("themeSelect");
const flipCoinBtn            = document.getElementById("flipCoinBtn");
const rollD6Btn              = document.getElementById("rollD6Btn");
const rollD20Btn             = document.getElementById("rollD20Btn");
const rngOutput              = document.getElementById("rngOutput");

const modeStatusText         = document.getElementById("modeStatusText");
const newGameBtn             = document.getElementById("newGameBtn");
const changeModeBtn          = document.getElementById("changeModeBtn");

/* =========================
   UTILITIES
========================= */

function msToClock(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins + ":" + (secs<10?("0"+secs):secs);
}

function formatDurationMs(ms){
  const totalSec = Math.floor(ms/1000);
  const mins = Math.floor(totalSec/60);
  const secs = totalSec % 60;
  return mins+"m "+secs+"s";
}

function makePlayer(defaultName){
  return {
    name: defaultName,

    status:"active",          // "active","cooldown","eliminated" (no cooldown used in regular mode but we still keep field)
    cooldownRemaining:0,

    life:40,
    poison:0,
    radiation:0,
    energy:0,
    experience:0,
    storm:0,

    hasMonarch:false,
    hasInitiative:false,
    hasCitysBlessing:false,

    dungeonProgress:"",
    emblemsText:"",
    notesText:"",

    commanderTaxSteps:0,

    commanderDamage:[], // victim.commanderDamage[srcIdx] = dmg from srcIdx's commander

    lookupNameInput:"",
    lastLookupName:"",
    lastLookupResult:"",
    lastLookupImg:"",

    totalActiveMs:0,
    turnStartMs:null,
    isTiming:false
  };
}

function syncCommanderDamageArrays(){
  players.forEach(p=>{
    while(p.commanderDamage.length < players.length){
      p.commanderDamage.push(0);
    }
    if(p.commanderDamage.length > players.length){
      p.commanderDamage.length = players.length;
    }
  });
}

function computeRespawnLifeDown(idx){
  const pool = players.filter((pl,j)=> j!==idx && pl.status!=="eliminated");
  if(pool.length===0) return 0;
  let sum=0;
  pool.forEach(pl=>{ sum+=pl.life; });
  return Math.floor(sum / pool.length);
}
function computeRespawnLifeUp(idx){
  const pool = players.filter((pl,j)=> j!==idx && pl.status!=="eliminated");
  if(pool.length===0) return 0;
  let sum=0;
  pool.forEach(pl=>{ sum+=pl.life; });
  return Math.ceil(sum / pool.length);
}

function getActivePlayers(){
  let arr=[];
  players.forEach((pl,i)=>{
    if(pl.status==="active"){
      arr.push(i);
    }
  });
  return arr;
}

/* timing helpers */
function startTimingPlayer(i){
  const p=players[i];
  if(p.status!=="active") return;
  p.isTiming=true;
  p.turnStartMs=Date.now();
}
function stopTimingPlayer(i){
  const p=players[i];
  if(!p.isTiming) return;
  const now=Date.now();
  const diff= now - (p.turnStartMs||now);
  p.totalActiveMs += diff;
  p.isTiming=false;
  p.turnStartMs=null;
}

function getPlayerTurnMs(p){
  if(p.isTiming && p.turnStartMs!=null){
    return Date.now()-p.turnStartMs;
  }
  return 0;
}
function getPlayerTotalMs(p){
  // total active time is banked + current running turn
  return p.totalActiveMs + getPlayerTurnMs(p);
}

/* Rumble: track reigning candidate */
function updateReigningCandidate(){
  if(gameMode!=="rumble"){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
    return;
  }
  const actives = getActivePlayers();
  if(actives.length===1){
    const onlyIdx=actives[0];
    if(reigningCandidateIndex===null){
      reigningCandidateIndex=onlyIdx;
      reigningCandidateTurnStamp=turnCounter;
    }else if(reigningCandidateIndex!==onlyIdx){
      reigningCandidateIndex=onlyIdx;
      reigningCandidateTurnStamp=turnCounter;
    }
  }else{
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

function permanentlyEliminate(i){
  const p=players[i];
  p.status="eliminated";
  p.cooldownRemaining=0;
  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
  stopTimingPlayer(i);
}

function checkCommanderDamageElim(victimIdx){
  const p = players[victimIdx];
  for(let src=0; src<p.commanderDamage.length; src++){
    if(p.commanderDamage[src] >= 21){
      // lethal commander damage → elimination / cooldown?
      if(gameMode==="rumble"){
        // lethal commander damage ends you permanently (as per variant rule: commander damage is permanent elimination)
        permanentlyEliminate(victimIdx);
      }else{
        permanentlyEliminate(victimIdx);
      }
      break;
    }
  }
}

/* =========================
   RUMBLE ONLY HELPERS
========================= */

function sendToCooldown(i){
  if(gameMode!=="rumble") return;
  const p = players[i];
  if(p.status==="eliminated") return;

  // leaving turn? if the KO target is current player, stop their clock
  stopTimingPlayer(i);

  let othersCooling=0;
  players.forEach((q,qi)=>{
    if(qi!==i && q.status==="cooldown") othersCooling++;
  });

  p.status="cooldown";
  p.cooldownRemaining = 1 + othersCooling;

  if(reigningCandidateIndex===i){
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
}

function fullyRespawnPlayer(i,roundingMode){
  if(gameMode!=="rumble") return;
  const p=players[i];
  let newLife = (roundingMode==="up")
    ? computeRespawnLifeUp(i)
    : computeRespawnLifeDown(i);
  p.status="active";
  p.cooldownRemaining=0;
  p.poison=0;
  p.life=newLife;
  p.commanderTaxSteps=0;
  // they come back in, not timing until it's actually their turn again
}

function handleCooldownTick(i){
  // only in rumble
  const p=players[i];
  if(p.status!=="cooldown") return false;

  if(p.cooldownRemaining>0){
    p.cooldownRemaining -= 1;
  }

  if(p.cooldownRemaining<=0){
    pendingCooldownFinishIndex = i;
    pendingCooldownMode = "normalFinish";
    showCooldownFinishOverlay(i);
    return true;
  }
  return false;
}

function showCooldownFinishOverlay(idx){
  const pl=players[idx];
  const nm=pl.name||("Player "+(idx+1));
  cooldownFinishQuestion.textContent=nm+"'s cooldown finished. What happens?";
  cooldownFinishOverlay.style.display="flex";
}

cooldownRespawnBtn.addEventListener("click",()=>{
  if(pendingCooldownFinishIndex!==null){
    fullyRespawnPlayer(pendingCooldownFinishIndex,"down");
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
  pendingCooldownFinishIndex=null;
  pendingCooldownMode=null;
  cooldownFinishOverlay.style.display="none";
  renderAll();
});
cooldownKeepBtn.addEventListener("click",()=>{
  if(pendingCooldownFinishIndex!==null){
    const p=players[pendingCooldownFinishIndex];
    p.status="cooldown";
    p.cooldownRemaining=1;
  }
  pendingCooldownFinishIndex=null;
  pendingCooldownMode=null;
  cooldownFinishOverlay.style.display="none";
  renderAll();
});
cooldownElimBtn.addEventListener("click",()=>{
  if(pendingCooldownFinishIndex!==null){
    permanentlyEliminate(pendingCooldownFinishIndex);
  }
  pendingCooldownFinishIndex=null;
  pendingCooldownMode=null;
  cooldownFinishOverlay.style.display="none";
  renderAll();
});

/* last-chance before Rumble win */
function maybeOfferRespawnBeforeWin(){
  if(winnerLocked) return false;
  if(gameMode!=="rumble") return false;

  const cooling = players
    .map((pl,i)=>({pl,i}))
    .filter(o=>o.pl.status==="cooldown");

  if(cooling.length===0){
    return false;
  }

  pendingRespawnIndex = cooling[0].i;
  showRespawnOverlay(pendingRespawnIndex);
  return true;
}

function showRespawnOverlay(idx){
  const p=players[idx];
  const nm=p.name||("Player "+(idx+1));
  respawnQuestion.textContent="Respawn "+nm+"?";
  respawnOverlay.style.display="flex";
}

respawnYesBtn.addEventListener("click",()=>{
  if(pendingRespawnIndex!==null){
    fullyRespawnPlayer(pendingRespawnIndex,"up");
    reigningCandidateIndex=null;
    reigningCandidateTurnStamp=null;
  }
  pendingRespawnIndex=null;
  respawnOverlay.style.display="none";
  renderAll();
});
respawnNoBtn.addEventListener("click",()=>{
  if(pendingRespawnIndex!==null){
    permanentlyEliminate(pendingRespawnIndex);
  }
  pendingRespawnIndex=null;
  respawnOverlay.style.display="none";
  renderAll();
});

/* =========================
   WIN LOGIC
========================= */

function checkForWinRegular(){
  if(gameMode!=="regular") return false;
  if(winnerLocked) return false;

  // who is still not eliminated?
  const stillIn = players.filter(p=>p.status!=="eliminated");
  if(stillIn.length===1){
    const idx = players.indexOf(stillIn[0]);
    lockWinner(idx,false);
    return true;
  }
  return false;
}

function checkForWinRumbleBeforeAdvance(){
  if(gameMode!=="rumble") return false;
  if(winnerLocked) return false;

  const actives=getActivePlayers();
  if(actives.length!==1) return false;
  const onlyIdx=actives[0];

  const aboutToWin =
    (reigningCandidateIndex===onlyIdx &&
     reigningCandidateTurnStamp!==null &&
     turnCounter > reigningCandidateTurnStamp);

  if(!aboutToWin){
    return false;
  }

  // offer cooldown respawn if possible
  const offered = maybeOfferRespawnBeforeWin();
  if(offered){
    return false;
  }

  lockWinner(onlyIdx,true);
  return true;
}

function lockWinner(idx,isRumble){
  winnerLocked = true;
  winnerName = players[idx].name || ("Player "+(idx+1));
  winnerTimeMs = Date.now()-gameStartTime;
  winnerActiveMs = getPlayerTotalMs(players[idx]);

  showWinnerOverlay(isRumble);
}

function showWinnerOverlay(isRumble){
  if(isRumble){
    winnerTitle.textContent = winnerName.toUpperCase()+" — REIGNING RUMBLER!";
  }else{
    winnerTitle.textContent = winnerName+" wins the game!";
  }

  winnerTimeLine.textContent =
    "Game Time: "+formatDurationMs(winnerTimeMs);
  winnerPlayerTimeLine.textContent =
    "Winner Active Time: "+formatDurationMs(winnerActiveMs);

  winnerMiniBanner.style.display="block";
  winnerMiniBanner.textContent =
    winnerName+
    (isRumble? " — REIGNING RUMBLER! ":" wins!")+
    " ("+formatDurationMs(winnerTimeMs)+")";

  winnerOverlay.style.display="flex";
}

winnerCloseBtn.addEventListener("click",()=>{
  winnerOverlay.style.display="none";
});

/* =========================
   TURN FLOW
========================= */

function passTurn(){
  if(winnerLocked){
    renderAll();
    return;
  }

  // regular mode: maybe immediate win condition before passing?
  if(gameMode==="regular"){
    const didWinReg = checkForWinRegular();
    if(didWinReg){
      renderAll();
      return;
    }
  }

  // rumble check: about to crown reigning rumbler
  if(gameMode==="rumble"){
    const didWinRumble = checkForWinRumbleBeforeAdvance();
    if(didWinRumble){
      renderAll();
      return;
    }
  }

  // stop timing old active player
  stopTimingPlayer(turnIndex);

  // rotate turnIndex until we find next valid
  let safety=0;
  do{
    turnIndex=(turnIndex+1)%players.length;
    const pl=players[turnIndex];

    if(pl.status==="eliminated"){
      // skip
    } else if(gameMode==="rumble" && pl.status==="cooldown"){
      // tick their cooldown
      const triggered = handleCooldownTick(turnIndex);
      if(triggered){
        // cooldownFinishOverlay will appear
        break;
      } else {
        // still cooling, skip
      }
    } else {
      // found next active / (in regular, no cooldown status anyway)
      break;
    }

    safety++;
    if(safety>50) break;
  }while(true);

  turnCounter += 1;
  updateReigningCandidate();

  // start timing new active player if actually active
  if(players[turnIndex].status==="active"){
    startTimingPlayer(turnIndex);
  }

  // after passing, regular mode might now have only 1 left
  if(gameMode==="regular"){
    const didWinReg2 = checkForWinRegular();
    if(didWinReg2){
      renderAll();
      return;
    }
  }

  renderAll();
}

/* =========================
   THEME / TOOLS
========================= */

toggleToolsBtn.addEventListener("click",()=>{
  if(toolsPanel.style.display==="block"){
    toolsPanel.style.display="none";
    toggleToolsBtn.textContent="Tools ▼";
  } else {
    toolsPanel.style.display="block";
    toggleToolsBtn.textContent="Tools ▲";
  }
});

themeSelect.addEventListener("change",()=>{
  document.body.classList.remove("theme-dark","theme-light","theme-neon");
  document.body.classList.add(themeSelect.value);
});

flipCoinBtn.addEventListener("click",()=>{
  rngOutput.textContent="Coin: "+(Math.random()<0.5?"Heads":"Tails");
});
rollD6Btn.addEventListener("click",()=>{
  rngOutput.textContent="d6: "+(Math.floor(Math.random()*6)+1);
});
rollD20Btn.addEventListener("click",()=>{
  rngOutput.textContent="d20: "+(Math.floor(Math.random()*20)+1);
});

newGameBtn.addEventListener("click",()=>{
  // same mode, confirm wipe
  if(!confirm("Start a new game in the same mode? This clears all data.")) return;
  showPlayerCountStep(); // skip mode re-pick, keep gameMode
});
changeModeBtn.addEventListener("click",()=>{
  // confirm wipe + go back to mode select
  if(!confirm("Change mode? This restarts the game.")) return;
  showModeStep(); // pick mode again
});

/* =========================
   SCRYFALL LOOKUP
========================= */

function analyzeOracleText(oracleText,typeLine){
  const text=(oracleText||"").toLowerCase();
  const tline=(typeLine||"").toLowerCase();
  const parsed={
    wantsMonarch:/become the monarch|you become the monarch/.test(text),
    wantsInitiative:/take the initiative|you take the initiative/.test(text),
    wantsCitysBlessing:/city's blessing/.test(text),
    wantsExp:/experience counter/.test(text),
    planeswalkerHint:/planeswalker/.test(tline),

    upkeepReminder:"",
    dungeonHint:"",
    bountyNote:""
  };

  const upkeepMatch=oracleText && oracleText.match(/At the beginning of your upkeep[^.]*\./i);
  if(upkeepMatch){
    parsed.upkeepReminder="UPKEEP: "+upkeepMatch[0].trim();
  }

  if(/the initiative/.test(text)
  ||/undercity/.test(text)
  ||/venture into the dungeon/.test(text)){
    parsed.dungeonHint="Dungeon/Initiative: Track Undercity / dungeon progress each upkeep.";
  }

  if(/bounty counter/.test(text)){
    parsed.bountyNote="Bounty: Mark target; reward when it dies.";
  }

  return parsed;
}

async function doLookup(idx){
  const p=players[idx];
  const rawName=p.lookupNameInput||"";
  if(!rawName.trim()){
    p.lastLookupResult="Enter a card name first.";
    renderAll();
    return;
  }
  const url="https://api.scryfall.com/cards/named?fuzzy="+encodeURIComponent(rawName.trim());
  try{
    const resp=await fetch(url);
    if(!resp.ok){
      p.lastLookupName="";
      p.lastLookupResult="Card not found.";
      p.lastLookupImg="";
      renderAll();
      return;
    }
    const data=await resp.json();
    const oracle=data.oracle_text||"";
    const typeLine=data.type_line||"";

    p.lastLookupName=data.name||rawName.trim();
    p.lastLookupResult=(typeLine?typeLine+"\n":"")+(oracle?oracle:"");

    let imgUrl="";
    if(data.image_uris && data.image_uris.normal){
      imgUrl=data.image_uris.normal;
    }else if(Array.isArray(data.card_faces)
          && data.card_faces[0]
          && data.card_faces[0].image_uris){
      imgUrl=data.card_faces[0].image_uris.normal||"";
    }
    p.lastLookupImg=imgUrl;

    const parsed=analyzeOracleText(oracle,typeLine);
    if(parsed.wantsMonarch){ p.hasMonarch=true; }
    if(parsed.wantsInitiative){
      p.hasInitiative=true;
      if(!p.dungeonProgress.toLowerCase().includes("undercity")
      && !p.dungeonProgress.toLowerCase().includes("dungeon")){
        p.dungeonProgress += (p.dungeonProgress? "\n":"")
          +"Initiative: Progress Undercity each upkeep.";
      }
    }
    if(parsed.wantsCitysBlessing){ p.hasCitysBlessing=true; }
    if(parsed.wantsExp){
      if(!p.notesText.toLowerCase().includes("experience counter")){
        p.notesText += (p.notesText? "\n":"")
          +"This uses Experience counters. Track them.";
      }
    }
    if(parsed.planeswalkerHint){
      if(!p.notesText.toLowerCase().includes("track loyalty")){
        p.notesText += (p.notesText? "\n":"")
          +"If this is your commander, track loyalty like life.";
      }
    }
    if(parsed.upkeepReminder){
      if(!p.notesText.toLowerCase().includes(parsed.upkeepReminder.toLowerCase())){
        p.notesText += (p.notesText? "\n":"")+parsed.upkeepReminder;
      }
    }
    if(parsed.dungeonHint){
      if(!p.dungeonProgress.toLowerCase().includes("dungeon")){
        p.dungeonProgress += (p.dungeonProgress? "\n":"")+parsed.dungeonHint;
      }
    }
    if(parsed.bountyNote){
      if(!p.notesText.toLowerCase().includes("bounty")){
        p.notesText += (p.notesText? "\n":"")+parsed.bountyNote;
      }
    }

    renderAll();
  }catch(e){
    p.lastLookupName=rawName.trim();
    p.lastLookupResult="Lookup failed (offline?).";
    p.lastLookupImg="";
    renderAll();
  }
}

/* =========================
   RENDER
========================= */

function renderAll(){
  syncCommanderDamageArrays();

  // update header
  const cur = players[turnIndex]||{};
  const nm  = cur.name||("Player "+(turnIndex+1));
  turnBanner.textContent = "▶ "+nm.toUpperCase()+"'S TURN ◀";

  // update mode text
  modeStatusText.textContent =
    (gameMode==="regular"?"Mode 1 — Regular":"Mode 2 — Rumble");

  renderHUD();
  renderOthers();
  renderAccordions();

  if(winnerLocked){
    winnerMiniBanner.style.display="block";
  }else{
    // if no winner yet but we had displayed banner before, keep it visible? up to you.
    // we'll leave whatever is already in banner but hide if game not ended
    if(!winnerTimeMs){
      winnerMiniBanner.style.display="none";
    }
  }
}

/* seat glow color */
function getSeatColor(i){
  const cols=["var(--gold)","var(--cyan)","var(--magenta)","var(--lime)"];
  return cols[i % cols.length];
}

/* build active player HUD */
function renderHUD(){
  hudArea.innerHTML="";
  const p=players[turnIndex];
  if(!p){ return; }

  const seatColor=getSeatColor(turnIndex);

  const card=document.createElement("div");
  card.className="hud-card";
  card.style.border="1px solid "+seatColor;
  card.style.boxShadow="0 0 20px "+seatColor+"80, 0 30px 60px rgba(0,0,0,.9)";

  const topRow=document.createElement("div");
  topRow.className="hud-top-row";

  /* LEFT COL */
  const leftCol=document.createElement("div");
  leftCol.className="hud-col";

  const nameBlock=document.createElement("div");
  nameBlock.className="section-block-inline";

  const nmLabel=document.createElement("div");
  nmLabel.className="label-sm";
  nmLabel.textContent="Your Name";

  const nmInput=document.createElement("input");
  nmInput.className="text-input";
  nmInput.value=p.name;
  nmInput.addEventListener("input",e=>{
    p.name=e.target.value;
  });
  nmInput.addEventListener("blur",()=>{
    renderAll();
  });
  nmInput.addEventListener("keydown",ev=>{
    if(ev.key==="Enter"){
      ev.preventDefault();
      nmInput.blur();
    }
  });

  const tinyStack=document.createElement("div");
  tinyStack.className="tiny-col-stack";

  // status row
  const statusRow=document.createElement("div");
  statusRow.className="tiny-row";

  // build status chip based on mode
  const stChip=document.createElement("div");
  stChip.className="status-chip "+
    (p.status==="active"?"status-active":
     p.status==="cooldown"?"status-cooldown":
                           "status-elim");
  stChip.textContent=
    p.status==="active"?"ACTIVE":
    p.status==="cooldown"?"COOLDOWN":
    "ELIMINATED";

  stChip.title = (gameMode==="rumble")
    ? "Tap to cycle: Active → Cooldown → Eliminated → Active"
    : "Tap to cycle: Active → Eliminated → Active";

  stChip.addEventListener("click",()=>{
    cycleStatus(turnIndex);
  });

  statusRow.appendChild(stChip);

  // cooldownRemaining only matters in rumble + status=cooldown
  if(gameMode==="rumble" && p.status==="cooldown"){
    const cdWrap=document.createElement("div");
    cdWrap.className="cooldown-inline-wrap";

    const cdLab=document.createElement("div");
    cdLab.className="cd-label";
    cdLab.textContent="CD:";

    const cdStepper=document.createElement("div");
    cdStepper.className="mini-step-row";

    const cdMinus=document.createElement("div");
    cdMinus.className="step-btn";
    cdMinus.textContent="-";
    cdMinus.addEventListener("click",()=>{
      adjustCooldownRemaining(turnIndex,-1,true);
    });

    const cdVal=document.createElement("div");
    cdVal.className="step-val";
    cdVal.textContent=p.cooldownRemaining;

    const cdPlus=document.createElement("div");
    cdPlus.className="step-btn";
    cdPlus.textContent="+";
    cdPlus.addEventListener("click",()=>{
      adjustCooldownRemaining(turnIndex,1,true);
    });

    cdStepper.appendChild(cdMinus);
    cdStepper.appendChild(cdVal);
    cdStepper.appendChild(cdPlus);

    cdWrap.appendChild(cdLab);
    cdWrap.appendChild(cdStepper);
    statusRow.appendChild(cdWrap);
  }

  // commander tax row
  const taxRow=document.createElement("div");
  taxRow.className="tax-row";

  const taxLabel=document.createElement("div");
  taxLabel.className="tax-label";
  taxLabel.textContent="Commander Tax: +2 ×";

  const taxCtrl=document.createElement("div");
  taxCtrl.className="tax-ctrl";

  const taxMinus=document.createElement("div");
  taxMinus.className="tax-btn";
  taxMinus.textContent="-";
  taxMinus.addEventListener("click",()=>{
    if(p.commanderTaxSteps>0)p.commanderTaxSteps--;
    renderAll();
  });

  const taxVal=document.createElement("div");
  taxVal.className="tax-val";
  taxVal.textContent=p.commanderTaxSteps;

  const taxPlus=document.createElement("div");
  taxPlus.className="tax-btn";
  taxPlus.textContent="+";
  taxPlus.addEventListener("click",()=>{
    p.commanderTaxSteps++;
    renderAll();
  });

  taxCtrl.appendChild(taxMinus);
  taxCtrl.appendChild(taxVal);
  taxCtrl.appendChild(taxPlus);

  taxRow.appendChild(taxLabel);
  taxRow.appendChild(taxCtrl);

  // timer row (Turn Time / Total Time)
  const timeRow=document.createElement("div");
  timeRow.className="timer-row";

  const tBlock1=document.createElement("div");
  tBlock1.className="timer-block";
  const tb1L=document.createElement("div");
  tb1L.className="timer-label";
  tb1L.textContent="Turn Time";
  const tb1V=document.createElement("div");
  tb1V.className="timer-val";
  tb1V.textContent=msToClock(getPlayerTurnMs(p));
  tBlock1.appendChild(tb1L);
  tBlock1.appendChild(tb1V);

  const tBlock2=document.createElement("div");
  tBlock2.className="timer-block";
  const tb2L=document.createElement("div");
  tb2L.className="timer-label";
  tb2L.textContent="Total Time";
  const tb2V=document.createElement("div");
  tb2V.className="timer-val";
  tb2V.textContent=msToClock(getPlayerTotalMs(p));
  tBlock2.appendChild(tb2L);
  tBlock2.appendChild(tb2V);

  timeRow.appendChild(tBlock1);
  timeRow.appendChild(tBlock2);

  tinyStack.appendChild(statusRow);
  tinyStack.appendChild(taxRow);
  tinyStack.appendChild(timeRow);

  nameBlock.appendChild(nmLabel);
  nameBlock.appendChild(nmInput);
  nameBlock.appendChild(tinyStack);

  leftCol.appendChild(nameBlock);

  /* RIGHT COL */
  const rightCol=document.createElement("div");
  rightCol.className="hud-col";

  const vitalsBlock=document.createElement("div");
  vitalsBlock.className="section-block-inline vitalsBlock";

  const lfLabel=document.createElement("div");
  lfLabel.className="label-sm";
  lfLabel.textContent="Life Total";

  const lfRow=document.createElement("div");
  lfRow.className="life-row";

  const minusBtn=document.createElement("div");
  minusBtn.className="life-btn";
  minusBtn.textContent="-";
  minusBtn.addEventListener("click",()=>{
    p.life = p.life-1;
    if(gameMode==="rumble"){
      if(p.life<=0){
        sendToCooldown(turnIndex);
      }
    }else{
      if(p.life<=0){
        permanentlyEliminate(turnIndex);
      }
    }
    renderAll();
  });

  const lifeVal=document.createElement("div");
  lifeVal.className="life-value";
  lifeVal.textContent=p.life;

  const plusBtn=document.createElement("div");
  plusBtn.className="life-btn";
  plusBtn.textContent="+";
  plusBtn.addEventListener("click",()=>{
    p.life = p.life+1;
    renderAll();
  });

  lfRow.appendChild(minusBtn);
  lfRow.appendChild(lifeVal);
  lfRow.appendChild(plusBtn);

  const grid=document.createElement("div");
  grid.className="mini-counters-grid";

  grid.appendChild(makeMiniStepperBox("☠ Poison",p.poison,(newVal)=>{
    p.poison=newVal;
    if(gameMode==="rumble"){
      if(p.poison>=10){
        sendToCooldown(turnIndex);
      }
    }else{
      if(p.poison>=10){
        permanentlyEliminate(turnIndex);
      }
    }
    renderAll();
  }));

  grid.appendChild(makeMiniStepperBox("☢ Rad",p.radiation,(newVal)=>{
    p.radiation=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("⚡ Energy",p.energy,(newVal)=>{
    p.energy=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("★ Exp",p.experience,(newVal)=>{
    p.experience=newVal;
    renderAll();
  }));
  grid.appendChild(makeMiniStepperBox("☁ Storm",p.storm,(newVal)=>{
    p.storm=newVal;
    renderAll();
  }));

  vitalsBlock.appendChild(lfLabel);
  vitalsBlock.appendChild(lfRow);
  vitalsBlock.appendChild(grid);

  rightCol.appendChild(vitalsBlock);

  topRow.appendChild(leftCol);
  topRow.appendChild(rightCol);
  card.appendChild(topRow);

  hudArea.appendChild(card);
}

function makeMiniStepperBox(labelText,val,onSet){
  const wrap=document.createElement("div");
  wrap.className="mini-counter-box";

  const lab=document.createElement("div");
  lab.className="mini-counter-label";
  lab.textContent=labelText;

  const row=document.createElement("div");
  row.className="mini-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1;
    if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1;
    if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);

  wrap.appendChild(lab);
  wrap.appendChild(row);
  return wrap;
}

/* render "Other Players" list */
function renderOthers(){
  othersArea.innerHTML="";
  const wrap=document.createElement("div");
  wrap.className="others-card";

  const hdr=document.createElement("div");
  hdr.className="other-header";
  hdr.textContent="Other Players";
  wrap.appendChild(hdr);

  players.forEach((pl,i)=>{
    if(i===turnIndex) return;
    const block=document.createElement("div");
    block.className="other-player-block";

    const top=document.createElement("div");
    top.className="other-player-top";

    const nm=pl.name||("Player "+(i+1));
    const titleSpan=document.createElement("span");
    titleSpan.textContent=nm;

    const chev=document.createElement("span");
    chev.className="other-expand-indicator";
    chev.textContent="▼";

    top.appendChild(titleSpan);
    top.appendChild(chev);

    const body=document.createElement("div");
    body.className="other-player-body";

    // status line
    const statusLine=document.createElement("div");
    statusLine.className="status-line-other";

    const statusText=document.createElement("div");
    statusText.textContent="Status: "+pl.status.toUpperCase();
    statusLine.appendChild(statusText);

    if(pl.status==="active"){
      if(gameMode==="rumble"){
        const koBtn=document.createElement("div");
        koBtn.className="cool-btn-inline";
        koBtn.textContent="Knock Out → Cooldown";
        koBtn.addEventListener("click",()=>{
          sendToCooldown(i);
          renderAll();
        });
        statusLine.appendChild(koBtn);
      }else{
        const elimBtn=document.createElement("div");
        elimBtn.className="cool-btn-inline";
        elimBtn.textContent="Eliminate Player";
        elimBtn.addEventListener("click",()=>{
          permanentlyEliminate(i);
          renderAll();
        });
        statusLine.appendChild(elimBtn);
      }
    }

    // cooldown row (only rumble, only if cooldown)
    if(gameMode==="rumble" && pl.status==="cooldown"){
      const cdWrap=document.createElement("div");
      cdWrap.className="cool-row-inline";

      const cdLab=document.createElement("div");
      cdLab.className="cd-label";
      cdLab.style.fontSize=".6rem";
      cdLab.style.color="var(--text-dim)";
      cdLab.style.textTransform="uppercase";
      cdLab.style.letterSpacing=".05em";
      cdLab.textContent="CD Left:";

      const cdStepper=document.createElement("div");
      cdStepper.className="mini-step-row";

      const cdMinus=document.createElement("div");
      cdMinus.className="step-btn";
      cdMinus.textContent="-";
      cdMinus.addEventListener("click",()=>{
        adjustCooldownRemaining(i,-1,false);
      });
      const cdVal=document.createElement("div");
      cdVal.className="step-val";
      cdVal.textContent=pl.cooldownRemaining;
      const cdPlus=document.createElement("div");
      cdPlus.className="step-btn";
      cdPlus.textContent="+";
      cdPlus.addEventListener("click",()=>{
        adjustCooldownRemaining(i,1,false);
      });

      cdStepper.appendChild(cdMinus);
      cdStepper.appendChild(cdVal);
      cdStepper.appendChild(cdPlus);

      cdWrap.appendChild(cdLab);
      cdWrap.appendChild(cdStepper);

      statusLine.appendChild(cdWrap);
    }

    // player total time chunk
    const timeBox=document.createElement("div");
    timeBox.className="cool-row-inline";
    const tLab=document.createElement("div");
    tLab.className="cd-label";
    tLab.textContent="Total Time:";
    const tVal=document.createElement("div");
    tVal.className="cool-val-box";
    tVal.textContent=msToClock(getPlayerTotalMs(pl));
    timeBox.appendChild(tLab);
    timeBox.appendChild(tVal);
    statusLine.appendChild(timeBox);

    body.appendChild(statusLine);

    // life / counters
    const lifeCol=document.createElement("div");
    lifeCol.className="mini-col";

    const lifeLab=document.createElement("div");
    lifeLab.className="label-sm";
    lifeLab.textContent="Life Total ("+nm+")";

    const lifeRow=document.createElement("div");
    lifeRow.className="life-edit-inline";

    const minusBtn=document.createElement("div");
    minusBtn.className="life-inline-btn";
    minusBtn.textContent="-";
    minusBtn.addEventListener("click",()=>{
      pl.life = pl.life-1;
      if(gameMode==="rumble"){
        if(pl.life<=0){
          sendToCooldown(i);
        }
      }else{
        if(pl.life<=0){
          permanentlyEliminate(i);
        }
      }
      renderAll();
    });

    const lifeVal=document.createElement("div");
    lifeVal.className="life-inline-val";
    lifeVal.textContent=pl.life;

    const plusBtn=document.createElement("div");
    plusBtn.className="life-inline-btn";
    plusBtn.textContent="+";
    plusBtn.addEventListener("click",()=>{
      pl.life = pl.life+1;
      renderAll();
    });

    lifeRow.appendChild(minusBtn);
    lifeRow.appendChild(lifeVal);
    lifeRow.appendChild(plusBtn);
    lifeCol.appendChild(lifeLab);
    lifeCol.appendChild(lifeRow);

    body.appendChild(lifeCol);

    // poison/rad/exp/storm etc row
    const debuffRow=document.createElement("div");
    debuffRow.className="mini-row";

    debuffRow.appendChild(smallStepperBox("☠ Poison",pl.poison,(v)=>{
      pl.poison=v;
      if(gameMode==="rumble"){
        if(pl.poison>=10){
          sendToCooldown(i);
        }
      }else{
        if(pl.poison>=10){
          permanentlyEliminate(i);
        }
      }
      renderAll();
    }));

    debuffRow.appendChild(smallStepperBox("☢ Rad",pl.radiation,(v)=>{
      pl.radiation=v;
      renderAll();
    }));

    debuffRow.appendChild(smallStepperBox("★ Exp",pl.experience,(v)=>{
      pl.experience=v;
      renderAll();
    }));

    debuffRow.appendChild(smallStepperBox("☁ Storm",pl.storm,(v)=>{
      pl.storm=v;
      renderAll();
    }));

    body.appendChild(debuffRow);

    // commander damage GRID
    const cdmgWrap=document.createElement("div");
    cdmgWrap.className="cdmg-section-wrap";

    const cdmgLab=document.createElement("div");
    cdmgLab.className="cdmg-label";
    cdmgLab.textContent=
      "Commander Damage Taken by "+nm+
      " (21 from any 1 source = elim)";
    cdmgWrap.appendChild(cdmgLab);

    const cdmgGrid=document.createElement("div");
    cdmgGrid.className="cdmg-grid";

    players.forEach((srcPl,srcIdx)=>{
      const srcName=srcPl.name||("P"+(srcIdx+1));
      const cell=document.createElement("div");
      cell.className="cdmg-cell";

      const cellLabel=document.createElement("div");
      cellLabel.className="cdmg-cell-label";
      cellLabel.textContent="from "+srcName;

      const inputRow=document.createElement("div");
      inputRow.className="cdmg-input-row";

      const dmgIn=document.createElement("input");
      dmgIn.type="number";
      dmgIn.min="0";
      dmgIn.value=pl.commanderDamage[srcIdx]||0;
      dmgIn.addEventListener("input",e=>{
        let v=parseInt(e.target.value,10);
        if(isNaN(v)||v<0) v=0;
        pl.commanderDamage[srcIdx]=v;
        checkCommanderDamageElim(i);
        renderAll();
      });

      inputRow.appendChild(dmgIn);
      cell.appendChild(cellLabel);
      cell.appendChild(inputRow);
      cdmgGrid.appendChild(cell);
    });

    cdmgWrap.appendChild(cdmgGrid);
    body.appendChild(cdmgWrap);

    // note box
    const miniNote=document.createElement("div");
    miniNote.className="mini-note-box";
    const mnLab=document.createElement("div");
    mnLab.className="mini-note-label";
    mnLab.textContent="Note on "+nm+" (Monarch, Goaded, etc.)";
    const mnArea=document.createElement("textarea");
    mnArea.className="mini-area-input";
    mnArea.value=pl.notesText;
    mnArea.addEventListener("input",e=>{
      pl.notesText=e.target.value;
    });
    miniNote.appendChild(mnLab);
    miniNote.appendChild(mnArea);
    body.appendChild(miniNote);

    top.addEventListener("click",()=>{
      if(body.style.display==="flex"){
        body.style.display="none";
        chev.textContent="▼";
      }else{
        body.style.display="flex";
        chev.textContent="▲";
      }
    });

    block.appendChild(top);
    block.appendChild(body);

    wrap.appendChild(block);
  });

  othersArea.appendChild(wrap);
}

function smallStepperBox(labelText,val,onSet){
  const box=document.createElement("div");
  box.className="mini-col";

  const l=document.createElement("div");
  l.className="label-sm";
  l.textContent=labelText;

  const row=document.createElement("div");
  row.className="mini-step-row";

  const minus=document.createElement("div");
  minus.className="step-btn";
  minus.textContent="-";
  minus.addEventListener("click",()=>{
    let v=val-1;
    if(v<0)v=0;
    onSet(v);
  });

  const mid=document.createElement("div");
  mid.className="step-val";
  mid.textContent=val;

  const plus=document.createElement("div");
  plus.className="step-btn";
  plus.textContent="+";
  plus.addEventListener("click",()=>{
    let v=val+1;
    if(v<0)v=0;
    onSet(v);
  });

  row.appendChild(minus);
  row.appendChild(mid);
  row.appendChild(plus);

  box.appendChild(l);
  box.appendChild(row);
  return box;
}

/* accordions for current player */
function renderAccordions(){
  accordionsArea.innerHTML="";
  const p=players[turnIndex];
  if(!p){return;}

  const acc1 = makeAccordion(
    "statusEffects",
    "Status Effects / Titles",
    "Monarch, Initiative, Blessing, Dungeon, Emblems",
    (body)=>{
      const togglesRow=document.createElement("div");
      togglesRow.className="row-flex";

      togglesRow.appendChild(makeToggleChip("Monarch",p.hasMonarch,val=>{
        p.hasMonarch=val; renderAll();
      }));
      togglesRow.appendChild(makeToggleChip("Initiative",p.hasInitiative,val=>{
        p.hasInitiative=val; renderAll();
      }));
      togglesRow.appendChild(makeToggleChip("Blessing",p.hasCitysBlessing,val=>{
        p.hasCitysBlessing=val; renderAll();
      }));

      body.appendChild(togglesRow);

      const dLabel=document.createElement("div");
      dLabel.className="label-sm";
      dLabel.textContent="Dungeon / Undercity / Progress";

      const dArea=document.createElement("textarea");
      dArea.className="area-input";
      dArea.placeholder="Initiative, Undercity steps, dungeon rooms..."
      dArea.value=p.dungeonProgress;
      dArea.addEventListener("input",e=>{
        p.dungeonProgress=e.target.value;
      });

      const eLabel=document.createElement("div");
      eLabel.className="label-sm";
      eLabel.textContent="Emblems / Globals";

      const eArea=document.createElement("textarea");
      eArea.className="area-input";
      eArea.placeholder="Emblems, static buffs, city-wide effects..."
      eArea.value=p.emblemsText;
      eArea.addEventListener("input",e=>{
        p.emblemsText=e.target.value;
      });

      body.appendChild(dLabel);
      body.appendChild(dArea);
      body.appendChild(eLabel);
      body.appendChild(eArea);
    }
  );

  const acc2 = makeAccordion(
    "notes",
    "Notes / Reminders",
    "Goad, skip draw, bounty, upkeep triggers",
    (body)=>{
      const notesLabel=document.createElement("div");
      notesLabel.className="label-sm";
      notesLabel.textContent="Notes";
      const notesArea=document.createElement("textarea");
      notesArea.className="area-input";
      notesArea.placeholder="Ex: Goaded Krenko vs Jess; Skip next draw; Bounty on Theo"
      notesArea.value=p.notesText;
      notesArea.addEventListener("input",e=>{
        p.notesText=e.target.value;
      });

      body.appendChild(notesLabel);
      body.appendChild(notesArea);
    }
  );

  const acc3 = makeAccordion(
    "lookup",
    "Card Lookup (Scryfall)",
    "Pull card text + auto reminders",
    (body)=>{
      const lookRow=document.createElement("div");
      lookRow.className="lookup-row";

      const lookInput=document.createElement("input");
      lookInput.className="lookup-input";
      lookInput.placeholder="Search card..."
      lookInput.value=p.lookupNameInput;
      lookInput.addEventListener("input",e=>{
        p.lookupNameInput=e.target.value;
      });

      const lookBtn=document.createElement("button");
      lookBtn.className="lookup-btn";
      lookBtn.textContent="Lookup";
      lookBtn.addEventListener("click",()=>{
        doLookup(turnIndex);
      });

      lookRow.appendChild(lookInput);
      lookRow.appendChild(lookBtn);

      const lookResults=document.createElement("div");
      lookResults.className="lookup-results";

      if(p.lastLookupName || p.lastLookupResult){
        const textDiv=document.createElement("div");
        textDiv.className="lookup-cardtext";
        textDiv.textContent=
          (p.lastLookupName? p.lastLookupName+"\n":"")+
          (p.lastLookupResult||"");

        lookResults.appendChild(textDiv);

        if(p.lastLookupImg){
          const imgWrap=document.createElement("div");
          imgWrap.className="lookup-cardimg";
          const img=document.createElement("img");
          img.src=p.lastLookupImg;
          img.alt=p.lastLookupName||"card art";
          imgWrap.appendChild(img);
          lookResults.appendChild(imgWrap);
        }
      }else{
        const hint=document.createElement("div");
        hint.className="small-hint";
        hint.textContent="Auto-marks Monarch / Initiative and upkeep triggers in Notes.";
        lookResults.appendChild(hint);
      }

      body.appendChild(lookRow);
      body.appendChild(lookResults);
    }
  );

  accordionsArea.appendChild(acc1);
  accordionsArea.appendChild(acc2);
  accordionsArea.appendChild(acc3);
}

function makeToggleChip(label,active,onToggle){
  const chip=document.createElement("div");
  chip.className="toggle-chip"+(active?" active":"");
  chip.textContent=active?(label+" ✓"):label;
  chip.addEventListener("click",()=>{ onToggle(!active); });
  return chip;
}

function makeAccordion(key,title,hint,fillBodyFn){
  const wrap=document.createElement("div");
  wrap.className="accordion-block";

  const head=document.createElement("div");
  head.className="accordion-head";

  const leftSpan=document.createElement("div");
  leftSpan.textContent=title;

  const rightSpan=document.createElement("div");
  rightSpan.style.display="flex";
  rightSpan.style.gap=".5rem";
  rightSpan.style.alignItems="center";

  const hintEl=document.createElement("div");
  hintEl.className="hint";
  hintEl.textContent=hint;

  const chevron=document.createElement("div");
  chevron.style.color="var(--text-dim)";
  chevron.style.fontSize=".8rem";

  rightSpan.appendChild(hintEl);
  rightSpan.appendChild(chevron);

  head.appendChild(leftSpan);
  head.appendChild(rightSpan);

  const body=document.createElement("div");
  body.className="accordion-body";

  fillBodyFn(body);

  if(accordionsOpen[key]){
    body.style.display="block";
    chevron.textContent="▲";
  }else{
    body.style.display="none";
    chevron.textContent="▼";
  }

  head.addEventListener("click",()=>{
    accordionsOpen[key]=!accordionsOpen[key];
    if(accordionsOpen[key]){
      body.style.display="block";
      chevron.textContent="▲";
    }else{
      body.style.display="none";
      chevron.textContent="▼";
    }
  });

  wrap.appendChild(head);
  wrap.appendChild(body);
  return wrap;
}

/* =========================
   STATUS / COOLDOWN ADJUST
========================= */

function cycleStatus(i){
  const p=players[i];
  // stop timing if we leave active
  if(p.status==="active"){
    stopTimingPlayer(i);
  }

  if(gameMode==="rumble"){
    // active -> cooldown -> eliminated -> active
    if(p.status==="active"){
      // go cooldown
      let othersCooling=0;
      players.forEach((q,qi)=>{
        if(qi!==i && q.status==="cooldown") othersCooling++;
      });
      p.status="cooldown";
      p.cooldownRemaining=1+othersCooling;
    }else if(p.status==="cooldown"){
      permanentlyEliminate(i);
    }else{
      // eliminated -> back active (house tool convenience)
      p.status="active";
      p.cooldownRemaining=0;
      if(p.life<1){ p.life=1; }
    }
  }else{
    // regular: active -> eliminated -> active
    if(p.status==="active"){
      permanentlyEliminate(i);
    }else{
      p.status="active";
      if(p.life<1){ p.life=1; }
    }
  }

  updateReigningCandidate();
  renderAll();
}

function adjustCooldownRemaining(i,delta,fromSelfHUD){
  if(gameMode!=="rumble") return;
  const p=players[i];
  if(p.status!=="cooldown") return;

  p.cooldownRemaining += delta;
  if(p.cooldownRemaining<0) p.cooldownRemaining=0;

  if(p.cooldownRemaining===0){
    pendingCooldownFinishIndex=i;
    pendingCooldownMode="normalFinish";
    showCooldownFinishOverlay(i);
  }

  renderAll();
}

/* =========================
   SETUP / NEW GAME / MODE SWITCH
========================= */

function resetGameStateKeepMode(){
  players=[];
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;
  winnerName="";
  winnerTimeMs=0;
  winnerActiveMs=0;
  pendingRespawnIndex=null;
  pendingCooldownFinishIndex=null;
  pendingCooldownMode=null;

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  setupStepMode.style.display="none";     // keep same mode
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

function showModeStep(){
  // step 1: pick mode
  players=[];
  gameStartTime=null;
  winnerLocked=false;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;

  if(renderIntervalId){
    clearInterval(renderIntervalId);
    renderIntervalId=null;
  }

  setupStepMode.style.display="flex";
  setupStepPlayers.style.display="none";
  setupOverlay.style.display="flex";
}
function showPlayerCountStep(){
  // step 2: pick player count with current gameMode
  setupStepMode.style.display="none";
  setupStepPlayers.style.display="flex";
  setupOverlay.style.display="flex";
}

/* mode select buttons */
setupStepMode.querySelectorAll("[data-mode]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const m=btn.getAttribute("data-mode");
    gameMode=m==="regular"?"regular":"rumble";
    showPlayerCountStep();
  });
});

/* player count select buttons */
setupStepPlayers.querySelectorAll("[data-fixedplayers]").forEach(btn=>{
  btn.addEventListener("click",()=>{
    const n=parseInt(btn.getAttribute("data-fixedplayers"),10);
    startGameWith(n);
  });
});

manualStartBtn.addEventListener("click",()=>{
  let n=parseInt(manualPlayerCount.value,10);
  if(isNaN(n)||n<2)n=2;
  if(n>8)n=8;
  startGameWith(n);
});

function startGameWith(nPlayers){
  players=[];
  for(let i=0;i<nPlayers;i++){
    players.push(makePlayer("Player "+(i+1)));
  }
  turnIndex=0;
  turnCounter=0;
  reigningCandidateIndex=null;
  reigningCandidateTurnStamp=null;
  winnerLocked=false;
  winnerName="";
  winnerTimeMs=0;
  winnerActiveMs=0;
  pendingRespawnIndex=null;
  pendingCooldownFinishIndex=null;
  pendingCooldownMode=null;

  gameStartTime=Date.now();

  syncCommanderDamageArrays();
  updateReigningCandidate();

  setupOverlay.style.display="none";

  // timing: start first player's timer if they're active
  if(players[0] && players[0].status==="active"){
    startTimingPlayer(0);
  }

  renderAll();

  // start 1s interval to keep Turn Time / Total Time live
  if(renderIntervalId){
    clearInterval(renderIntervalId);
  }
  renderIntervalId=setInterval(()=>{
    if(!winnerLocked){
      // just refresh timer visuals
      renderAll();
    }
  },1000);
}

/* =========================
   EVENT LISTENERS
========================= */

endTurnBtn.addEventListener("click",()=>{
  passTurn();
});

</script>
</body>
</html>